CCS PCH C Compiler, Version 5.117, 2295               10-Apr-24 12:54

               Filename:   C:\Users\James Jarvis\Desktop\planetPrecision\dcswc_module_voltage_current_counter\dcswc_module_voltage_current_counter.lst

               ROM used:   2620 bytes (16%)
                           Largest free fragment is 13760
               RAM used:   114 (22%) at main() level
                           133 (26%) worst case
               Stack used: 5 locations (3 in main + 2 for interrupts)
               Stack size: 31

*
0000:  GOTO   08A4
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  FF5,15
003C:  MOVFF  FF6,16
0040:  MOVFF  FF7,17
0044:  MOVFF  00,0E
0048:  MOVFF  01,0F
004C:  MOVFF  02,10
0050:  MOVFF  03,11
0054:  BTFSS  F9D.1
0056:  GOTO   0060
005A:  BTFSC  F9E.1
005C:  GOTO   00BA
0060:  BTFSS  F9D.3
0062:  GOTO   006C
0066:  BTFSC  F9E.3
0068:  GOTO   039E
006C:  MOVFF  0E,00
0070:  MOVFF  0F,01
0074:  MOVFF  10,02
0078:  MOVFF  11,03
007C:  MOVFF  0C,FE9
0080:  MOVFF  07,FEA
0084:  BSF    07.7
0086:  MOVFF  08,FE1
008A:  MOVFF  09,FE2
008E:  MOVFF  0A,FD9
0092:  MOVFF  0B,FDA
0096:  MOVFF  12,FF3
009A:  MOVFF  13,FF4
009E:  MOVFF  14,FFA
00A2:  MOVFF  15,FF5
00A6:  MOVFF  16,FF6
00AA:  MOVFF  17,FF7
00AE:  MOVF   04,W
00B0:  MOVFF  06,FE0
00B4:  MOVFF  05,FD8
00B8:  RETFIE 0
.................... #include "dcswc_module_voltage_current_counter.h"
.................... #include <18F14K22.h>
.................... //////////// Standard Header file for the PIC18F14K22 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18F14K22
*
0450:  DATA 23,20
0452:  DATA 64,63
0454:  DATA 73,77
0456:  DATA 63,5F
0458:  DATA 6D,6F
045A:  DATA 64,75
045C:  DATA 6C,65
045E:  DATA 5F,76
0460:  DATA 6F,6C
0462:  DATA 74,61
0464:  DATA 67,65
0466:  DATA 5F,63
0468:  DATA 75,72
046A:  DATA 72,65
046C:  DATA 6E,74
046E:  DATA 5F,63
0470:  DATA 6F,75
0472:  DATA 6E,74
0474:  DATA 65,72
0476:  DATA 20,25
0478:  DATA 73,0D
047A:  DATA 0A,23
047C:  DATA 20,00
047E:  DATA 31,30
0480:  DATA 2D,41
0482:  DATA 70,72
0484:  DATA 2D,32
0486:  DATA 34,00
0488:  DATA 57,44
048A:  DATA 54,20
048C:  DATA 54,49
048E:  DATA 4D,45
0490:  DATA 4F,55
0492:  DATA 54,00
0494:  DATA 4D,43
0496:  DATA 4C,52
0498:  DATA 20,46
049A:  DATA 52,4F
049C:  DATA 4D,20
049E:  DATA 53,4C
04A0:  DATA 45,45
04A2:  DATA 50,00
04A4:  DATA 4D,43
04A6:  DATA 4C,52
04A8:  DATA 20,46
04AA:  DATA 52,4F
04AC:  DATA 4D,20
04AE:  DATA 52,55
04B0:  DATA 4E,00
04B2:  DATA 4E,4F
04B4:  DATA 52,4D
04B6:  DATA 41,4C
04B8:  DATA 20,50
04BA:  DATA 4F,57
04BC:  DATA 45,52
04BE:  DATA 20,55
04C0:  DATA 50,00
04C2:  DATA 42,52
04C4:  DATA 4F,57
04C6:  DATA 4E,4F
04C8:  DATA 55,54
04CA:  DATA 20,52
04CC:  DATA 45,53
04CE:  DATA 54,41
04D0:  DATA 52,54
04D2:  DATA 00,00
04D4:  DATA 57,44
04D6:  DATA 54,20
04D8:  DATA 46,52
04DA:  DATA 4F,4D
04DC:  DATA 20,53
04DE:  DATA 4C,45
04E0:  DATA 45,50
04E2:  DATA 00,00
04E4:  DATA 52,45
04E6:  DATA 53,45
04E8:  DATA 54,20
04EA:  DATA 49,4E
04EC:  DATA 53,54
04EE:  DATA 52,55
04F0:  DATA 43,54
04F2:  DATA 49,4F
04F4:  DATA 4E,00
04F6:  DATA 55,4E
04F8:  DATA 4B,4E
04FA:  DATA 4F,57
04FC:  DATA 4E,21
04FE:  DATA 00,00
*
064A:  TBLRD*+
064C:  MOVFF  FF6,73
0650:  MOVFF  FF7,74
0654:  MOVF   FF5,W
0656:  BTFSS  F9E.4
0658:  BRA    0656
065A:  MOVWF  FAD
065C:  MOVFF  73,FF6
0660:  MOVFF  74,FF7
0664:  DECFSZ x72,F
0666:  BRA    064A
0668:  RETURN 0
066A:  TBLRD*+
066C:  MOVF   FF5,F
066E:  BZ    068A
0670:  MOVFF  FF6,72
0674:  MOVFF  FF7,73
0678:  MOVF   FF5,W
067A:  BTFSS  F9E.4
067C:  BRA    067A
067E:  MOVWF  FAD
0680:  MOVFF  72,FF6
0684:  MOVFF  73,FF7
0688:  BRA    066A
068A:  RETURN 0
.................... 
.................... #list
.................... 
.................... #device ADC=10
.................... #device *=16
.................... #use delay(clock=16MHz)
*
0622:  CLRF   FEA
0624:  MOVLW  72
0626:  MOVWF  FE9
0628:  MOVF   FEF,W
062A:  BZ    0648
062C:  MOVLW  05
062E:  MOVWF  01
0630:  CLRF   00
0632:  DECFSZ 00,F
0634:  BRA    0632
0636:  DECFSZ 01,F
0638:  BRA    0630
063A:  MOVLW  2E
063C:  MOVWF  00
063E:  DECFSZ 00,F
0640:  BRA    063E
0642:  BRA    0644
0644:  DECFSZ FEF,F
0646:  BRA    062C
0648:  RETURN 0
.................... 
.................... /* hardware I2C port is slave and is connected to DCSWC bus */
.................... #use i2c(stream=STREAM_SLAVE,SLAVE, I2C1, FORCE_HW)
*
0388:  MOVF   FC9,W
038A:  MOVFF  80,FC9
038E:  BSF    FC6.4
0390:  BCF    F9E.3
0392:  BTFSC  FC7.0
0394:  BRA    0392
0396:  CLRF   01
0398:  BTFSS  FC5.6
039A:  INCF   01,F
039C:  RETURN 0
.................... /* slave address set based on dip switch in init() */
.................... /* Linux / i2cdetect will use the CCS address >>1. So 0x34 becomes 0x1a */
.................... 
.................... 
.................... 
.................... /* important FUSE notes! 
.................... MPLAB defaults to DEBUG mode and that will override fuses.
.................... make sure it is on "BUILD CONFIGURATION" of "RELEASE" under
.................... "PROJECT" menu.
.................... 
.................... CCS setup functions can override fuses. Check .LST file
.................... to see if anything has been overriden!
.................... */
.................... 
.................... #fuses NODEBUG 
.................... #fuses HS
.................... #fuses NOPCLKEN
.................... #fuses NOPLLEN
.................... #fuses NOFCMEN
.................... #fuses NOIESO
.................... #fuses BROWNOUT
.................... #fuses BORV30
.................... #fuses NOPUT
.................... #fuses WDT
.................... #fuses WDT128     /* this can be override by setup_wdt() */
.................... #fuses NOHFOFST
.................... #fuses NOMCLR
.................... #fuses STVREN
.................... #fuses NOLVP
.................... #fuses NOXINST
.................... #fuses NODEBUG
.................... #fuses NOPROTECT
.................... #fuses NOWRT
.................... #fuses NOWRTC 
.................... #fuses NOWRTB
.................... #fuses NOWRTD
.................... #fuses NOEBTR
.................... #fuses NOEBTRB
.................... #fuses BBSIZ1K
.................... 
.................... 
.................... #use standard_io(ALL)
.................... 
.................... #use rs232(UART1,stream=STREAM_FTDI,baud=9600,errors)	
.................... 
.................... /* program config CRC of 0 and a serial_prefix of 'A' ... that will trigger a write default on first boot */
.................... #ROM 0xF00000 = { 0x00, 0x00, 0x40, 0x00 }
.................... 
.................... 
.................... 
.................... #define COUNT_B              PIN_C5
.................... #define COUNT_A              PIN_C4
.................... #define LED_A                PIN_C3
.................... #define PIC_ADDR_MSB         PIN_C6
.................... #define PIC_ADDR_LSB         PIN_C7
.................... #define SER_TO_PC            PIN_B7
.................... 
.................... #define INA_ALERT            PIN_A2
.................... #define I2C_SW_SDA           PIN_C0
.................... #define I2C_SW_SCL           PIN_C1
.................... #define TP2                  PIN_C2
.................... #define I2C_SDA              PIN_B4
.................... #define SER_FROM_PC          PIN_B5
.................... #define I2C_SCL              PIN_B6
.................... 
.................... 
.................... /* software I2C port is maser and is connected to two INA228A */
.................... #use i2c(stream=STREAM_MASTER, MASTER, FAST, FORCE_SW, scl=I2C_SW_SCL, sda=I2C_SW_SDA)
*
0520:  MOVLW  08
0522:  MOVWF  01
0524:  NOP   
0526:  BCF    F8B.1
0528:  BCF    F94.1
052A:  NOP   
052C:  RLCF   x79,F
052E:  BCF    F8B.0
0530:  BTFSC  FD8.0
0532:  BSF    F94.0
0534:  BTFSS  FD8.0
0536:  BCF    F94.0
0538:  BSF    F94.1
053A:  BTFSS  F82.1
053C:  BRA    053A
053E:  DECFSZ 01,F
0540:  BRA    0524
0542:  NOP   
0544:  BCF    F8B.1
0546:  BCF    F94.1
0548:  NOP   
054A:  BSF    F94.0
054C:  NOP   
054E:  NOP   
0550:  BSF    F94.1
0552:  BTFSS  F82.1
0554:  BRA    0552
0556:  CLRF   01
0558:  NOP   
055A:  BTFSC  F82.0
055C:  BSF    01.0
055E:  BCF    F8B.1
0560:  BCF    F94.1
0562:  BCF    F8B.0
0564:  BCF    F94.0
0566:  RETURN 0
*
068C:  MOVLW  08
068E:  MOVWF  x7B
0690:  MOVFF  00,7C
0694:  BSF    F94.0
0696:  NOP   
0698:  BSF    F94.1
069A:  BTFSS  F82.1
069C:  BRA    069A
069E:  BTFSC  F82.0
06A0:  BSF    FD8.0
06A2:  BTFSS  F82.0
06A4:  BCF    FD8.0
06A6:  RLCF   01,F
06A8:  NOP   
06AA:  BCF    F94.1
06AC:  BCF    F8B.1
06AE:  DECFSZ x7B,F
06B0:  BRA    0694
06B2:  BSF    F94.0
06B4:  NOP   
06B6:  BCF    F8B.0
06B8:  MOVF   x7C,W
06BA:  BTFSS  FD8.2
06BC:  BCF    F94.0
06BE:  NOP   
06C0:  BSF    F94.1
06C2:  BTFSS  F82.1
06C4:  BRA    06C2
06C6:  NOP   
06C8:  BCF    F8B.1
06CA:  BCF    F94.1
06CC:  NOP   
06CE:  BCF    F8B.0
06D0:  BCF    F94.0
06D2:  RETURN 0
.................... 
.................... 
.................... 
.................... #define INA228_A_ADDR      0x80
.................... #define INA228_B_ADDR      0x9a
.................... 
.................... 
.................... 
.................... #define ADCRANGE 1
.................... 
.................... typedef struct {
.................... 	int32 vbus_a, vshunt_a;
.................... 	int32 vbus_b, vshunt_b;
.................... 
.................... 	int16 count_a_last_second, count_b_last_second;
.................... 
.................... 	int32 count_a_long;
.................... 	int32 count_b_long;
.................... 	int32 count_seconds_long;
.................... 
.................... 	int16 dietemp_a;
.................... 	int16 dietemp_b;
.................... } struct_current;
.................... 
.................... typedef struct {
.................... 	/* action flags */
.................... 	int1 now_millisecond;
.................... 
.................... 	int1 now_ina;    // query ina registers
.................... 
.................... 	int1 now_dump;   // debugging
.................... 
.................... 	/* timers */
.................... 	int8 led_on_a;
.................... } struct_time_keep;
.................... 
.................... /* global structures */
.................... struct_current current={0};
.................... struct_current next={0};
.................... struct_time_keep timers={0};
.................... 
.................... #include "ina228.c"
.................... #define INA228_REG_CONFIG       0x00  // 16 bits, configuration
.................... #define INA228_REG_ADC_CONFIG   0x01  // 16 bits, ADC configuration
.................... #define INA228_REG_SHUNT_CAL    0x02  // 16 bits, shunt calibration
.................... #define INA228_REG_SHUNT_TEMPCO 0x03  // 16 bits, shunt temperature coefficient
.................... #define INA228_REG_VSHUNT       0x04  // 24 bits, shunt voltage measurement
.................... #define INA228_REG_VBUS         0x05  // 24 bits, bus voltage measurement
.................... #define INA228_REG_DIETEMP      0x06  // 16 bits, temperature measurement
.................... #define INA228_REG_CURRENT      0x07  // 24 bits, current result
.................... #define INA228_REG_POWER        0x08  // 24 bits, power result 
.................... #define INA228_REG_ENERGY       0x09  // 40 bits, energy result
.................... #define INA228_REG_CHARGE       0x0a  // 40 bits, charge result
.................... #define INA228_REG_DIAG_ALRT    0x0b  // 16 bits, diagnostic flags and alert
.................... #define INA228_REG_SOVL         0x0c  // 16 bits, shunt overvoltage threshold
.................... #define INA228_REG_SUVL         0x0d  // 16 bits, shunt undervoltage threshold
.................... #define INA228_REG_BOVL         0x0e  // 16 bits, bus overvoltage threshold
.................... #define INA228_REG_BUVL         0x0f  // 16 bits, bus undervoltage threshold
.................... #define INA228_REG_TEMP_LIMIT   0x10  // 16 bits, temperature over-limit threshold
.................... #define INA228_REG_PWR_LIMIT    0x11  // 16 bits, power over-limit threshold
.................... #define INA228_REG_MFG_ID       0x3e  // 16 bits, manufacturer ID
.................... #define INA228_REG_DEVICE_ID    0x3f  // 16 bits, device ID
.................... 
.................... #define INA228_I2C_WRITE        0x00
.................... #define INA228_I2C_READ         0x01 
.................... 
.................... 
.................... int16 ina228_read16(int8 i2c_address, int8 regaddr) {
.................... 	int16 data;
.................... 
.................... 	i2c_start(STREAM_MASTER);
*
0772:  BSF    F94.0
0774:  NOP   
0776:  BSF    F94.1
0778:  NOP   
077A:  BCF    F8B.0
077C:  BCF    F94.0
077E:  NOP   
0780:  BCF    F8B.1
0782:  BCF    F94.1
.................... 	delay_us(15);
0784:  MOVLW  13
0786:  MOVWF  00
0788:  DECFSZ 00,F
078A:  BRA    0788
078C:  BRA    078E
.................... 	i2c_write(STREAM_MASTER,i2c_address);
078E:  MOVFF  72,79
0792:  RCALL  0520
.................... 	i2c_write(STREAM_MASTER,regaddr);
0794:  MOVFF  73,79
0798:  RCALL  0520
.................... 	i2c_start(STREAM_MASTER);
079A:  BSF    F94.0
079C:  NOP   
079E:  BSF    F94.1
07A0:  NOP   
07A2:  BTFSS  F82.1
07A4:  BRA    07A2
07A6:  BCF    F8B.0
07A8:  BCF    F94.0
07AA:  NOP   
07AC:  BCF    F8B.1
07AE:  BCF    F94.1
.................... 	delay_us(15);
07B0:  MOVLW  13
07B2:  MOVWF  00
07B4:  DECFSZ 00,F
07B6:  BRA    07B4
07B8:  BRA    07BA
.................... 	i2c_write(STREAM_MASTER,i2c_address | INA228_I2C_READ);  // read cycle
07BA:  MOVF   x72,W
07BC:  IORLW  01
07BE:  MOVWF  x76
07C0:  MOVWF  x79
07C2:  RCALL  0520
.................... 	data=make16(i2c_read(STREAM_MASTER,1),i2c_read(STREAM_MASTER,0));                                 
07C4:  MOVLW  01
07C6:  MOVWF  00
07C8:  RCALL  068C
07CA:  MOVFF  01,76
07CE:  CLRF   00
07D0:  RCALL  068C
07D2:  MOVFF  76,75
07D6:  MOVFF  01,74
.................... 	i2c_stop(STREAM_MASTER);
07DA:  BCF    F94.0
07DC:  NOP   
07DE:  BSF    F94.1
07E0:  BTFSS  F82.1
07E2:  BRA    07E0
07E4:  NOP   
07E6:  BRA    07E8
07E8:  NOP   
07EA:  BSF    F94.0
07EC:  NOP   
.................... 
.................... 	return data;
07EE:  MOVFF  74,01
07F2:  MOVFF  75,02
07F6:  RETURN 0
.................... }
.................... 
.................... int32 ina228_read24(int8 i2c_address, int8 regaddr) {
.................... 	int32 data;
.................... 
.................... 	i2c_start(STREAM_MASTER);
*
06D4:  BSF    F94.0
06D6:  NOP   
06D8:  BSF    F94.1
06DA:  NOP   
06DC:  BCF    F8B.0
06DE:  BCF    F94.0
06E0:  NOP   
06E2:  BCF    F8B.1
06E4:  BCF    F94.1
.................... 	delay_us(15);
06E6:  MOVLW  13
06E8:  MOVWF  00
06EA:  DECFSZ 00,F
06EC:  BRA    06EA
06EE:  BRA    06F0
.................... 	i2c_write(STREAM_MASTER,i2c_address);
06F0:  MOVFF  72,79
06F4:  RCALL  0520
.................... 	i2c_write(STREAM_MASTER,regaddr);
06F6:  MOVFF  73,79
06FA:  RCALL  0520
.................... 	i2c_start(STREAM_MASTER);
06FC:  BSF    F94.0
06FE:  NOP   
0700:  BSF    F94.1
0702:  NOP   
0704:  BTFSS  F82.1
0706:  BRA    0704
0708:  BCF    F8B.0
070A:  BCF    F94.0
070C:  NOP   
070E:  BCF    F8B.1
0710:  BCF    F94.1
.................... 	delay_us(15);
0712:  MOVLW  13
0714:  MOVWF  00
0716:  DECFSZ 00,F
0718:  BRA    0716
071A:  BRA    071C
.................... 	i2c_write(STREAM_MASTER,i2c_address | INA228_I2C_READ);  // read cycle
071C:  MOVF   x72,W
071E:  IORLW  01
0720:  MOVWF  x78
0722:  MOVWF  x79
0724:  RCALL  0520
.................... 	data=make32(0,i2c_read(STREAM_MASTER,1),i2c_read(STREAM_MASTER,1),i2c_read(STREAM_MASTER,0));
0726:  MOVLW  01
0728:  MOVWF  00
072A:  RCALL  068C
072C:  MOVFF  01,78
0730:  MOVLW  01
0732:  MOVWF  00
0734:  RCALL  068C
0736:  MOVFF  01,79
073A:  CLRF   00
073C:  RCALL  068C
073E:  CLRF   x77
0740:  MOVFF  78,76
0744:  MOVFF  79,75
0748:  MOVFF  01,74
.................... 	i2c_stop(STREAM_MASTER);
074C:  BCF    F94.0
074E:  NOP   
0750:  BSF    F94.1
0752:  BTFSS  F82.1
0754:  BRA    0752
0756:  NOP   
0758:  BRA    075A
075A:  NOP   
075C:  BSF    F94.0
075E:  NOP   
.................... 
.................... 	return data;
0760:  MOVFF  74,00
0764:  MOVFF  75,01
0768:  MOVFF  76,02
076C:  MOVFF  77,03
0770:  RETURN 0
.................... }
.................... 
.................... void ina228_write16(int8 i2c_address, int8 regaddr, int16 value) {
.................... 	i2c_start(STREAM_MASTER);
*
0568:  BSF    F94.0
056A:  NOP   
056C:  BSF    F94.1
056E:  NOP   
0570:  BCF    F8B.0
0572:  BCF    F94.0
0574:  NOP   
0576:  BCF    F8B.1
0578:  BCF    F94.1
.................... 	delay_us(15);                                                 
057A:  MOVLW  13
057C:  MOVWF  00
057E:  DECFSZ 00,F
0580:  BRA    057E
0582:  BRA    0584
.................... 	i2c_write(STREAM_MASTER,i2c_address); // write cycle                       
0584:  MOVFF  73,79
0588:  RCALL  0520
.................... 	i2c_write(STREAM_MASTER,regaddr);  // write cycle         
058A:  MOVFF  74,79
058E:  RCALL  0520
.................... 	i2c_write(STREAM_MASTER,make8(value,1));
0590:  MOVFF  76,79
0594:  RCALL  0520
.................... 	i2c_write(STREAM_MASTER,make8(value,0));
0596:  MOVFF  75,79
059A:  RCALL  0520
.................... 	i2c_stop(STREAM_MASTER);
059C:  BCF    F94.0
059E:  NOP   
05A0:  BSF    F94.1
05A2:  BTFSS  F82.1
05A4:  BRA    05A2
05A6:  NOP   
05A8:  BRA    05AA
05AA:  NOP   
05AC:  BSF    F94.0
05AE:  NOP   
05B0:  RETURN 0
.................... }
.................... 
.................... void ina228_init(int8 i2c_address) {
.................... 	/* 
.................... 	INA228_REG_CONFIG (from table 7-5 in INA228 datasheet
.................... 		bit[15]            RST      (R/W) Reset bit
.................... 		bit[14]            RSTACC   (R/W) Resets the contents of accumulation registers ENERGY and CHARGE to 0
.................... 		bit[13] to bit[ 6] CONDLY   (R/W) Sets the Delay for initial ADC conversion in steps of 2 ms
....................                                           0h = 0 s
....................                                           1h = 2 ms
....................                                           FFh = 510 ms
.................... 		bit[ 5]            TEMPCOMP (R/W) Enables temperature compensation of an external shunt 
.................... 		bit[ 4]            ADCRANGE (R/W) Shunt full scale range selection across IN+ and IN–
....................                                           0h = ±163.84 mV
....................                                           1h = ± 40.96 mV
.................... 		bit[ 3] to bit[ 0] RESERVED (R)   Reserved. Always reads 0
....................  	*/
.................... 
.................... 	/* note that issuing a reset bit to INA228_REG_CONFIG will cause it to reset and apparently ignore the rest of the config */
.................... 
.................... 	/* no resets, no conversion delay, no shunt temperature compensation, +-40.96mV range */
.................... #if ADCRANGE == 1
.................... 	ina228_write16(i2c_address,INA228_REG_CONFIG,0b0000000000010000);
05B2:  MOVFF  72,73
05B6:  CLRF   x74
05B8:  CLRF   x76
05BA:  MOVLW  10
05BC:  MOVWF  x75
05BE:  RCALL  0568
.................... //                                                 5432109876543210
.................... //                                                 1     0
.................... #else
.................... 	ina228_write16(i2c_address,INA228_REG_CONFIG,0x00);
.................... #endif
.................... 
.................... 	/* continuous measurements, longest conversion time for voltages, shortest for temperature, 128 averaging window */
.................... 	ina228_write16(i2c_address,INA228_REG_ADC_CONFIG,0b1111111111000100);
05C0:  MOVFF  72,73
05C4:  MOVLW  01
05C6:  MOVWF  x74
05C8:  SETF   x76
05CA:  MOVLW  C4
05CC:  MOVWF  x75
05CE:  RCALL  0568
05D0:  RETURN 0
.................... 
.................... }
.................... 
.................... #include "i2c_handler_dcswc_module_voltage_current_counter.c"
.................... #include "registers_dcswc_module_voltage_current_counter.h"
.................... /* 32 bit INA228 bus and shunt voltages */
.................... #define I2C_REG_VBUS_A_MSW                    0
.................... #define I2C_REG_VBUS_A_LSW                    1
.................... #define I2C_REG_VSHUNT_A_MSW                  2
.................... #define I2C_REG_VSHUNT_A_LSW                  3
.................... 
.................... #define I2C_REG_VBUS_B_MSW                    4
.................... #define I2C_REG_VBUS_B_LSW                    5
.................... #define I2C_REG_VSHUNT_B_MSW                  6
.................... #define I2C_REG_VSHUNT_B_LSW                  7
.................... 
.................... /* 16 bit count of last (not current) second */
.................... #define I2C_REG_COUNT_A_LAST_SECOND           8
.................... #define I2C_REG_COUNT_B_LAST_SECOND           9
.................... 
.................... /* 32 bit count since reset */
.................... #define I2C_REG_COUNT_A_LONG_MSW              10
.................... #define I2C_REG_COUNT_A_LONG_LSW              11
.................... #define I2C_REG_COUNT_B_LONG_MSW              12
.................... #define I2C_REG_COUNT_B_LONG_LSW              13
.................... 
.................... /* 32 bit seconds since count reset */
.................... #define I2C_REG_COUNT_LONG_SECONDS_MSW        14
.................... #define I2C_REG_COUNT_LONG_SECONDS_LSW        15
.................... 
.................... /* 16 bit INA228 die temperatures */
.................... #define I2C_REG_DIETEMP_A                     16
.................... #define I2C_REG_DIETEMP_B                     17
.................... 
.................... 
.................... 
.................... /* test scratchpad registers for validating I2C communications */
.................... //int16 rtest[8] = { 0x0001, 0x0203, 0x0405, 0x0607, 0x0809, 0x0a0b, 0x0c0d, 0x0e0f };
.................... 
.................... 
.................... void write_i2c(int8 address, int16 value) {
.................... 	
.................... 	switch ( address ) {
*
01B2:  MOVF   x82,W
01B4:  XORLW  0E
01B6:  BZ    01BE
01B8:  XORLW  01
01BA:  BZ    01BE
01BC:  BRA    01D6
.................... #if 0
.................... 		case 0: rtest[0]=value; break;
.................... 		case 1: rtest[1]=value; break;
.................... 		case 2: rtest[2]=value; break;
.................... 		case 3: rtest[3]=value; break;
.................... 		case 4: rtest[4]=value; break;
.................... 		case 5: rtest[5]=value; break;
.................... 		case 6: rtest[6]=value; break;
.................... 		case 7: rtest[7]=value; break;
.................... #endif
.................... 
.................... 		/* write anything to either of these addresses and we reset the long counter */
.................... 		case I2C_REG_COUNT_LONG_SECONDS_MSW:
.................... 		case I2C_REG_COUNT_LONG_SECONDS_LSW:
.................... 			current.count_a_long=0;
01BE:  CLRF   31
01C0:  CLRF   30
01C2:  CLRF   2F
01C4:  CLRF   2E
.................... 			current.count_b_long=0;
01C6:  CLRF   35
01C8:  CLRF   34
01CA:  CLRF   33
01CC:  CLRF   32
.................... 			current.count_seconds_long=0;
01CE:  CLRF   39
01D0:  CLRF   38
01D2:  CLRF   37
01D4:  CLRF   36
.................... 			break;
.................... 		default:
.................... 			/* do nothing */
.................... 	}
01D6:  GOTO   041E (RETURN)
.................... 
.................... }
.................... 
.................... 
.................... int16 map_i2c(int8 addr) {
.................... 	static int16 lsw=0xffff;
.................... 
.................... 	timers.led_on_a=100;
01DA:  MOVLW  64
01DC:  MOVWF  x63
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 	switch ( addr ) {
01DE:  MOVF   x80,W
01E0:  BZ    023C
01E2:  XORLW  01
01E4:  BZ    025A
01E6:  XORLW  03
01E8:  BZ    0264
01EA:  XORLW  01
01EC:  BZ    0284
01EE:  XORLW  07
01F0:  BZ    028E
01F2:  XORLW  01
01F4:  BZ    02AC
01F6:  XORLW  03
01F8:  BZ    02B6
01FA:  XORLW  01
01FC:  BZ    02D4
01FE:  XORLW  0F
0200:  BTFSC  FD8.2
0202:  BRA    02DE
0204:  XORLW  01
0206:  BTFSC  FD8.2
0208:  BRA    02E8
020A:  XORLW  03
020C:  BTFSC  FD8.2
020E:  BRA    02F2
0210:  XORLW  01
0212:  BTFSC  FD8.2
0214:  BRA    0310
0216:  XORLW  07
0218:  BTFSC  FD8.2
021A:  BRA    031A
021C:  XORLW  01
021E:  BTFSC  FD8.2
0220:  BRA    0338
0222:  XORLW  03
0224:  BTFSC  FD8.2
0226:  BRA    0342
0228:  XORLW  01
022A:  BTFSC  FD8.2
022C:  BRA    0360
022E:  XORLW  1F
0230:  BTFSC  FD8.2
0232:  BRA    036A
0234:  XORLW  01
0236:  BTFSC  FD8.2
0238:  BRA    0374
023A:  BRA    037E
.................... #if 0
.................... 		case 0: return rtest[0];
.................... 		case 1: return rtest[1];
.................... 		case 2: return rtest[2];
.................... 		case 3: return rtest[3];
.................... 		case 4: return rtest[4];
.................... 		case 5: return rtest[5];
.................... 		case 6: return rtest[6];
.................... 		case 7: return rtest[7];
.................... #endif
.................... 
.................... 		/* 32 bit variables have the most significant word read first and that sets the
.................... 		   least sinificant word which can be read next. _LSW registers are only valid if
.................... 		   they are preceeded by a read on the matching _MSW register
.................... 		 */
.................... 		case I2C_REG_VBUS_A_MSW:
.................... 			lsw = make16(make8(current.vbus_a,1),make8(current.vbus_a,0));
023C:  MOVFF  1B,65
0240:  MOVFF  1A,64
.................... 			return (int16) make16(make8(current.vbus_a,3),make8(current.vbus_a,2));
0244:  MOVFF  1D,81
0248:  MOVFF  1C,82
024C:  MOVFF  1D,03
0250:  MOVFF  1C,01
0254:  MOVFF  1D,02
0258:  BRA    0384
.................... 		case I2C_REG_VBUS_A_LSW:
.................... 			return (int16) lsw;
025A:  MOVFF  64,01
025E:  MOVFF  65,02
0262:  BRA    0384
.................... 		case I2C_REG_VSHUNT_A_MSW:
.................... 			timers.now_dump=1;
0264:  BSF    x62.2
.................... 			lsw = make16(make8(current.vshunt_a,1),make8(current.vshunt_a,0));
0266:  MOVFF  1F,65
026A:  MOVFF  1E,64
.................... 			return (int16) make16(make8(current.vshunt_a,3),make8(current.vshunt_a,2));
026E:  MOVFF  21,81
0272:  MOVFF  20,82
0276:  MOVFF  21,03
027A:  MOVFF  20,01
027E:  MOVFF  21,02
0282:  BRA    0384
.................... 		case I2C_REG_VSHUNT_A_LSW:
.................... 			return (int16) lsw;    
0284:  MOVFF  64,01
0288:  MOVFF  65,02
028C:  BRA    0384
.................... 
.................... 		case I2C_REG_VBUS_B_MSW:
.................... 			lsw = make16(make8(current.vbus_b,1),make8(current.vbus_b,0));
028E:  MOVFF  23,65
0292:  MOVFF  22,64
.................... 			return (int16) make16(make8(current.vbus_b,3),make8(current.vbus_b,2));
0296:  MOVFF  25,81
029A:  MOVFF  24,82
029E:  MOVFF  25,03
02A2:  MOVFF  24,01
02A6:  MOVFF  25,02
02AA:  BRA    0384
.................... 		case I2C_REG_VBUS_B_LSW:
.................... 			return (int16) lsw;
02AC:  MOVFF  64,01
02B0:  MOVFF  65,02
02B4:  BRA    0384
.................... 		case I2C_REG_VSHUNT_B_MSW:
.................... 			lsw = make16(make8(current.vshunt_b,1),make8(current.vshunt_b,0));
02B6:  MOVFF  27,65
02BA:  MOVFF  26,64
.................... 			return (int16) make16(make8(current.vshunt_b,3),make8(current.vshunt_b,2));
02BE:  MOVFF  29,81
02C2:  MOVFF  28,82
02C6:  MOVFF  29,03
02CA:  MOVFF  28,01
02CE:  MOVFF  29,02
02D2:  BRA    0384
.................... 		case I2C_REG_VSHUNT_B_LSW:
.................... 			return (int16) lsw;    
02D4:  MOVFF  64,01
02D8:  MOVFF  65,02
02DC:  BRA    0384
.................... 
.................... 
.................... 		case I2C_REG_COUNT_A_LAST_SECOND:
.................... 			return (int16) current.count_a_last_second;
02DE:  MOVFF  2A,01
02E2:  MOVFF  2B,02
02E6:  BRA    0384
.................... 		case I2C_REG_COUNT_B_LAST_SECOND:
.................... 			return (int16) current.count_b_last_second;
02E8:  MOVFF  2C,01
02EC:  MOVFF  2D,02
02F0:  BRA    0384
.................... 
.................... 		case I2C_REG_COUNT_A_LONG_MSW:
.................... 			lsw = make16(make8(current.count_a_long,1),make8(current.count_a_long,0));
02F2:  MOVFF  2F,65
02F6:  MOVFF  2E,64
.................... 			return (int16) make16(make8(current.count_a_long,3),make8(current.count_a_long,2));
02FA:  MOVFF  31,81
02FE:  MOVFF  30,82
0302:  MOVFF  31,03
0306:  MOVFF  30,01
030A:  MOVFF  31,02
030E:  BRA    0384
.................... 		case I2C_REG_COUNT_A_LONG_LSW:
.................... 			return (int16) lsw;
0310:  MOVFF  64,01
0314:  MOVFF  65,02
0318:  BRA    0384
.................... 		case I2C_REG_COUNT_B_LONG_MSW:
.................... 			lsw = make16(make8(current.count_b_long,1),make8(current.count_b_long,0));
031A:  MOVFF  33,65
031E:  MOVFF  32,64
.................... 			return (int16) make16(make8(current.count_b_long,3),make8(current.count_b_long,2));
0322:  MOVFF  35,81
0326:  MOVFF  34,82
032A:  MOVFF  35,03
032E:  MOVFF  34,01
0332:  MOVFF  35,02
0336:  BRA    0384
.................... 		case I2C_REG_COUNT_B_LONG_LSW:
.................... 			return (int16) lsw;
0338:  MOVFF  64,01
033C:  MOVFF  65,02
0340:  BRA    0384
.................... 		case I2C_REG_COUNT_LONG_SECONDS_MSW:
.................... 			lsw = make16(make8(current.count_seconds_long,1),make8(current.count_seconds_long,0));
0342:  MOVFF  37,65
0346:  MOVFF  36,64
.................... 			return (int16) make16(make8(current.count_seconds_long,3),make8(current.count_seconds_long,2));
034A:  MOVFF  39,81
034E:  MOVFF  38,82
0352:  MOVFF  39,03
0356:  MOVFF  38,01
035A:  MOVFF  39,02
035E:  BRA    0384
.................... 		case I2C_REG_COUNT_LONG_SECONDS_LSW:
.................... 			return (int16) lsw;
0360:  MOVFF  64,01
0364:  MOVFF  65,02
0368:  BRA    0384
.................... 
.................... 		case I2C_REG_DIETEMP_A:
.................... 			return (int16) current.dietemp_a;
036A:  MOVFF  3A,01
036E:  MOVFF  3B,02
0372:  BRA    0384
.................... 		case I2C_REG_DIETEMP_B:
.................... 			return (int16) current.dietemp_b;
0374:  MOVFF  3C,01
0378:  MOVFF  3D,02
037C:  BRA    0384
.................... 
.................... 		/* we should have range checked, and never gotten here ... or read unimplemented (future) register */
.................... 		default: return (int16) addr;
037E:  MOVFF  80,01
0382:  CLRF   02
.................... 	}
0384:  GOTO   0432 (RETURN)
.................... 
.................... }
.................... 
.................... 
.................... 
.................... #include "interrupt_dcswc_module_voltage_current_counter.c"
.................... #int_timer2
.................... void isr_timer2() {
.................... 	static int16 ticks=0;
.................... 	static short count_a_last=0;
.................... 	static short count_b_last=0;
.................... 	short count_a_now;
.................... 	short count_b_now;
.................... 
.................... 
.................... 	/* external input counting */
.................... 	count_a_now=input(COUNT_A);
*
00BA:  BSF    F94.4
00BC:  BCF    x7D.0
00BE:  BTFSC  F82.4
00C0:  BSF    x7D.0
.................... 	if ( 0 == count_a_now && 1 == count_a_last ) {
00C2:  BTFSC  x7D.0
00C4:  BRA    00D0
00C6:  BTFSS  x68.0
00C8:  BRA    00D0
.................... 		next.count_a_last_second++;
00CA:  INCF   4E,F
00CC:  BTFSC  FD8.2
00CE:  INCF   4F,F
.................... 	}
.................... 	count_a_last=count_a_now;
00D0:  BCF    x68.0
00D2:  BTFSC  x7D.0
00D4:  BSF    x68.0
.................... 
.................... 	count_b_now=input(COUNT_B);
00D6:  BSF    F94.5
00D8:  BCF    x7D.1
00DA:  BTFSC  F82.5
00DC:  BSF    x7D.1
.................... 	if ( 0 == count_b_now && 1 == count_b_last ) {
00DE:  BTFSC  x7D.1
00E0:  BRA    00EC
00E2:  BTFSS  x68.1
00E4:  BRA    00EC
.................... 		next.count_b_last_second++;
00E6:  INCF   50,F
00E8:  BTFSC  FD8.2
00EA:  INCF   51,F
.................... 	}
.................... 	count_b_last=count_b_now;
00EC:  BCF    x68.1
00EE:  BTFSC  x7D.1
00F0:  BSF    x68.1
.................... 
.................... 
.................... 	/* timing */
.................... 
.................... 	timers.now_millisecond=1;
00F2:  BSF    x62.0
.................... 
.................... 	ticks++;
00F4:  INCF   x66,F
00F6:  BTFSC  FD8.2
00F8:  INCF   x67,F
.................... 	if ( 500 == ticks ) {
00FA:  MOVF   x66,W
00FC:  SUBLW  F4
00FE:  BNZ   0108
0100:  DECFSZ x67,W
0102:  BRA    0108
.................... 		timers.now_ina=1;
0104:  BSF    x62.1
.................... 	} else if ( 1000 == ticks ) {
0106:  BRA    01AC
0108:  MOVF   x66,W
010A:  SUBLW  E8
010C:  BNZ   01AC
010E:  MOVF   x67,W
0110:  SUBLW  03
0112:  BNZ   01AC
.................... 		current.vbus_a=next.vbus_a;
0114:  MOVFF  41,1D
0118:  MOVFF  40,1C
011C:  MOVFF  3F,1B
0120:  MOVFF  3E,1A
.................... 		current.vshunt_a=next.vshunt_a;
0124:  MOVFF  45,21
0128:  MOVFF  44,20
012C:  MOVFF  43,1F
0130:  MOVFF  42,1E
.................... 		current.dietemp_a=next.dietemp_a;	
0134:  MOVFF  5F,3B
0138:  MOVFF  5E,3A
.................... 
.................... 		current.vbus_b=next.vbus_b;
013C:  MOVFF  49,25
0140:  MOVFF  48,24
0144:  MOVFF  47,23
0148:  MOVFF  46,22
.................... 		current.vshunt_b=next.vshunt_b;
014C:  MOVFF  4D,29
0150:  MOVFF  4C,28
0154:  MOVFF  4B,27
0158:  MOVFF  4A,26
.................... 		current.dietemp_b=next.dietemp_b;
015C:  MOVFF  61,3D
0160:  MOVFF  60,3C
.................... 
.................... 		current.count_a_last_second=next.count_a_last_second;
0164:  MOVFF  4F,2B
0168:  MOVFF  4E,2A
.................... 
.................... 		current.count_b_last_second=next.count_b_last_second;	
016C:  MOVFF  51,2D
0170:  MOVFF  50,2C
.................... 
.................... 		current.count_a_long += current.count_a_last_second;
0174:  MOVF   2A,W
0176:  ADDWF  2E,F
0178:  MOVF   2B,W
017A:  ADDWFC 2F,F
017C:  MOVLW  00
017E:  ADDWFC 30,F
0180:  ADDWFC 31,F
.................... 		current.count_b_long += current.count_b_last_second;
0182:  MOVF   2C,W
0184:  ADDWF  32,F
0186:  MOVF   2D,W
0188:  ADDWFC 33,F
018A:  MOVLW  00
018C:  ADDWFC 34,F
018E:  ADDWFC 35,F
.................... 	
.................... 		current.count_seconds_long++;
0190:  MOVLW  01
0192:  ADDWF  36,F
0194:  BTFSC  FD8.0
0196:  INCF   37,F
0198:  BTFSC  FD8.2
019A:  INCF   38,F
019C:  BTFSC  FD8.2
019E:  INCF   39,F
.................... 
.................... 		/* reset our counters */
.................... 		next.count_a_last_second=0;
01A0:  CLRF   4F
01A2:  CLRF   4E
.................... 		next.count_b_last_second=0;
01A4:  CLRF   51
01A6:  CLRF   50
.................... 
.................... 		ticks=0;
01A8:  CLRF   x67
01AA:  CLRF   x66
.................... 	}
.................... }
.................... 
.................... 
.................... /* I2C slave interrupt */
01AC:  BCF    F9E.1
01AE:  GOTO   006C
.................... #byte SSPSTAT=GETENV("SFR:SSPSTAT")
.................... #INT_SSP
.................... void ssp_interrupt () {
.................... 	static int8 sstate;
.................... 	int8 state;
.................... 	int8 incoming;
.................... 	static int16 lastValue;
.................... 	static int8 lastMSB;
.................... 
.................... 	static int8 address; 
.................... 
.................... 	/* 
.................... 	our implementation of i2c_isr_state() that won't overflow and switch states
.................... 	but it will quit counting at 127 bytes. 
.................... 	If more bytes are needed, external counting variables can be used or the size of state can be made larger
.................... 	*/
.................... 
.................... 
.................... 	if ( ! bit_test(SSPSTAT,5) ) {
*
039E:  BTFSC  FC7.5
03A0:  BRA    03AA
.................... 		/* address */
.................... 		sstate=0;
03A2:  CLRF   x69
.................... 
.................... 		if ( bit_test(SSPSTAT,2) ) {
03A4:  BTFSS  FC7.2
03A6:  BRA    03AA
.................... 			/* set high bit if read */
.................... 			bit_set(sstate,7);
03A8:  BSF    x69.7
.................... 		}
.................... 	} else {
.................... 		/* data */
.................... 	}
.................... 
.................... 	/* state variable used below is not incremented */
.................... 	state=sstate;
03AA:  MOVFF  69,7D
.................... 
.................... 	/* increment the state counter for next pass through unless it will overflow us into another state */
.................... 	if ( sstate != 0x7f && sstate != 0xff) {
03AE:  MOVF   x69,W
03B0:  SUBLW  7F
03B2:  BZ    03BC
03B4:  INCFSZ x69,W
03B6:  BRA    03BA
03B8:  BRA    03BC
.................... 		sstate++;
03BA:  INCF   x69,F
.................... 	}
.................... 
.................... 	
.................... 	/* i2c_isr_state() return an 8 bit int
.................... 		0 - Address match received with R/W bit clear, perform i2c_read( ) to read the I2C address.
.................... 		1-0x7F - Master has written data; i2c_read() will immediately return the data
.................... 		0x80 - Address match received with R/W bit set; perform i2c_read( ) to read the I2C address,
.................... 		and use i2c_write( ) to pre-load the transmit buffer for the next transaction (next I2C read
.................... 		performed by master will read this byte).
.................... 		0x81-0xFF - Transmission completed and acknowledged; respond with i2c_write() to pre-load
.................... 		the transmit buffer for the next transition (the next I2C read performed by master will read this
.................... 		byte).
.................... 		Function:
.................... 		Returns the state of I2C communications in I2C slave mode after an SSP interrupt. The return
.................... 		value increments with each byte received or sent.
.................... 		If 0x00 or 0x80 is returned, an i2C_read( ) needs to be performed to read the I2C address that
.................... 		was sent (it will match the address configured by #USE I2C so this value can be ignored)
.................... 	*/
.................... 
.................... 	if ( state <= 0x80 ) {                      
03BC:  MOVF   x7D,W
03BE:  SUBLW  80
03C0:  BNC   041E
.................... 		/* I2C master is sending us data */
.................... 		if ( 0x80 == state ) {
03C2:  MOVF   x7D,W
03C4:  SUBLW  80
03C6:  BNZ   03CE
.................... 			/* i2c_read(2) casues the function to read the SSPBUF without releasing the clock */
.................... 			incoming = i2c_read(STREAM_SLAVE,2);
03C8:  MOVFF  FC9,7E
.................... 		} else {
03CC:  BRA    03DA
.................... 			incoming = i2c_read(STREAM_SLAVE);
03CE:  BCF    FC6.6
03D0:  BTFSS  FC7.0
03D2:  BRA    03D0
03D4:  MOVF   FC9,W
03D6:  BSF    FC6.4
03D8:  MOVWF  x7E
.................... 		}
.................... 
.................... 		if ( 1 == state ) {             
03DA:  DECFSZ x7D,W
03DC:  BRA    03E6
.................... 			address = incoming<<1;
03DE:  BCF    FD8.0
03E0:  RLCF   x7E,W
03E2:  MOVWF  x6D
.................... 		} else if ( state >= 2 && 0x80 != state ) {
03E4:  BRA    041E
03E6:  MOVF   x7D,W
03E8:  SUBLW  01
03EA:  BC    041E
03EC:  MOVF   x7D,W
03EE:  SUBLW  80
03F0:  BZ    041E
.................... 			/* received byte is data */
.................... 		
.................... 			/* save MSB and we'll process it on next */
.................... 			if ( 2 == state ) {
03F2:  MOVF   x7D,W
03F4:  SUBLW  02
03F6:  BNZ   03FE
.................... 				lastMSB=incoming;
03F8:  MOVFF  7E,6C
.................... 			} else if ( 3 == state ) {
03FC:  BRA    041E
03FE:  MOVF   x7D,W
0400:  SUBLW  03
0402:  BNZ   041E
.................... 				/* 16 bit value made of previous byte and this byte */
.................... 				write_i2c(address>>1,make16(lastMSB,incoming));
0404:  BCF    FD8.0
0406:  RRCF   x6D,W
0408:  MOVWF  x7F
040A:  MOVFF  6C,81
040E:  MOVFF  7E,80
0412:  MOVWF  x82
0414:  MOVFF  6C,84
0418:  MOVFF  7E,83
041C:  BRA    01B2
.................... 
.................... 				/* this write only works for a single register per I2C transaction */
.................... 				/* this is not a BUG, but it would need to be implemented if this functionality is needed */
.................... 			}
.................... 		}
.................... 	}
.................... 
.................... 
.................... 	if ( state >= 0x80 ) {
041E:  MOVF   x7D,W
0420:  SUBLW  7F
0422:  BC    044A
.................... 		/* I2C master is requesting data from us */
.................... 
.................... 		if ( ! bit_test(address,0) ) {
0424:  BTFSC  x6D.0
0426:  BRA    0442
.................... 			/* read 16 bit register (register address half of I2C address) on even address */
.................... 			lastValue=map_i2c(address>>1);
0428:  BCF    FD8.0
042A:  RRCF   x6D,W
042C:  MOVWF  x7F
042E:  MOVWF  x80
0430:  BRA    01DA
0432:  MOVFF  02,6B
0436:  MOVFF  01,6A
.................... 
.................... 			/* send the MSB */
.................... 			i2c_write(STREAM_SLAVE,make8(lastValue,1));
043A:  MOVFF  6B,80
043E:  RCALL  0388
.................... 		} else {
0440:  BRA    0448
.................... 			/* send LSB of 16 bit register on odd address */
.................... 			i2c_write(STREAM_SLAVE,make8(lastValue,0));
0442:  MOVFF  6A,80
0446:  RCALL  0388
.................... 		}
.................... 		address++;
0448:  INCF   x6D,F
.................... 	}
044A:  BCF    F9E.3
044C:  GOTO   006C
.................... }
.................... 
.................... 
.................... int8 read_dip_switch(void) {
.................... 	/* nomenclature is backwards on netlist. We actually want LSB on top */
.................... 	return ( ! input(PIC_ADDR_LSB)<<1 ) | ( ! input(PIC_ADDR_MSB) );
*
0500:  BSF    F94.7
0502:  MOVLW  00
0504:  BTFSS  F82.7
0506:  MOVLW  01
0508:  MOVWF  00
050A:  BCF    FD8.0
050C:  RLCF   00,W
050E:  MOVWF  x72
0510:  BSF    F94.6
0512:  MOVLW  00
0514:  BTFSS  F82.6
0516:  MOVLW  01
0518:  IORWF  x72,W
051A:  MOVWF  01
051C:  GOTO   060A (RETURN)
.................... }
.................... 
.................... void init(void) {
.................... 	setup_vref(VREF_OFF);
*
05D2:  CLRF   FBA
.................... 	setup_dac(DAC_OFF);
05D4:  CLRF   FBB
.................... 	setup_adc(ADC_OFF);
05D6:  BCF    FC2.0
.................... 	setup_adc_ports(NO_ANALOGS);
05D8:  MOVLW  00
05DA:  MOVWF  F7E
05DC:  BCF    FC1.0
05DE:  BCF    FC1.1
05E0:  BCF    FC1.2
05E2:  BCF    FC1.3
05E4:  MOVWF  F7F
.................... 
.................... 	setup_wdt(WDT_512MS);
05E6:  BSF    FD1.0
.................... 
.................... 
.................... 	set_tris_a    (0b00111111);
05E8:  MOVLW  3F
05EA:  MOVWF  F92
.................... 	port_a_pullups(0b00110000);
05EC:  MOVLW  30
05EE:  MOVWF  F77
05F0:  BCF    FF1.7
.................... //                   76543210
.................... 
.................... 	set_tris_b    (0b01110000);
05F2:  MOVLW  70
05F4:  MOVWF  F93
.................... 	port_b_pullups(0b00000000);
05F6:  CLRF   F78
.................... //                   76543210
.................... 
.................... 	set_tris_c    (0b11110011);
05F8:  MOVLW  F3
05FA:  MOVWF  F94
.................... //                   76543210
.................... 
.................... 
.................... 	/* data structure initialization */
.................... 	/* all initialized to 0 on declaration. Just do this if need non-zero */
.................... 
.................... 
.................... 	/* one periodic interrupt @ 1mS. Generated from system 16 MHz clock */
.................... 	/* prescale=16, match=249, postscale=1. Match is 249 because when match occurs, one cycle is lost */
.................... 	setup_timer_2(T2_DIV_BY_16,249,1);
05FC:  MOVLW  00
05FE:  IORLW  06
0600:  MOVWF  FCA
0602:  MOVLW  F9
0604:  MOVWF  FCB
.................... 
.................... 	enable_interrupts(INT_TIMER2);
0606:  BSF    F9D.1
.................... 
.................... 	/* set I2C slave address, which is always an even number */
.................... 	i2c_slaveaddr(0x36 + (read_dip_switch()<<1) );
0608:  BRA    0500
060A:  BCF    FD8.0
060C:  RLCF   01,W
060E:  ADDLW  36
0610:  MOVWF  FC8
.................... 
.................... 
.................... 	/* initialize ina228 chips */
.................... 	ina228_init(INA228_A_ADDR);
0612:  MOVLW  80
0614:  MOVWF  x72
0616:  RCALL  05B2
.................... 	ina228_init(INA228_B_ADDR);
0618:  MOVLW  9A
061A:  MOVWF  x72
061C:  RCALL  05B2
061E:  GOTO   094E (RETURN)
.................... 
.................... }
.................... 
.................... 
.................... void action_now_ina(void) {
.................... 	timers.now_ina=0;
*
07F8:  BCF    x62.1
.................... 
.................... 	/* sample INA228 at middle of 1 second window */
.................... 	next.vbus_a  =ina228_read24(INA228_A_ADDR,INA228_REG_VBUS);
07FA:  MOVLW  80
07FC:  MOVWF  x72
07FE:  MOVLW  05
0800:  MOVWF  x73
0802:  RCALL  06D4
0804:  MOVFF  03,41
0808:  MOVFF  02,40
080C:  MOVFF  01,3F
0810:  MOVFF  00,3E
.................... 	next.vshunt_a=ina228_read24(INA228_A_ADDR,INA228_REG_VSHUNT);
0814:  MOVLW  80
0816:  MOVWF  x72
0818:  MOVLW  04
081A:  MOVWF  x73
081C:  RCALL  06D4
081E:  MOVFF  03,45
0822:  MOVFF  02,44
0826:  MOVFF  01,43
082A:  MOVFF  00,42
.................... 
.................... 	next.vbus_b  =ina228_read24(INA228_B_ADDR,INA228_REG_VBUS);
082E:  MOVLW  9A
0830:  MOVWF  x72
0832:  MOVLW  05
0834:  MOVWF  x73
0836:  RCALL  06D4
0838:  MOVFF  03,49
083C:  MOVFF  02,48
0840:  MOVFF  01,47
0844:  MOVFF  00,46
.................... 	next.vshunt_b=ina228_read24(INA228_B_ADDR,INA228_REG_VSHUNT);
0848:  MOVLW  9A
084A:  MOVWF  x72
084C:  MOVLW  04
084E:  MOVWF  x73
0850:  RCALL  06D4
0852:  MOVFF  03,4D
0856:  MOVFF  02,4C
085A:  MOVFF  01,4B
085E:  MOVFF  00,4A
.................... 
.................... 	next.dietemp_a=ina228_read16(INA228_A_ADDR,INA228_REG_DIETEMP);
0862:  MOVLW  80
0864:  MOVWF  x72
0866:  MOVLW  06
0868:  MOVWF  x73
086A:  RCALL  0772
086C:  MOVFF  02,5F
0870:  MOVFF  01,5E
.................... 	next.dietemp_b=ina228_read16(INA228_B_ADDR,INA228_REG_DIETEMP);
0874:  MOVLW  9A
0876:  MOVWF  x72
0878:  MOVLW  06
087A:  MOVWF  x73
087C:  RCALL  0772
087E:  MOVFF  02,61
0882:  MOVFF  01,60
.................... 
.................... #if ADCRANGE == 1 
.................... 	/* set low bit of high word (bit 24) to indicate we have +-40.96mV shunt range */
.................... 	bit_set(next.vshunt_a,24);
0886:  BSF    45.0
.................... 	bit_set(next.vshunt_b,24);
0888:  BSF    4D.0
.................... #else
088A:  GOTO   0A36 (RETURN)
.................... 	/* systems with +-163.84mV shunt range have bit 24 cleared. Or older firmwares don't implement this and that bit
.................... 	will be 0 by default */
.................... 	bit_clear(next.vshunt_a,24);
.................... 	bit_clear(next.vshunt_b,24);
.................... #endif
.................... }
.................... 
.................... 
.................... void periodic_millisecond(void) {
.................... 	timers.now_millisecond=0;
088E:  BCF    x62.0
.................... 
.................... 	/* LED control */
.................... 	if ( 0==timers.led_on_a ) {
0890:  MOVF   x63,F
0892:  BNZ   089A
.................... 		output_low(LED_A);
0894:  BCF    F94.3
0896:  BCF    F8B.3
.................... 	} else {
0898:  BRA    08A0
.................... 		output_high(LED_A);
089A:  BCF    F94.3
089C:  BSF    F8B.3
.................... 		timers.led_on_a--;
089E:  DECF   x63,F
.................... 	}
08A0:  GOTO   0A3C (RETURN)
.................... 
.................... 
.................... }
.................... 
.................... 
.................... void main(void) {
08A4:  CLRF   FF8
08A6:  BCF    FD0.7
08A8:  BSF    07.7
08AA:  BSF    F93.6
08AC:  BSF    F93.4
08AE:  CLRF   FC8
08B0:  MOVLW  36
08B2:  MOVWF  FC6
08B4:  BSF    FC5.0
08B6:  BSF    FC5.7
08B8:  CLRF   19
08BA:  BSF    FB8.3
08BC:  MOVLW  A0
08BE:  MOVWF  FAF
08C0:  MOVLW  01
08C2:  MOVWF  FB0
08C4:  MOVLW  A6
08C6:  MOVWF  FAC
08C8:  MOVLW  90
08CA:  MOVWF  FAB
08CC:  CLRF   x6F
08CE:  CLRF   x6E
08D0:  MOVLW  00
08D2:  MOVWF  F7E
08D4:  BCF    FC1.0
08D6:  BCF    FC1.1
08D8:  BCF    FC1.2
08DA:  BCF    FC1.3
08DC:  MOVWF  F7F
08DE:  CLRF   F6C
08E0:  CLRF   F6B
08E2:  CLRF   F6D
08E4:  BCF    x68.0
08E6:  BCF    x68.1
08E8:  BRA    08FA
08EA:  DATA 4A,40
08EC:  DATA 1A,00
08EE:  DATA 04,80
08F0:  DATA FF,FF
08F2:  DATA 00,00
08F4:  DATA 05,40
08F6:  DATA 69,00
08F8:  DATA 00,00
08FA:  MOVLW  00
08FC:  MOVWF  FF8
08FE:  MOVLW  08
0900:  MOVWF  FF7
0902:  MOVLW  EA
0904:  MOVWF  FF6
0906:  TBLRD*+
0908:  MOVF   FF5,W
090A:  MOVWF  00
090C:  XORLW  00
090E:  BZ    0936
0910:  TBLRD*+
0912:  MOVF   FF5,W
0914:  MOVWF  01
0916:  BTFSC  FE8.7
0918:  BRA    0924
091A:  ANDLW  3F
091C:  MOVWF  FEA
091E:  TBLRD*+
0920:  MOVFF  FF5,FE9
0924:  BTFSC  01.6
0926:  TBLRD*+
0928:  BTFSS  01.6
092A:  TBLRD*+
092C:  MOVFF  FF5,FEE
0930:  DCFSNZ 00,F
0932:  BRA    0906
0934:  BRA    0928
0936:  CLRF   FF8
.................... 	int8 restart_cause;
.................... 	int8 i;
.................... 
.................... 	restart_cause=restart_cause();
0938:  MOVF   FD0,W
093A:  ANDLW  0F
093C:  BTFSS  FD0.4
093E:  MOVLW  00
0940:  BSF    FD0.0
0942:  BSF    FD0.1
0944:  BSF    FD0.4
0946:  BSF    FD8.3
0948:  BSF    FD8.4
094A:  MOVWF  x70
.................... 
.................... 	init();
094C:  BRA    05D2
.................... 
.................... 
.................... 
.................... 	/* flash on startup */
.................... 	for ( i=0 ; i<5 ; i++ ) {
094E:  CLRF   x71
0950:  MOVF   x71,W
0952:  SUBLW  04
0954:  BNC   0970
.................... 		restart_wdt();
0956:  CLRWDT
.................... 		output_high(LED_A);
0958:  BCF    F94.3
095A:  BSF    F8B.3
.................... 		delay_ms(200);
095C:  MOVLW  C8
095E:  MOVWF  x72
0960:  RCALL  0622
.................... 		output_low(LED_A);
0962:  BCF    F94.3
0964:  BCF    F8B.3
.................... 		delay_ms(200);
0966:  MOVLW  C8
0968:  MOVWF  x72
096A:  RCALL  0622
096C:  INCF   x71,F
096E:  BRA    0950
.................... 	}
.................... 
.................... 	fprintf(STREAM_FTDI,"# dcswc_module_voltage_current_counter %s\r\n# ",__DATE__);
0970:  MOVLW  50
0972:  MOVWF  FF6
0974:  MOVLW  04
0976:  MOVWF  FF7
0978:  MOVLW  27
097A:  MOVWF  x72
097C:  RCALL  064A
097E:  MOVLW  7E
0980:  MOVWF  FF6
0982:  MOVLW  04
0984:  MOVWF  FF7
0986:  RCALL  066A
0988:  MOVLW  79
098A:  MOVWF  FF6
098C:  MOVLW  04
098E:  MOVWF  FF7
0990:  MOVLW  04
0992:  MOVWF  x72
0994:  RCALL  064A
.................... 	switch ( restart_cause ) {
0996:  MOVF   x70,W
0998:  XORLW  07
099A:  BZ    09B6
099C:  XORLW  0C
099E:  BZ    09C2
09A0:  XORLW  04
09A2:  BZ    09CE
09A4:  XORLW  03
09A6:  BZ    09DA
09A8:  XORLW  02
09AA:  BZ    09E6
09AC:  XORLW  0D
09AE:  BZ    09F2
09B0:  XORLW  03
09B2:  BZ    09FE
09B4:  BRA    0A0A
.................... 		case WDT_TIMEOUT:       fprintf(STREAM_FTDI,"WDT TIMEOUT"); break;
09B6:  MOVLW  88
09B8:  MOVWF  FF6
09BA:  MOVLW  04
09BC:  MOVWF  FF7
09BE:  RCALL  066A
09C0:  BRA    0A14
.................... 		case MCLR_FROM_SLEEP:   fprintf(STREAM_FTDI,"MCLR FROM SLEEP"); break;
09C2:  MOVLW  94
09C4:  MOVWF  FF6
09C6:  MOVLW  04
09C8:  MOVWF  FF7
09CA:  RCALL  066A
09CC:  BRA    0A14
.................... 		case MCLR_FROM_RUN:     fprintf(STREAM_FTDI,"MCLR FROM RUN"); break;
09CE:  MOVLW  A4
09D0:  MOVWF  FF6
09D2:  MOVLW  04
09D4:  MOVWF  FF7
09D6:  RCALL  066A
09D8:  BRA    0A14
.................... 		case NORMAL_POWER_UP:   fprintf(STREAM_FTDI,"NORMAL POWER UP"); break;
09DA:  MOVLW  B2
09DC:  MOVWF  FF6
09DE:  MOVLW  04
09E0:  MOVWF  FF7
09E2:  RCALL  066A
09E4:  BRA    0A14
.................... 		case BROWNOUT_RESTART:  fprintf(STREAM_FTDI,"BROWNOUT RESTART"); break;
09E6:  MOVLW  C2
09E8:  MOVWF  FF6
09EA:  MOVLW  04
09EC:  MOVWF  FF7
09EE:  RCALL  066A
09F0:  BRA    0A14
.................... 		case WDT_FROM_SLEEP:    fprintf(STREAM_FTDI,"WDT FROM SLEEP"); break;
09F2:  MOVLW  D4
09F4:  MOVWF  FF6
09F6:  MOVLW  04
09F8:  MOVWF  FF7
09FA:  RCALL  066A
09FC:  BRA    0A14
.................... 		case RESET_INSTRUCTION: fprintf(STREAM_FTDI,"RESET INSTRUCTION"); break;
09FE:  MOVLW  E4
0A00:  MOVWF  FF6
0A02:  MOVLW  04
0A04:  MOVWF  FF7
0A06:  RCALL  066A
0A08:  BRA    0A14
.................... 		default:                fprintf(STREAM_FTDI,"UNKNOWN!");
0A0A:  MOVLW  F6
0A0C:  MOVWF  FF6
0A0E:  MOVLW  04
0A10:  MOVWF  FF7
0A12:  RCALL  066A
.................... 	}
.................... 	fprintf(STREAM_FTDI,"\r\n");
0A14:  MOVLW  0D
0A16:  BTFSS  F9E.4
0A18:  BRA    0A16
0A1A:  MOVWF  FAD
0A1C:  MOVLW  0A
0A1E:  BTFSS  F9E.4
0A20:  BRA    0A1E
0A22:  MOVWF  FAD
.................... 
.................... 
.................... 	timers.led_on_a=500;
0A24:  MOVLW  F4
0A26:  MOVWF  x63
.................... 
.................... 	enable_interrupts(GLOBAL);
0A28:  MOVLW  C0
0A2A:  IORWF  FF2,F
.................... 
.................... 	/* enable I2C slave interrupt */
.................... 	enable_interrupts(INT_SSP);
0A2C:  BSF    F9D.3
.................... 
.................... 	for ( ; ; ) {
.................... 		restart_wdt();
0A2E:  CLRWDT
.................... 
.................... 		/* query INA228's for next */
.................... 		if ( timers.now_ina ) {
0A30:  BTFSS  x62.1
0A32:  BRA    0A36
.................... 			action_now_ina();
0A34:  BRA    07F8
.................... 		}
.................... 
.................... 		if ( timers.now_millisecond ) {
0A36:  BTFSS  x62.0
0A38:  BRA    0A3C
.................... 			periodic_millisecond();
0A3A:  BRA    088E
.................... 		}
.................... 
.................... #if 0
.................... 		if ( timers.now_dump ) {
.................... 			timers.now_dump=0;
.................... 
.................... 			fprintf(STREAM_FTDI,"# A: 0x%08lx / 0x%08lx / 0x%04lu\r\n",
.................... 				current.vbus_a,
.................... 				current.vshunt_a,
.................... 				current.dietemp_a
.................... 			);
.................... 		}
.................... #endif
.................... 
.................... #if 0
0A3C:  BRA    0A2E
.................... 		if ( kbhit() ) {
.................... 			getc();
.................... 
.................... 			fprintf(STREAM_FTDI,"# DIP SWITCHES: %d\r\n",
.................... 				read_dip_switch()
.................... 			);
.................... 
.................... 			fprintf(STREAM_FTDI,"# A: 0x%08lx / 0x%08lx / 0x%04lu\r\n",
.................... 				current.vbus_a,
.................... 				current.vshunt_a,
.................... 				current.dietemp_a
.................... 			);
.................... 			fprintf(STREAM_FTDI,"# B: 0x%08lx / 0x%08lx / 0x%04lu\r\n",
.................... 				current.vbus_b,
.................... 				current.vshunt_b,
.................... 				current.dietemp_b
.................... 			);
.................... 
.................... 			fprintf(STREAM_FTDI,"# current.count_a_last_second=%lu\r\n",
.................... 				current.count_a_last_second
.................... 			);
.................... 			fprintf(STREAM_FTDI,"# current.count_b_last_second=%lu\r\n",
.................... 				current.count_b_last_second
.................... 			);
.................... 			fprintf(STREAM_FTDI,"# current.count_a_long=%lu\r\n",
.................... 				current.count_a_long
.................... 			);
.................... 			fprintf(STREAM_FTDI,"# current.count_b_long=%lu\r\n",
.................... 				current.count_b_long
.................... 			);
.................... 
.................... 			fprintf(STREAM_FTDI,"# current.count_seconds_long=%lu\r\n",
.................... 				current.count_seconds_long
.................... 			);
.................... 
.................... 			fprintf(STREAM_FTDI,"# input(PIC_ADDR_MSB)=%u\r\n",input(PIC_ADDR_MSB));
.................... 			fprintf(STREAM_FTDI,"# input(PIC_ADDR_LSB)=%u\r\n",input(PIC_ADDR_LSB));
.................... 		}
.................... #endif
.................... 
.................... 
.................... 	}
.................... 
.................... 
.................... }
0A3E:  SLEEP 

Configuration Fuses:
   Word  1: 0200   HS NOPLLEN NOPCLKEN NOFCMEN NOIESO
   Word  2: 0F07   NOPUT BROWNOUT BORV30 WDT WDT128
   Word  3: 0000   NOHFOFST NOMCLR
   Word  4: 0081   STVREN NOLVP BBSIZ1K NOXINST NODEBUG
   Word  5: C003   NOPROTECT NOCPB NOCPD
   Word  6: E003   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 4003   NOEBTR NOEBTRB

ROM data:
F00000: 00 00 40 00                                        ..@.
