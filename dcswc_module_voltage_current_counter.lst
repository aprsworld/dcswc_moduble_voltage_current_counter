CCS PCH C Compiler, Version 5.090, 49113               13-Jan-22 15:19

               Filename:   C:\Users\James Jarvis\Desktop\planetPrecision\dcswc_module_voltage_current_counter\dcswc_module_voltage_current_counter.lst

               ROM used:   4184 bytes (27%)
                           Largest free fragment is 11364
               RAM used:   114 (22%) at main() level
                           146 (29%) worst case
               Stack used: 4 locations (2 in main + 2 for interrupts)
               Stack size: 30

0000:  GOTO   0C74
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  FF5,15
003C:  MOVFF  FF6,16
0040:  MOVFF  FF7,17
0044:  MOVFF  00,0E
0048:  MOVFF  01,0F
004C:  MOVFF  02,10
0050:  MOVFF  03,11
0054:  BTFSS  F9D.1
0056:  GOTO   0060
005A:  BTFSC  F9E.1
005C:  GOTO   00BA
0060:  BTFSS  F9D.3
0062:  GOTO   006C
0066:  BTFSC  F9E.3
0068:  GOTO   039C
006C:  MOVFF  0E,00
0070:  MOVFF  0F,01
0074:  MOVFF  10,02
0078:  MOVFF  11,03
007C:  MOVFF  0C,FE9
0080:  MOVFF  07,FEA
0084:  BSF    07.7
0086:  MOVFF  08,FE1
008A:  MOVFF  09,FE2
008E:  MOVFF  0A,FD9
0092:  MOVFF  0B,FDA
0096:  MOVFF  12,FF3
009A:  MOVFF  13,FF4
009E:  MOVFF  14,FFA
00A2:  MOVFF  15,FF5
00A6:  MOVFF  16,FF6
00AA:  MOVFF  17,FF7
00AE:  MOVF   04,W
00B0:  MOVFF  06,FE0
00B4:  MOVFF  05,FD8
00B8:  RETFIE 0
.................... #include "dcswc_module_voltage_current_counter.h"
.................... #include <18F14K22.h>
.................... //////////// Standard Header file for the PIC18F14K22 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18F14K22
*
0456:  DATA 23,20
0458:  DATA 64,63
045A:  DATA 73,77
045C:  DATA 63,5F
045E:  DATA 6D,6F
0460:  DATA 64,75
0462:  DATA 6C,65
0464:  DATA 5F,76
0466:  DATA 6F,6C
0468:  DATA 74,61
046A:  DATA 67,65
046C:  DATA 5F,63
046E:  DATA 75,72
0470:  DATA 72,65
0472:  DATA 6E,74
0474:  DATA 5F,63
0476:  DATA 6F,75
0478:  DATA 6E,74
047A:  DATA 65,72
047C:  DATA 20,25
047E:  DATA 73,0D
0480:  DATA 0A,00
0482:  DATA 31,33
0484:  DATA 2D,4A
0486:  DATA 61,6E
0488:  DATA 2D,32
048A:  DATA 32,00
048C:  DATA 23,20
048E:  DATA 44,49
0490:  DATA 50,20
0492:  DATA 53,57
0494:  DATA 49,54
0496:  DATA 43,48
0498:  DATA 45,53
049A:  DATA 3A,20
049C:  DATA 25,64
049E:  DATA 0D,0A
04A0:  DATA 00,00
04A2:  DATA 23,20
04A4:  DATA 41,3A
04A6:  DATA 20,30
04A8:  DATA 78,25
04AA:  DATA 30,38
04AC:  DATA 6C,78
04AE:  DATA 20,2F
04B0:  DATA 20,30
04B2:  DATA 78,25
04B4:  DATA 30,38
04B6:  DATA 6C,78
04B8:  DATA 20,2F
04BA:  DATA 20,30
04BC:  DATA 78,25
04BE:  DATA 30,34
04C0:  DATA 6C,75
04C2:  DATA 0D,0A
04C4:  DATA 00,00
04C6:  DATA 23,20
04C8:  DATA 42,3A
04CA:  DATA 20,30
04CC:  DATA 78,25
04CE:  DATA 30,38
04D0:  DATA 6C,78
04D2:  DATA 20,2F
04D4:  DATA 20,30
04D6:  DATA 78,25
04D8:  DATA 30,38
04DA:  DATA 6C,78
04DC:  DATA 20,2F
04DE:  DATA 20,30
04E0:  DATA 78,25
04E2:  DATA 30,34
04E4:  DATA 6C,75
04E6:  DATA 0D,0A
04E8:  DATA 00,00
04EA:  DATA 23,20
04EC:  DATA 63,75
04EE:  DATA 72,72
04F0:  DATA 65,6E
04F2:  DATA 74,2E
04F4:  DATA 63,6F
04F6:  DATA 75,6E
04F8:  DATA 74,5F
04FA:  DATA 61,5F
04FC:  DATA 6C,61
04FE:  DATA 73,74
0500:  DATA 5F,73
0502:  DATA 65,63
0504:  DATA 6F,6E
0506:  DATA 64,3D
0508:  DATA 25,6C
050A:  DATA 75,0D
050C:  DATA 0A,00
050E:  DATA 23,20
0510:  DATA 63,75
0512:  DATA 72,72
0514:  DATA 65,6E
0516:  DATA 74,2E
0518:  DATA 63,6F
051A:  DATA 75,6E
051C:  DATA 74,5F
051E:  DATA 62,5F
0520:  DATA 6C,61
0522:  DATA 73,74
0524:  DATA 5F,73
0526:  DATA 65,63
0528:  DATA 6F,6E
052A:  DATA 64,3D
052C:  DATA 25,6C
052E:  DATA 75,0D
0530:  DATA 0A,00
0532:  DATA 23,20
0534:  DATA 63,75
0536:  DATA 72,72
0538:  DATA 65,6E
053A:  DATA 74,2E
053C:  DATA 63,6F
053E:  DATA 75,6E
0540:  DATA 74,5F
0542:  DATA 61,5F
0544:  DATA 6C,6F
0546:  DATA 6E,67
0548:  DATA 3D,25
054A:  DATA 6C,75
054C:  DATA 0D,0A
054E:  DATA 00,00
0550:  DATA 23,20
0552:  DATA 63,75
0554:  DATA 72,72
0556:  DATA 65,6E
0558:  DATA 74,2E
055A:  DATA 63,6F
055C:  DATA 75,6E
055E:  DATA 74,5F
0560:  DATA 62,5F
0562:  DATA 6C,6F
0564:  DATA 6E,67
0566:  DATA 3D,25
0568:  DATA 6C,75
056A:  DATA 0D,0A
056C:  DATA 00,00
056E:  DATA 23,20
0570:  DATA 63,75
0572:  DATA 72,72
0574:  DATA 65,6E
0576:  DATA 74,2E
0578:  DATA 63,6F
057A:  DATA 75,6E
057C:  DATA 74,5F
057E:  DATA 73,65
0580:  DATA 63,6F
0582:  DATA 6E,64
0584:  DATA 73,5F
0586:  DATA 6C,6F
0588:  DATA 6E,67
058A:  DATA 3D,25
058C:  DATA 6C,75
058E:  DATA 0D,0A
0590:  DATA 00,00
0592:  DATA 23,20
0594:  DATA 69,6E
0596:  DATA 70,75
0598:  DATA 74,28
059A:  DATA 50,49
059C:  DATA 43,5F
059E:  DATA 41,44
05A0:  DATA 44,52
05A2:  DATA 5F,4D
05A4:  DATA 53,42
05A6:  DATA 29,3D
05A8:  DATA 25,75
05AA:  DATA 0D,0A
05AC:  DATA 00,00
05AE:  DATA 23,20
05B0:  DATA 69,6E
05B2:  DATA 70,75
05B4:  DATA 74,28
05B6:  DATA 50,49
05B8:  DATA 43,5F
05BA:  DATA 41,44
05BC:  DATA 44,52
05BE:  DATA 5F,4C
05C0:  DATA 53,42
05C2:  DATA 29,3D
05C4:  DATA 25,75
05C6:  DATA 0D,0A
05C8:  DATA 00,00
*
0652:  TBLRD*+
0654:  MOVFF  FF6,73
0658:  MOVFF  FF7,74
065C:  MOVF   FF5,W
065E:  BTFSS  F9E.4
0660:  BRA    065E
0662:  MOVWF  FAD
0664:  MOVFF  73,FF6
0668:  MOVFF  74,FF7
066C:  DECFSZ x72,F
066E:  BRA    0652
0670:  RETURN 0
0672:  TBLRD*+
0674:  MOVF   FF5,F
0676:  BZ    0692
0678:  MOVFF  FF6,71
067C:  MOVFF  FF7,72
0680:  MOVF   FF5,W
0682:  BTFSS  F9E.4
0684:  BRA    0682
0686:  MOVWF  FAD
0688:  MOVFF  71,FF6
068C:  MOVFF  72,FF7
0690:  BRA    0672
0692:  GOTO   0D52 (RETURN)
*
090A:  MOVF   x79,W
090C:  CLRF   01
090E:  SUBWF  x78,W
0910:  BC    0918
0912:  MOVFF  78,00
0916:  BRA    0930
0918:  CLRF   00
091A:  MOVLW  08
091C:  MOVWF  x7A
091E:  RLCF   x78,F
0920:  RLCF   00,F
0922:  MOVF   x79,W
0924:  SUBWF  00,W
0926:  BTFSC  FD8.0
0928:  MOVWF  00
092A:  RLCF   01,F
092C:  DECFSZ x7A,F
092E:  BRA    091E
0930:  RETURN 0
0932:  MOVLW  20
0934:  BTFSS  x73.4
0936:  MOVLW  30
0938:  MOVWF  x74
093A:  MOVFF  72,00
093E:  BTFSS  x72.7
0940:  BRA    0952
0942:  COMF   00,F
0944:  INCF   00,F
0946:  MOVFF  00,72
094A:  MOVLW  2D
094C:  MOVWF  x74
094E:  BSF    x73.7
0950:  BSF    x73.0
0952:  MOVF   01,W
0954:  MOVFF  72,78
0958:  MOVLW  64
095A:  MOVWF  x79
095C:  RCALL  090A
095E:  MOVFF  00,72
0962:  MOVLW  30
0964:  ADDWF  01,W
0966:  MOVWF  x75
0968:  MOVFF  72,78
096C:  MOVLW  0A
096E:  MOVWF  x79
0970:  RCALL  090A
0972:  MOVLW  30
0974:  ADDWF  00,W
0976:  MOVWF  x77
0978:  MOVLW  30
097A:  ADDWF  01,W
097C:  MOVWF  x76
097E:  MOVFF  74,00
0982:  MOVLW  30
0984:  SUBWF  x75,W
0986:  BZ    0990
0988:  BSF    x73.1
098A:  BTFSC  x73.7
098C:  BSF    x73.2
098E:  BRA    09B4
0990:  MOVFF  74,75
0994:  MOVLW  20
0996:  MOVWF  x74
0998:  MOVLW  30
099A:  SUBWF  x76,W
099C:  BZ    09A6
099E:  BSF    x73.0
09A0:  BTFSC  x73.7
09A2:  BSF    x73.1
09A4:  BRA    09B4
09A6:  BTFSS  FD8.2
09A8:  BSF    x73.0
09AA:  BNZ   09B4
09AC:  MOVFF  75,76
09B0:  MOVLW  20
09B2:  MOVWF  x75
09B4:  BTFSC  x73.2
09B6:  BRA    09C2
09B8:  BTFSC  x73.1
09BA:  BRA    09CA
09BC:  BTFSC  x73.0
09BE:  BRA    09D2
09C0:  BRA    09DA
09C2:  MOVF   x74,W
09C4:  BTFSS  F9E.4
09C6:  BRA    09C4
09C8:  MOVWF  FAD
09CA:  MOVF   x75,W
09CC:  BTFSS  F9E.4
09CE:  BRA    09CC
09D0:  MOVWF  FAD
09D2:  MOVF   x76,W
09D4:  BTFSS  F9E.4
09D6:  BRA    09D4
09D8:  MOVWF  FAD
09DA:  MOVF   x77,W
09DC:  BTFSS  F9E.4
09DE:  BRA    09DC
09E0:  MOVWF  FAD
09E2:  GOTO   0DAC (RETURN)
09E6:  BTFSC  x72.7
09E8:  BRA    0A0A
09EA:  MOVLW  0F
09EC:  MOVWF  00
09EE:  SWAPF  x71,W
09F0:  ANDWF  00,F
09F2:  MOVLW  0A
09F4:  SUBWF  00,W
09F6:  BC    09FE
09F8:  MOVLW  30
09FA:  ADDWF  00,F
09FC:  BRA    0A02
09FE:  MOVF   x72,W
0A00:  ADDWF  00,F
0A02:  MOVF   00,W
0A04:  BTFSS  F9E.4
0A06:  BRA    0A04
0A08:  MOVWF  FAD
0A0A:  MOVLW  0F
0A0C:  ANDWF  x71,F
0A0E:  MOVLW  0A
0A10:  SUBWF  x71,W
0A12:  BC    0A18
0A14:  MOVLW  30
0A16:  BRA    0A1C
0A18:  BCF    x72.7
0A1A:  MOVF   x72,W
0A1C:  ADDWF  x71,F
0A1E:  MOVF   x71,W
0A20:  BTFSS  F9E.4
0A22:  BRA    0A20
0A24:  MOVWF  FAD
0A26:  RETURN 0
0A28:  MOVFF  FEA,79
0A2C:  MOVFF  FE9,78
0A30:  SWAPF  x72,W
0A32:  IORLW  F0
0A34:  MOVWF  x74
0A36:  ADDWF  x74,F
0A38:  ADDLW  E2
0A3A:  MOVWF  x75
0A3C:  ADDLW  32
0A3E:  MOVWF  x77
0A40:  MOVF   x72,W
0A42:  ANDLW  0F
0A44:  ADDWF  x75,F
0A46:  ADDWF  x75,F
0A48:  ADDWF  x77,F
0A4A:  ADDLW  E9
0A4C:  MOVWF  x76
0A4E:  ADDWF  x76,F
0A50:  ADDWF  x76,F
0A52:  SWAPF  x71,W
0A54:  ANDLW  0F
0A56:  ADDWF  x76,F
0A58:  ADDWF  x77,F
0A5A:  RLCF   x76,F
0A5C:  RLCF   x77,F
0A5E:  COMF   x77,F
0A60:  RLCF   x77,F
0A62:  MOVF   x71,W
0A64:  ANDLW  0F
0A66:  ADDWF  x77,F
0A68:  RLCF   x74,F
0A6A:  MOVLW  07
0A6C:  MOVWF  x73
0A6E:  MOVLW  0A
0A70:  DECF   x76,F
0A72:  ADDWF  x77,F
0A74:  BNC   0A70
0A76:  DECF   x75,F
0A78:  ADDWF  x76,F
0A7A:  BNC   0A76
0A7C:  DECF   x74,F
0A7E:  ADDWF  x75,F
0A80:  BNC   0A7C
0A82:  DECF   x73,F
0A84:  ADDWF  x74,F
0A86:  BNC   0A82
0A88:  CLRF   FEA
0A8A:  MOVLW  73
0A8C:  MOVWF  FE9
0A8E:  MOVLW  07
0A90:  ANDWF  x78,W
0A92:  BCF    x78.6
0A94:  ADDWF  FE9,F
0A96:  MOVLW  00
0A98:  ADDWFC FEA,F
0A9A:  MOVF   FE9,W
0A9C:  SUBLW  77
0A9E:  BNZ   0AA6
0AA0:  MOVF   FEA,F
0AA2:  BNZ   0AA6
0AA4:  BSF    x78.6
0AA6:  MOVF   FEF,W
0AA8:  MOVWF  00
0AAA:  BNZ   0ABC
0AAC:  BTFSC  x78.6
0AAE:  BRA    0ABC
0AB0:  BTFSC  x78.4
0AB2:  BRA    0ACC
0AB4:  BTFSC  x78.3
0AB6:  BRA    0ABC
0AB8:  MOVLW  20
0ABA:  BRA    0AC2
0ABC:  BSF    x78.3
0ABE:  BCF    x78.4
0AC0:  MOVLW  30
0AC2:  ADDWF  00,F
0AC4:  MOVF   00,W
0AC6:  BTFSS  F9E.4
0AC8:  BRA    0AC6
0ACA:  MOVWF  FAD
0ACC:  MOVF   FEE,W
0ACE:  BTFSS  x78.6
0AD0:  BRA    0A9A
0AD2:  RETURN 0
0AD4:  BTFSC  FD8.1
0AD6:  BRA    0ADE
0AD8:  CLRF   FEA
0ADA:  MOVLW  85
0ADC:  MOVWF  FE9
0ADE:  CLRF   00
0AE0:  CLRF   01
0AE2:  CLRF   02
0AE4:  CLRF   03
0AE6:  CLRF   x85
0AE8:  CLRF   x86
0AEA:  CLRF   x87
0AEC:  CLRF   x88
0AEE:  MOVF   x84,W
0AF0:  IORWF  x83,W
0AF2:  IORWF  x82,W
0AF4:  IORWF  x81,W
0AF6:  BZ    0B50
0AF8:  MOVLW  20
0AFA:  MOVWF  x89
0AFC:  BCF    FD8.0
0AFE:  RLCF   x7D,F
0B00:  RLCF   x7E,F
0B02:  RLCF   x7F,F
0B04:  RLCF   x80,F
0B06:  RLCF   x85,F
0B08:  RLCF   x86,F
0B0A:  RLCF   x87,F
0B0C:  RLCF   x88,F
0B0E:  MOVF   x84,W
0B10:  SUBWF  x88,W
0B12:  BNZ   0B24
0B14:  MOVF   x83,W
0B16:  SUBWF  x87,W
0B18:  BNZ   0B24
0B1A:  MOVF   x82,W
0B1C:  SUBWF  x86,W
0B1E:  BNZ   0B24
0B20:  MOVF   x81,W
0B22:  SUBWF  x85,W
0B24:  BNC   0B44
0B26:  MOVF   x81,W
0B28:  SUBWF  x85,F
0B2A:  MOVF   x82,W
0B2C:  BTFSS  FD8.0
0B2E:  INCFSZ x82,W
0B30:  SUBWF  x86,F
0B32:  MOVF   x83,W
0B34:  BTFSS  FD8.0
0B36:  INCFSZ x83,W
0B38:  SUBWF  x87,F
0B3A:  MOVF   x84,W
0B3C:  BTFSS  FD8.0
0B3E:  INCFSZ x84,W
0B40:  SUBWF  x88,F
0B42:  BSF    FD8.0
0B44:  RLCF   00,F
0B46:  RLCF   01,F
0B48:  RLCF   02,F
0B4A:  RLCF   03,F
0B4C:  DECFSZ x89,F
0B4E:  BRA    0AFC
0B50:  MOVFF  85,FEF
0B54:  MOVFF  86,FEC
0B58:  MOVFF  87,FEC
0B5C:  MOVFF  88,FEC
0B60:  RETURN 0
0B62:  MOVF   FE9,W
0B64:  MOVWF  x75
0B66:  MOVLW  3B
0B68:  MOVWF  x7C
0B6A:  MOVLW  9A
0B6C:  MOVWF  x7B
0B6E:  MOVLW  CA
0B70:  MOVWF  x7A
0B72:  CLRF   x79
0B74:  MOVLW  0A
0B76:  MOVWF  x77
0B78:  BSF    FD8.1
0B7A:  CLRF   FEA
0B7C:  MOVLW  71
0B7E:  MOVWF  FE9
0B80:  MOVFF  74,80
0B84:  MOVFF  73,7F
0B88:  MOVFF  72,7E
0B8C:  MOVFF  71,7D
0B90:  MOVFF  7C,84
0B94:  MOVFF  7B,83
0B98:  MOVFF  7A,82
0B9C:  MOVFF  79,81
0BA0:  RCALL  0AD4
0BA2:  MOVF   01,W
0BA4:  MOVF   00,F
0BA6:  BNZ   0BC6
0BA8:  MOVF   x77,W
0BAA:  XORLW  01
0BAC:  BZ    0BC6
0BAE:  MOVF   x75,W
0BB0:  BZ    0BC8
0BB2:  ANDLW  0F
0BB4:  SUBWF  x77,W
0BB6:  BZ    0BBA
0BB8:  BC    0BD4
0BBA:  BTFSC  x75.7
0BBC:  BRA    0BD4
0BBE:  BTFSC  x75.6
0BC0:  BRA    0BC8
0BC2:  MOVLW  20
0BC4:  BRA    0BCA
0BC6:  CLRF   x75
0BC8:  MOVLW  30
0BCA:  ADDWF  00,F
0BCC:  MOVF   00,W
0BCE:  BTFSS  F9E.4
0BD0:  BRA    0BCE
0BD2:  MOVWF  FAD
0BD4:  BCF    FD8.1
0BD6:  MOVFF  7C,80
0BDA:  MOVFF  7B,7F
0BDE:  MOVFF  7A,7E
0BE2:  MOVFF  79,7D
0BE6:  CLRF   x84
0BE8:  CLRF   x83
0BEA:  CLRF   x82
0BEC:  MOVLW  0A
0BEE:  MOVWF  x81
0BF0:  RCALL  0AD4
0BF2:  MOVFF  03,7C
0BF6:  MOVFF  02,7B
0BFA:  MOVFF  01,7A
0BFE:  MOVFF  00,79
0C02:  DECFSZ x77,F
0C04:  BRA    0B78
0C06:  RETURN 0
0C08:  MOVF   01,W
0C0A:  MOVFF  72,78
0C0E:  MOVLW  64
0C10:  MOVWF  x79
0C12:  RCALL  090A
0C14:  MOVFF  00,72
0C18:  MOVF   01,W
0C1A:  MOVLW  30
0C1C:  BNZ   0C2C
0C1E:  BTFSS  x73.1
0C20:  BRA    0C3C
0C22:  BTFSC  x73.3
0C24:  BRA    0C3C
0C26:  BTFSC  x73.4
0C28:  MOVLW  20
0C2A:  BRA    0C32
0C2C:  BCF    x73.3
0C2E:  BCF    x73.4
0C30:  BSF    x73.0
0C32:  ADDWF  01,F
0C34:  MOVF   01,W
0C36:  BTFSS  F9E.4
0C38:  BRA    0C36
0C3A:  MOVWF  FAD
0C3C:  MOVFF  72,78
0C40:  MOVLW  0A
0C42:  MOVWF  x79
0C44:  RCALL  090A
0C46:  MOVFF  00,72
0C4A:  MOVF   01,W
0C4C:  MOVLW  30
0C4E:  BNZ   0C5C
0C50:  BTFSC  x73.3
0C52:  BRA    0C66
0C54:  BTFSS  x73.0
0C56:  BRA    0C66
0C58:  BTFSC  x73.4
0C5A:  MOVLW  20
0C5C:  ADDWF  01,F
0C5E:  MOVF   01,W
0C60:  BTFSS  F9E.4
0C62:  BRA    0C60
0C64:  MOVWF  FAD
0C66:  MOVLW  30
0C68:  ADDWF  x72,F
0C6A:  MOVF   x72,W
0C6C:  BTFSS  F9E.4
0C6E:  BRA    0C6C
0C70:  MOVWF  FAD
0C72:  RETURN 0
.................... 
.................... #list
.................... 
.................... #device ADC=10
.................... #device *=16
.................... #use delay(clock=16MHz)
*
062A:  CLRF   FEA
062C:  MOVLW  72
062E:  MOVWF  FE9
0630:  MOVF   FEF,W
0632:  BZ    0650
0634:  MOVLW  05
0636:  MOVWF  01
0638:  CLRF   00
063A:  DECFSZ 00,F
063C:  BRA    063A
063E:  DECFSZ 01,F
0640:  BRA    0638
0642:  MOVLW  2E
0644:  MOVWF  00
0646:  DECFSZ 00,F
0648:  BRA    0646
064A:  BRA    064C
064C:  DECFSZ FEF,F
064E:  BRA    0634
0650:  RETURN 0
.................... 
.................... /* hardware I2C port is slave and is connected to DCSWC bus */
.................... #use i2c(stream=STREAM_SLAVE,SLAVE, I2C1, FORCE_HW)
*
0386:  MOVF   FC9,W
0388:  MOVFF  8D,FC9
038C:  BSF    FC6.4
038E:  BCF    F9E.3
0390:  BTFSC  FC7.0
0392:  BRA    0390
0394:  CLRF   01
0396:  BTFSS  FC5.6
0398:  INCF   01,F
039A:  RETURN 0
.................... /* slave address set based on dip switch in init() */
.................... /* Linux / i2cdetect will use the CCS address >>1. So 0x34 becomes 0x1a */
.................... 
.................... 
.................... 
.................... #fuses HS
.................... #fuses NOPLLEN
.................... #fuses NOFCMEN
.................... #fuses NOIESO
.................... #fuses PUT
.................... #fuses BROWNOUT
.................... #fuses WDT4096
.................... #fuses NOHFOFST
.................... #fuses NOMCLR
.................... #fuses STVREN
.................... #fuses NOLVP
.................... #fuses NOXINST
.................... #fuses NODEBUG
.................... #fuses NOPROTECT
.................... #fuses NOWRT
.................... #fuses NOWRTC 
.................... #fuses NOWRTB
.................... #fuses NOWRTD
.................... #fuses NOEBTR
.................... #fuses NOEBTRB
.................... 
.................... #use standard_io(ALL)
.................... 
.................... #use rs232(UART1,stream=STREAM_FTDI,baud=9600,errors)	
*
08F2:  BTFSS  F9E.5
08F4:  BRA    08F2
08F6:  MOVFF  FAB,19
08FA:  MOVFF  FAE,01
08FE:  BTFSS  19.1
0900:  BRA    0906
0902:  BCF    FAB.4
0904:  BSF    FAB.4
0906:  GOTO   0D8E (RETURN)
.................... 
.................... /* program config CRC of 0 and a serial_prefix of 'A' ... that will trigger a write default on first boot */
.................... #ROM 0xF00000 = { 0x00, 0x00, 0x40, 0x00 }
.................... 
.................... 
.................... 
.................... #define COUNT_B              PIN_C5
.................... #define COUNT_A              PIN_C4
.................... #define LED_A                PIN_C3
.................... #define PIC_ADDR_MSB         PIN_C6
.................... #define PIC_ADDR_LSB         PIN_C7
.................... #define SER_TO_PC            PIN_B7
.................... 
.................... #define INA_ALERT            PIN_A2
.................... #define I2C_SW_SDA           PIN_C0
.................... #define I2C_SW_SCL           PIN_C1
.................... #define TP2                  PIN_C2
.................... #define I2C_SDA              PIN_B4
.................... #define SER_FROM_PC          PIN_B5
.................... #define I2C_SCL              PIN_B6
.................... 
.................... 
.................... /* software I2C port is maser and is connected to two INA228A */
.................... #use i2c(stream=STREAM_MASTER, MASTER, FAST, FORCE_SW, scl=I2C_SW_SCL, sda=I2C_SW_SDA)
*
0696:  MOVLW  08
0698:  MOVWF  01
069A:  NOP   
069C:  BCF    F8B.1
069E:  BCF    F94.1
06A0:  NOP   
06A2:  RLCF   x78,F
06A4:  BCF    F8B.0
06A6:  BTFSC  FD8.0
06A8:  BSF    F94.0
06AA:  BTFSS  FD8.0
06AC:  BCF    F94.0
06AE:  BSF    F94.1
06B0:  BTFSS  F82.1
06B2:  BRA    06B0
06B4:  DECFSZ 01,F
06B6:  BRA    069A
06B8:  NOP   
06BA:  BCF    F8B.1
06BC:  BCF    F94.1
06BE:  NOP   
06C0:  BSF    F94.0
06C2:  NOP   
06C4:  NOP   
06C6:  BSF    F94.1
06C8:  BTFSS  F82.1
06CA:  BRA    06C8
06CC:  CLRF   01
06CE:  NOP   
06D0:  BTFSC  F82.0
06D2:  BSF    01.0
06D4:  BCF    F8B.1
06D6:  BCF    F94.1
06D8:  BCF    F8B.0
06DA:  BCF    F94.0
06DC:  RETURN 0
06DE:  MOVLW  08
06E0:  MOVWF  x7A
06E2:  MOVFF  00,7B
06E6:  BSF    F94.0
06E8:  NOP   
06EA:  BSF    F94.1
06EC:  BTFSS  F82.1
06EE:  BRA    06EC
06F0:  BTFSC  F82.0
06F2:  BSF    FD8.0
06F4:  BTFSS  F82.0
06F6:  BCF    FD8.0
06F8:  RLCF   01,F
06FA:  NOP   
06FC:  BCF    F94.1
06FE:  BCF    F8B.1
0700:  DECFSZ x7A,F
0702:  BRA    06E6
0704:  BSF    F94.0
0706:  NOP   
0708:  BCF    F8B.0
070A:  MOVF   x7B,W
070C:  BTFSS  FD8.2
070E:  BCF    F94.0
0710:  NOP   
0712:  BSF    F94.1
0714:  BTFSS  F82.1
0716:  BRA    0714
0718:  NOP   
071A:  BCF    F8B.1
071C:  BCF    F94.1
071E:  NOP   
0720:  BCF    F8B.0
0722:  BCF    F94.0
0724:  RETURN 0
.................... 
.................... 
.................... 
.................... #define INA228_A_ADDR      0x80
.................... #define INA228_B_ADDR      0x9a
.................... 
.................... 
.................... 
.................... 
.................... typedef struct {
.................... 	int8 serial_prefix;
.................... 	int16 serial_number;
.................... 	int16 startup_power_on_delay;
.................... } struct_config;
.................... 
.................... 
.................... 
.................... typedef struct {
.................... 	int32 vbus_a, vshunt_a;
.................... 	int32 vbus_b, vshunt_b;
.................... 
.................... 	int16 count_a_last_second, count_b_last_second;
.................... 
.................... 	int32 count_a_long;
.................... 	int32 count_b_long;
.................... 	int32 count_seconds_long;
.................... 
.................... 	int16 dietemp_a;
.................... 	int16 dietemp_b;
.................... } struct_current;
.................... 
.................... typedef struct {
.................... 	/* action flags */
.................... 	int1 now_millisecond;
.................... 
.................... 	int1 now_ina;    // query ina registers
.................... 
.................... 	/* timers */
.................... 	int8 led_on_a;
.................... } struct_time_keep;
.................... 
.................... /* global structures */
.................... struct_current current={0};
.................... struct_current next={0};
.................... struct_time_keep timers={0};
.................... 
.................... #include "ina228.c"
.................... #define INA228_REG_CONFIG       0x00  // 16 bits, configuration
.................... #define INA228_REG_ADC_CONFIG   0x01  // 16 bits, ADC configuration
.................... #define INA228_REG_SHUNT_CAL    0x02  // 16 bits, shunt calibration
.................... #define INA228_REG_SHUNT_TEMPCO 0x03  // 16 bits, shunt temperature coefficient
.................... #define INA228_REG_VSHUNT       0x04  // 24 bits, shunt voltage measurement
.................... #define INA228_REG_VBUS         0x05  // 24 bits, bus voltage measurement
.................... #define INA228_REG_DIETEMP      0x06  // 16 bits, temperature measurement
.................... #define INA228_REG_CURRENT      0x07  // 24 bits, current result
.................... #define INA228_REG_POWER        0x08  // 24 bits, power result 
.................... #define INA228_REG_ENERGY       0x09  // 40 bits, energy result
.................... #define INA228_REG_CHARGE       0x0a  // 40 bits, charge result
.................... #define INA228_REG_DIAG_ALRT    0x0b  // 16 bits, diagnostic flags and alert
.................... #define INA228_REG_SOVL         0x0c  // 16 bits, shunt overvoltage threshold
.................... #define INA228_REG_SUVL         0x0d  // 16 bits, shunt undervoltage threshold
.................... #define INA228_REG_BOVL         0x0e  // 16 bits, bus overvoltage threshold
.................... #define INA228_REG_BUVL         0x0f  // 16 bits, bus undervoltage threshold
.................... #define INA228_REG_TEMP_LIMIT   0x10  // 16 bits, temperature over-limit threshold
.................... #define INA228_REG_PWR_LIMIT    0x11  // 16 bits, power over-limit threshold
.................... #define INA228_REG_MFG_ID       0x3e  // 16 bits, manufacturer ID
.................... #define INA228_REG_DEVICE_ID    0x3f  // 16 bits, device ID
.................... 
.................... #define INA228_I2C_WRITE        0x00
.................... #define INA228_I2C_READ         0x01 
.................... 
.................... 
.................... int16 ina228_read16(int8 i2c_address, int8 regaddr) {
.................... 	int16 data;
.................... 
.................... 	i2c_start(STREAM_MASTER);
*
07C4:  BSF    F94.0
07C6:  NOP   
07C8:  BSF    F94.1
07CA:  NOP   
07CC:  BCF    F8B.0
07CE:  BCF    F94.0
07D0:  NOP   
07D2:  BCF    F8B.1
07D4:  BCF    F94.1
.................... 	delay_us(15);
07D6:  MOVLW  13
07D8:  MOVWF  00
07DA:  DECFSZ 00,F
07DC:  BRA    07DA
07DE:  BRA    07E0
.................... 	i2c_write(STREAM_MASTER,i2c_address);
07E0:  MOVFF  71,78
07E4:  RCALL  0696
.................... 	i2c_write(STREAM_MASTER,regaddr);
07E6:  MOVFF  72,78
07EA:  RCALL  0696
.................... 	i2c_start(STREAM_MASTER);
07EC:  BSF    F94.0
07EE:  NOP   
07F0:  BSF    F94.1
07F2:  NOP   
07F4:  BTFSS  F82.1
07F6:  BRA    07F4
07F8:  BCF    F8B.0
07FA:  BCF    F94.0
07FC:  NOP   
07FE:  BCF    F8B.1
0800:  BCF    F94.1
.................... 	delay_us(15);
0802:  MOVLW  13
0804:  MOVWF  00
0806:  DECFSZ 00,F
0808:  BRA    0806
080A:  BRA    080C
.................... 	i2c_write(STREAM_MASTER,i2c_address | INA228_I2C_READ);  // read cycle
080C:  MOVF   x71,W
080E:  IORLW  01
0810:  MOVWF  x75
0812:  MOVWF  x78
0814:  RCALL  0696
.................... 	data=make16(i2c_read(STREAM_MASTER,1),i2c_read(STREAM_MASTER,0));                                 
0816:  MOVLW  01
0818:  MOVWF  00
081A:  RCALL  06DE
081C:  MOVFF  01,75
0820:  CLRF   00
0822:  RCALL  06DE
0824:  MOVFF  75,74
0828:  MOVFF  01,73
.................... 	i2c_stop(STREAM_MASTER);
082C:  BCF    F94.0
082E:  NOP   
0830:  BSF    F94.1
0832:  BTFSS  F82.1
0834:  BRA    0832
0836:  NOP   
0838:  BRA    083A
083A:  NOP   
083C:  BSF    F94.0
083E:  NOP   
.................... 
.................... 	return data;
0840:  MOVFF  73,01
0844:  MOVFF  74,02
0848:  RETURN 0
.................... }
.................... 
.................... int32 ina228_read24(int8 i2c_address, int8 regaddr) {
.................... 	int32 data;
.................... 
.................... 	i2c_start(STREAM_MASTER);
*
0726:  BSF    F94.0
0728:  NOP   
072A:  BSF    F94.1
072C:  NOP   
072E:  BCF    F8B.0
0730:  BCF    F94.0
0732:  NOP   
0734:  BCF    F8B.1
0736:  BCF    F94.1
.................... 	delay_us(15);
0738:  MOVLW  13
073A:  MOVWF  00
073C:  DECFSZ 00,F
073E:  BRA    073C
0740:  BRA    0742
.................... 	i2c_write(STREAM_MASTER,i2c_address);
0742:  MOVFF  71,78
0746:  RCALL  0696
.................... 	i2c_write(STREAM_MASTER,regaddr);
0748:  MOVFF  72,78
074C:  RCALL  0696
.................... 	i2c_start(STREAM_MASTER);
074E:  BSF    F94.0
0750:  NOP   
0752:  BSF    F94.1
0754:  NOP   
0756:  BTFSS  F82.1
0758:  BRA    0756
075A:  BCF    F8B.0
075C:  BCF    F94.0
075E:  NOP   
0760:  BCF    F8B.1
0762:  BCF    F94.1
.................... 	delay_us(15);
0764:  MOVLW  13
0766:  MOVWF  00
0768:  DECFSZ 00,F
076A:  BRA    0768
076C:  BRA    076E
.................... 	i2c_write(STREAM_MASTER,i2c_address | INA228_I2C_READ);  // read cycle
076E:  MOVF   x71,W
0770:  IORLW  01
0772:  MOVWF  x77
0774:  MOVWF  x78
0776:  RCALL  0696
.................... 	data=make32(0,i2c_read(STREAM_MASTER,1),i2c_read(STREAM_MASTER,1),i2c_read(STREAM_MASTER,0));
0778:  MOVLW  01
077A:  MOVWF  00
077C:  RCALL  06DE
077E:  MOVFF  01,77
0782:  MOVLW  01
0784:  MOVWF  00
0786:  RCALL  06DE
0788:  MOVFF  01,78
078C:  CLRF   00
078E:  RCALL  06DE
0790:  CLRF   x76
0792:  MOVFF  77,75
0796:  MOVFF  78,74
079A:  MOVFF  01,73
.................... 	i2c_stop(STREAM_MASTER);
079E:  BCF    F94.0
07A0:  NOP   
07A2:  BSF    F94.1
07A4:  BTFSS  F82.1
07A6:  BRA    07A4
07A8:  NOP   
07AA:  BRA    07AC
07AC:  NOP   
07AE:  BSF    F94.0
07B0:  NOP   
.................... 
.................... 	return data;
07B2:  MOVFF  73,00
07B6:  MOVFF  74,01
07BA:  MOVFF  75,02
07BE:  MOVFF  76,03
07C2:  RETURN 0
.................... }
.................... 
.................... void ina228_write16(int8 i2c_address, int8 regaddr, int16 value) {
.................... 	i2c_start(STREAM_MASTER);
.................... 	delay_us(15);                                                 
.................... 	i2c_write(STREAM_MASTER,i2c_address); // write cycle                       
.................... 	i2c_write(STREAM_MASTER,regaddr);  // write cycle         
.................... 	i2c_write(STREAM_MASTER,make8(value,1));
.................... 	i2c_write(STREAM_MASTER,make8(value,0));
.................... 	i2c_stop(STREAM_MASTER);
.................... }
.................... 
.................... void ina228_init(int8 i2c_address) {
.................... 	ina228_write16(i2c_address,INA228_REG_CONFIG,0b1000000000000000);
.................... }
.................... 
.................... #include "i2c_handler_dcswc_module_voltage_current_counter.c"
.................... #include "registers_dcswc_module_voltage_current_counter.h"
.................... /* 32 bit INA228 bus and shunt voltages */
.................... #define I2C_REG_VBUS_A_MSW                    0
.................... #define I2C_REG_VBUS_A_LSW                    1
.................... #define I2C_REG_VSHUNT_A_MSW                  2
.................... #define I2C_REG_VSHUNT_A_LSW                  3
.................... 
.................... #define I2C_REG_VBUS_B_MSW                    4
.................... #define I2C_REG_VBUS_B_LSW                    5
.................... #define I2C_REG_VSHUNT_B_MSW                  6
.................... #define I2C_REG_VSHUNT_B_LSW                  7
.................... 
.................... /* 16 bit count of last (not current) second */
.................... #define I2C_REG_COUNT_A_LAST_SECOND           8
.................... #define I2C_REG_COUNT_B_LAST_SECOND           9
.................... 
.................... /* 32 bit count since reset */
.................... #define I2C_REG_COUNT_A_LONG_MSW              10
.................... #define I2C_REG_COUNT_A_LONG_LSW              11
.................... #define I2C_REG_COUNT_B_LONG_MSW              12
.................... #define I2C_REG_COUNT_B_LONG_LSW              13
.................... 
.................... /* 32 bit seconds since count reset */
.................... #define I2C_REG_COUNT_LONG_SECONDS_MSW        14
.................... #define I2C_REG_COUNT_LONG_SECONDS_LSW        15
.................... 
.................... /* 16 bit INA228 die temperatures */
.................... #define I2C_REG_DIETEMP_A                     16
.................... #define I2C_REG_DIETEMP_B                     17
.................... 
.................... 
.................... 
.................... /* test scratchpad registers for validating I2C communications */
.................... //int16 rtest[8] = { 0x0001, 0x0203, 0x0405, 0x0607, 0x0809, 0x0a0b, 0x0c0d, 0x0e0f };
.................... 
.................... 
.................... void write_i2c(int8 address, int16 value) {
.................... 	
.................... 	switch ( address ) {
*
01B2:  MOVF   x8F,W
01B4:  XORLW  0E
01B6:  BZ    01BE
01B8:  XORLW  01
01BA:  BZ    01BE
01BC:  BRA    01D6
.................... #if 0
.................... 		case 0: rtest[0]=value; break;
.................... 		case 1: rtest[1]=value; break;
.................... 		case 2: rtest[2]=value; break;
.................... 		case 3: rtest[3]=value; break;
.................... 		case 4: rtest[4]=value; break;
.................... 		case 5: rtest[5]=value; break;
.................... 		case 6: rtest[6]=value; break;
.................... 		case 7: rtest[7]=value; break;
.................... #endif
.................... 
.................... 		/* write anything to either of these addresses and we reset the long counter */
.................... 		case I2C_REG_COUNT_LONG_SECONDS_MSW:
.................... 		case I2C_REG_COUNT_LONG_SECONDS_LSW:
.................... 			current.count_a_long=0;
01BE:  CLRF   31
01C0:  CLRF   30
01C2:  CLRF   2F
01C4:  CLRF   2E
.................... 			current.count_b_long=0;
01C6:  CLRF   35
01C8:  CLRF   34
01CA:  CLRF   33
01CC:  CLRF   32
.................... 			current.count_seconds_long=0;
01CE:  CLRF   39
01D0:  CLRF   38
01D2:  CLRF   37
01D4:  CLRF   36
.................... 			break;
.................... 		default:
.................... 			/* do nothing */
.................... 	}
01D6:  GOTO   041C (RETURN)
.................... 
.................... }
.................... 
.................... 
.................... int16 map_i2c(int8 addr) {
.................... 	static int16 lsw=0xffff;
.................... 
.................... 	timers.led_on_a=100;
01DA:  MOVLW  64
01DC:  MOVWF  x63
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 	switch ( addr ) {
01DE:  MOVF   x8D,W
01E0:  BZ    023C
01E2:  XORLW  01
01E4:  BZ    025A
01E6:  XORLW  03
01E8:  BZ    0264
01EA:  XORLW  01
01EC:  BZ    0282
01EE:  XORLW  07
01F0:  BZ    028C
01F2:  XORLW  01
01F4:  BZ    02AA
01F6:  XORLW  03
01F8:  BZ    02B4
01FA:  XORLW  01
01FC:  BZ    02D2
01FE:  XORLW  0F
0200:  BTFSC  FD8.2
0202:  BRA    02DC
0204:  XORLW  01
0206:  BTFSC  FD8.2
0208:  BRA    02E6
020A:  XORLW  03
020C:  BTFSC  FD8.2
020E:  BRA    02F0
0210:  XORLW  01
0212:  BTFSC  FD8.2
0214:  BRA    030E
0216:  XORLW  07
0218:  BTFSC  FD8.2
021A:  BRA    0318
021C:  XORLW  01
021E:  BTFSC  FD8.2
0220:  BRA    0336
0222:  XORLW  03
0224:  BTFSC  FD8.2
0226:  BRA    0340
0228:  XORLW  01
022A:  BTFSC  FD8.2
022C:  BRA    035E
022E:  XORLW  1F
0230:  BTFSC  FD8.2
0232:  BRA    0368
0234:  XORLW  01
0236:  BTFSC  FD8.2
0238:  BRA    0372
023A:  BRA    037C
.................... #if 0
.................... 		case 0: return rtest[0];
.................... 		case 1: return rtest[1];
.................... 		case 2: return rtest[2];
.................... 		case 3: return rtest[3];
.................... 		case 4: return rtest[4];
.................... 		case 5: return rtest[5];
.................... 		case 6: return rtest[6];
.................... 		case 7: return rtest[7];
.................... #endif
.................... 
.................... 		/* 32 bit variables have the most significant word read first and that sets the
.................... 		   least sinificant word which can be read next. _LSW registers are only valid if
.................... 		   they are preceeded by a read on the matching _MSW register
.................... 		 */
.................... 		case I2C_REG_VBUS_A_MSW:
.................... 			lsw = make16(make8(current.vbus_a,1),make8(current.vbus_a,0));
023C:  MOVFF  1B,65
0240:  MOVFF  1A,64
.................... 			return (int16) make16(make8(current.vbus_a,3),make8(current.vbus_a,2));
0244:  MOVFF  1D,8E
0248:  MOVFF  1C,8F
024C:  MOVFF  1D,03
0250:  MOVFF  1C,01
0254:  MOVFF  1D,02
0258:  BRA    0382
.................... 		case I2C_REG_VBUS_A_LSW:
.................... 			return (int16) lsw;
025A:  MOVFF  64,01
025E:  MOVFF  65,02
0262:  BRA    0382
.................... 		case I2C_REG_VSHUNT_A_MSW:
.................... 			lsw = make16(make8(current.vshunt_a,1),make8(current.vshunt_a,0));
0264:  MOVFF  1F,65
0268:  MOVFF  1E,64
.................... 			return (int16) make16(make8(current.vshunt_a,3),make8(current.vshunt_a,2));
026C:  MOVFF  21,8E
0270:  MOVFF  20,8F
0274:  MOVFF  21,03
0278:  MOVFF  20,01
027C:  MOVFF  21,02
0280:  BRA    0382
.................... 		case I2C_REG_VSHUNT_A_LSW:
.................... 			return (int16) lsw;    
0282:  MOVFF  64,01
0286:  MOVFF  65,02
028A:  BRA    0382
.................... 
.................... 		case I2C_REG_VBUS_B_MSW:
.................... 			lsw = make16(make8(current.vbus_a,1),make8(current.vbus_a,0));
028C:  MOVFF  1B,65
0290:  MOVFF  1A,64
.................... 			return (int16) make16(make8(current.vbus_b,3),make8(current.vbus_b,2));
0294:  MOVFF  25,8E
0298:  MOVFF  24,8F
029C:  MOVFF  25,03
02A0:  MOVFF  24,01
02A4:  MOVFF  25,02
02A8:  BRA    0382
.................... 		case I2C_REG_VBUS_B_LSW:
.................... 			return (int16) lsw;
02AA:  MOVFF  64,01
02AE:  MOVFF  65,02
02B2:  BRA    0382
.................... 		case I2C_REG_VSHUNT_B_MSW:
.................... 			lsw = make16(make8(current.vshunt_b,1),make8(current.vshunt_b,0));
02B4:  MOVFF  27,65
02B8:  MOVFF  26,64
.................... 			return (int16) make16(make8(current.vshunt_b,3),make8(current.vshunt_b,2));
02BC:  MOVFF  29,8E
02C0:  MOVFF  28,8F
02C4:  MOVFF  29,03
02C8:  MOVFF  28,01
02CC:  MOVFF  29,02
02D0:  BRA    0382
.................... 		case I2C_REG_VSHUNT_B_LSW:
.................... 			return (int16) lsw;    
02D2:  MOVFF  64,01
02D6:  MOVFF  65,02
02DA:  BRA    0382
.................... 
.................... 
.................... 		case I2C_REG_COUNT_A_LAST_SECOND:
.................... 			return (int16) current.count_a_last_second;
02DC:  MOVFF  2A,01
02E0:  MOVFF  2B,02
02E4:  BRA    0382
.................... 		case I2C_REG_COUNT_B_LAST_SECOND:
.................... 			return (int16) current.count_b_last_second;
02E6:  MOVFF  2C,01
02EA:  MOVFF  2D,02
02EE:  BRA    0382
.................... 
.................... 		case I2C_REG_COUNT_A_LONG_MSW:
.................... 			lsw = make16(make8(current.count_a_long,1),make8(current.count_a_long,0));
02F0:  MOVFF  2F,65
02F4:  MOVFF  2E,64
.................... 			return (int16) make16(make8(current.count_a_long,3),make8(current.count_a_long,2));
02F8:  MOVFF  31,8E
02FC:  MOVFF  30,8F
0300:  MOVFF  31,03
0304:  MOVFF  30,01
0308:  MOVFF  31,02
030C:  BRA    0382
.................... 		case I2C_REG_COUNT_A_LONG_LSW:
.................... 			return (int16) lsw;
030E:  MOVFF  64,01
0312:  MOVFF  65,02
0316:  BRA    0382
.................... 		case I2C_REG_COUNT_B_LONG_MSW:
.................... 			lsw = make16(make8(current.count_b_long,1),make8(current.count_b_long,0));
0318:  MOVFF  33,65
031C:  MOVFF  32,64
.................... 			return (int16) make16(make8(current.count_b_long,3),make8(current.count_b_long,2));
0320:  MOVFF  35,8E
0324:  MOVFF  34,8F
0328:  MOVFF  35,03
032C:  MOVFF  34,01
0330:  MOVFF  35,02
0334:  BRA    0382
.................... 		case I2C_REG_COUNT_B_LONG_LSW:
.................... 			return (int16) lsw;
0336:  MOVFF  64,01
033A:  MOVFF  65,02
033E:  BRA    0382
.................... 		case I2C_REG_COUNT_LONG_SECONDS_MSW:
.................... 			lsw = make16(make8(current.count_seconds_long,1),make8(current.count_seconds_long,0));
0340:  MOVFF  37,65
0344:  MOVFF  36,64
.................... 			return (int16) make16(make8(current.count_seconds_long,3),make8(current.count_seconds_long,2));
0348:  MOVFF  39,8E
034C:  MOVFF  38,8F
0350:  MOVFF  39,03
0354:  MOVFF  38,01
0358:  MOVFF  39,02
035C:  BRA    0382
.................... 		case I2C_REG_COUNT_LONG_SECONDS_LSW:
.................... 			return (int16) lsw;
035E:  MOVFF  64,01
0362:  MOVFF  65,02
0366:  BRA    0382
.................... 
.................... 		case I2C_REG_DIETEMP_A:
.................... 			return (int16) current.dietemp_a;
0368:  MOVFF  3A,01
036C:  MOVFF  3B,02
0370:  BRA    0382
.................... 		case I2C_REG_DIETEMP_B:
.................... 			return (int16) current.dietemp_b;
0372:  MOVFF  3C,01
0376:  MOVFF  3D,02
037A:  BRA    0382
.................... 
.................... 		/* we should have range checked, and never gotten here ... or read unimplemented (future) register */
.................... 		default: return (int16) addr;
037C:  MOVFF  8D,01
0380:  CLRF   02
.................... 	}
0382:  GOTO   0430 (RETURN)
.................... 
.................... }
.................... 
.................... 
.................... 
.................... #include "interrupt_dcswc_module_voltage_current_counter.c"
.................... #int_timer2
.................... void isr_timer2() {
.................... 	static int16 ticks=0;
.................... 	static short count_a_last=0;
.................... 	static short count_b_last=0;
.................... 	short count_a_now;
.................... 	short count_b_now;
.................... 
.................... 
.................... 	/* external input counting */
.................... 	count_a_now=input(COUNT_A);
*
00BA:  BSF    F94.4
00BC:  BCF    x8A.0
00BE:  BTFSC  F82.4
00C0:  BSF    x8A.0
.................... 	if ( 0 == count_a_now && 1 == count_a_last ) {
00C2:  BTFSC  x8A.0
00C4:  BRA    00D0
00C6:  BTFSS  x68.0
00C8:  BRA    00D0
.................... 		next.count_a_last_second++;
00CA:  INCF   4E,F
00CC:  BTFSC  FD8.2
00CE:  INCF   4F,F
.................... 	}
.................... 	count_a_last=count_a_now;
00D0:  BCF    x68.0
00D2:  BTFSC  x8A.0
00D4:  BSF    x68.0
.................... 
.................... 	count_b_now=input(COUNT_B);
00D6:  BSF    F94.5
00D8:  BCF    x8A.1
00DA:  BTFSC  F82.5
00DC:  BSF    x8A.1
.................... 	if ( 0 == count_b_now && 1 == count_b_last ) {
00DE:  BTFSC  x8A.1
00E0:  BRA    00EC
00E2:  BTFSS  x68.1
00E4:  BRA    00EC
.................... 		next.count_b_last_second++;
00E6:  INCF   50,F
00E8:  BTFSC  FD8.2
00EA:  INCF   51,F
.................... 	}
.................... 	count_b_last=count_b_now;
00EC:  BCF    x68.1
00EE:  BTFSC  x8A.1
00F0:  BSF    x68.1
.................... 
.................... 
.................... 	/* timing */
.................... 
.................... 	timers.now_millisecond=1;
00F2:  BSF    x62.0
.................... 
.................... 	ticks++;
00F4:  INCF   x66,F
00F6:  BTFSC  FD8.2
00F8:  INCF   x67,F
.................... 	if ( 500 == ticks ) {
00FA:  MOVF   x66,W
00FC:  SUBLW  F4
00FE:  BNZ   0108
0100:  DECFSZ x67,W
0102:  BRA    0108
.................... 		timers.now_ina=1;
0104:  BSF    x62.1
.................... 	} else if ( 1000 == ticks ) {
0106:  BRA    01AC
0108:  MOVF   x66,W
010A:  SUBLW  E8
010C:  BNZ   01AC
010E:  MOVF   x67,W
0110:  SUBLW  03
0112:  BNZ   01AC
.................... 		current.vbus_a=next.vbus_a;
0114:  MOVFF  41,1D
0118:  MOVFF  40,1C
011C:  MOVFF  3F,1B
0120:  MOVFF  3E,1A
.................... 		current.vshunt_a=next.vshunt_a;
0124:  MOVFF  45,21
0128:  MOVFF  44,20
012C:  MOVFF  43,1F
0130:  MOVFF  42,1E
.................... 		current.dietemp_a=next.dietemp_a;	
0134:  MOVFF  5F,3B
0138:  MOVFF  5E,3A
.................... 
.................... 		current.vbus_b=next.vbus_b;
013C:  MOVFF  49,25
0140:  MOVFF  48,24
0144:  MOVFF  47,23
0148:  MOVFF  46,22
.................... 		current.vshunt_b=next.vshunt_b;
014C:  MOVFF  4D,29
0150:  MOVFF  4C,28
0154:  MOVFF  4B,27
0158:  MOVFF  4A,26
.................... 		current.dietemp_b=next.dietemp_b;
015C:  MOVFF  61,3D
0160:  MOVFF  60,3C
.................... 
.................... 		current.count_a_last_second=next.count_a_last_second;
0164:  MOVFF  4F,2B
0168:  MOVFF  4E,2A
.................... 
.................... 		current.count_b_last_second=next.count_b_last_second;	
016C:  MOVFF  51,2D
0170:  MOVFF  50,2C
.................... 
.................... 		current.count_a_long += current.count_a_last_second;
0174:  MOVF   2A,W
0176:  ADDWF  2E,F
0178:  MOVF   2B,W
017A:  ADDWFC 2F,F
017C:  MOVLW  00
017E:  ADDWFC 30,F
0180:  ADDWFC 31,F
.................... 		current.count_b_long += current.count_b_last_second;
0182:  MOVF   2C,W
0184:  ADDWF  32,F
0186:  MOVF   2D,W
0188:  ADDWFC 33,F
018A:  MOVLW  00
018C:  ADDWFC 34,F
018E:  ADDWFC 35,F
.................... 	
.................... 		current.count_seconds_long++;
0190:  MOVLW  01
0192:  ADDWF  36,F
0194:  BTFSC  FD8.0
0196:  INCF   37,F
0198:  BTFSC  FD8.2
019A:  INCF   38,F
019C:  BTFSC  FD8.2
019E:  INCF   39,F
.................... 
.................... 		/* reset our counters */
.................... 		next.count_a_last_second=0;
01A0:  CLRF   4F
01A2:  CLRF   4E
.................... 		next.count_b_last_second=0;
01A4:  CLRF   51
01A6:  CLRF   50
.................... 
.................... 		ticks=0;
01A8:  CLRF   x67
01AA:  CLRF   x66
.................... 	}
.................... }
.................... 
.................... 
.................... /* I2C slave interrupt */
01AC:  BCF    F9E.1
01AE:  GOTO   006C
.................... #byte SSPSTAT=GETENV("SFR:SSPSTAT")
.................... #INT_SSP
.................... void ssp_interrupt () {
.................... 	static int8 sstate;
.................... 	int8 state;
.................... 	int8 incoming;
.................... 	static int16 lastValue;
.................... 	static int8 lastMSB;
.................... 
.................... 	static int8 address; 
.................... 
.................... 	/* 
.................... 	our implementation of i2c_isr_state() that won't overflow and switch states
.................... 	but it will quit counting at 127 bytes. 
.................... 	If more bytes are needed, external counting variables can be used or the size of state can be made larger
.................... 	*/
.................... 
.................... 
.................... 	if ( ! bit_test(SSPSTAT,5) ) {
*
039C:  BTFSC  FC7.5
039E:  BRA    03A8
.................... 		/* address */
.................... 		sstate=0;
03A0:  CLRF   x69
.................... 
.................... 		if ( bit_test(SSPSTAT,2) ) {
03A2:  BTFSS  FC7.2
03A4:  BRA    03A8
.................... 			/* set high bit if read */
.................... 			bit_set(sstate,7);
03A6:  BSF    x69.7
.................... 		}
.................... 	} else {
.................... 		/* data */
.................... 	}
.................... 
.................... 	/* state variable used below is not incremented */
.................... 	state=sstate;
03A8:  MOVFF  69,8A
.................... 
.................... 	/* increment the state counter for next pass through unless it will overflow us into another state */
.................... 	if ( sstate != 0x7f && sstate != 0xff) {
03AC:  MOVF   x69,W
03AE:  SUBLW  7F
03B0:  BZ    03BA
03B2:  INCFSZ x69,W
03B4:  BRA    03B8
03B6:  BRA    03BA
.................... 		sstate++;
03B8:  INCF   x69,F
.................... 	}
.................... 
.................... 	
.................... 	/* i2c_isr_state() return an 8 bit int
.................... 		0 - Address match received with R/W bit clear, perform i2c_read( ) to read the I2C address.
.................... 		1-0x7F - Master has written data; i2c_read() will immediately return the data
.................... 		0x80 - Address match received with R/W bit set; perform i2c_read( ) to read the I2C address,
.................... 		and use i2c_write( ) to pre-load the transmit buffer for the next transaction (next I2C read
.................... 		performed by master will read this byte).
.................... 		0x81-0xFF - Transmission completed and acknowledged; respond with i2c_write() to pre-load
.................... 		the transmit buffer for the next transition (the next I2C read performed by master will read this
.................... 		byte).
.................... 		Function:
.................... 		Returns the state of I2C communications in I2C slave mode after an SSP interrupt. The return
.................... 		value increments with each byte received or sent.
.................... 		If 0x00 or 0x80 is returned, an i2C_read( ) needs to be performed to read the I2C address that
.................... 		was sent (it will match the address configured by #USE I2C so this value can be ignored)
.................... 	*/
.................... 
.................... 	if ( state <= 0x80 ) {                      
03BA:  MOVF   x8A,W
03BC:  SUBLW  80
03BE:  BNC   041C
.................... 		/* I2C master is sending us data */
.................... 		if ( 0x80 == state ) {
03C0:  MOVF   x8A,W
03C2:  SUBLW  80
03C4:  BNZ   03CC
.................... 			/* i2c_read(2) casues the function to read the SSPBUF without releasing the clock */
.................... 			incoming = i2c_read(STREAM_SLAVE,2);
03C6:  MOVFF  FC9,8B
.................... 		} else {
03CA:  BRA    03D8
.................... 			incoming = i2c_read(STREAM_SLAVE);
03CC:  BCF    FC6.6
03CE:  BTFSS  FC7.0
03D0:  BRA    03CE
03D2:  MOVF   FC9,W
03D4:  BSF    FC6.4
03D6:  MOVWF  x8B
.................... 		}
.................... 
.................... 		if ( 1 == state ) {             
03D8:  DECFSZ x8A,W
03DA:  BRA    03E4
.................... 			address = incoming<<1;
03DC:  BCF    FD8.0
03DE:  RLCF   x8B,W
03E0:  MOVWF  x6D
.................... 		} else if ( state >= 2 && 0x80 != state ) {
03E2:  BRA    041C
03E4:  MOVF   x8A,W
03E6:  SUBLW  01
03E8:  BC    041C
03EA:  MOVF   x8A,W
03EC:  SUBLW  80
03EE:  BZ    041C
.................... 			/* received byte is data */
.................... 		
.................... 			/* save MSB and we'll process it on next */
.................... 			if ( 2 == state ) {
03F0:  MOVF   x8A,W
03F2:  SUBLW  02
03F4:  BNZ   03FC
.................... 				lastMSB=incoming;
03F6:  MOVFF  8B,6C
.................... 			} else if ( 3 == state ) {
03FA:  BRA    041C
03FC:  MOVF   x8A,W
03FE:  SUBLW  03
0400:  BNZ   041C
.................... 				/* 16 bit value made of previous byte and this byte */
.................... 				write_i2c(address>>1,make16(lastMSB,incoming));
0402:  BCF    FD8.0
0404:  RRCF   x6D,W
0406:  MOVWF  x8C
0408:  MOVFF  6C,8E
040C:  MOVFF  8B,8D
0410:  MOVWF  x8F
0412:  MOVFF  6C,91
0416:  MOVFF  8B,90
041A:  BRA    01B2
.................... 
.................... 				/* this write only works for a single register per I2C transaction */
.................... 				/* this is not a BUG, but it would need to be implemented if this functionality is needed */
.................... 			}
.................... 		}
.................... 	}
.................... 
.................... 
.................... 	if ( state >= 0x80 ) {
041C:  MOVF   x8A,W
041E:  SUBLW  7F
0420:  BC    0450
.................... 		/* I2C master is requesting data from us */
.................... 
.................... 		if ( ! bit_test(address,0) ) {
0422:  BTFSC  x6D.0
0424:  BRA    0444
.................... 			/* read 16 bit register (register address half of I2C address) on even address */
.................... 			lastValue=map_i2c(address>>1);
0426:  BCF    FD8.0
0428:  RRCF   x6D,W
042A:  MOVWF  x8C
042C:  MOVWF  x8D
042E:  BRA    01DA
0430:  MOVFF  02,6B
0434:  MOVFF  01,6A
.................... 
.................... 			/* send the MSB */
.................... 			i2c_write(STREAM_SLAVE,make8(lastValue,1));
0438:  MOVFF  6B,8C
043C:  MOVFF  6B,8D
0440:  RCALL  0386
.................... 		} else {
0442:  BRA    044E
.................... 			/* send LSB of 16 bit register on odd address */
.................... 			i2c_write(STREAM_SLAVE,make8(lastValue,0));
0444:  MOVFF  6A,8C
0448:  MOVFF  6A,8D
044C:  RCALL  0386
.................... 		}
.................... 		address++;
044E:  INCF   x6D,F
.................... 	}
0450:  BCF    F9E.3
0452:  GOTO   006C
.................... }
.................... 
.................... 
.................... int8 read_dip_switch(void) {
.................... 	/* nomenclature is backwards on netlist. We actually want LSB on top */
.................... 	return ( ! input(PIC_ADDR_LSB)<<1 ) | ( ! input(PIC_ADDR_MSB) );
*
05CA:  BSF    F94.7
05CC:  MOVLW  00
05CE:  BTFSS  F82.7
05D0:  MOVLW  01
05D2:  MOVWF  00
05D4:  BCF    FD8.0
05D6:  RLCF   00,W
05D8:  MOVWF  x71
05DA:  BSF    F94.6
05DC:  MOVLW  00
05DE:  BTFSS  F82.6
05E0:  MOVLW  01
05E2:  IORWF  x71,W
05E4:  MOVWF  01
05E6:  RETURN 0
.................... }
.................... 
.................... void init(void) {
.................... 	setup_vref(VREF_OFF);
05E8:  CLRF   FBA
.................... 	setup_dac(DAC_OFF);
05EA:  CLRF   FBB
.................... 	setup_adc(ADC_OFF);
05EC:  BCF    FC2.0
.................... 	setup_adc_ports(NO_ANALOGS);
05EE:  MOVLW  00
05F0:  MOVWF  F7E
05F2:  BCF    FC1.0
05F4:  BCF    FC1.1
05F6:  BCF    FC1.2
05F8:  BCF    FC1.3
05FA:  MOVWF  F7F
.................... 
.................... 
.................... 
.................... 	set_tris_a    (0b00111111);
05FC:  MOVLW  3F
05FE:  MOVWF  F92
.................... 	port_a_pullups(0b00110000);
0600:  MOVLW  30
0602:  MOVWF  F77
0604:  BCF    FF1.7
.................... //                   76543210
.................... 
.................... 	set_tris_b    (0b01110000);
0606:  MOVLW  70
0608:  MOVWF  F93
.................... 	port_b_pullups(0b00000000);
060A:  CLRF   F78
.................... //                   76543210
.................... 
.................... 	set_tris_c    (0b11110011);
060C:  MOVLW  F3
060E:  MOVWF  F94
.................... //                   76543210
.................... 
.................... 
.................... 	/* data structure initialization */
.................... 	/* all initialized to 0 on declaration. Just do this if need non-zero */
.................... 
.................... 
.................... 	/* one periodic interrupt @ 1mS. Generated from system 16 MHz clock */
.................... 	/* prescale=16, match=249, postscale=1. Match is 249 because when match occurs, one cycle is lost */
.................... 	setup_timer_2(T2_DIV_BY_16,249,1);
0610:  MOVLW  00
0612:  IORLW  06
0614:  MOVWF  FCA
0616:  MOVLW  F9
0618:  MOVWF  FCB
.................... 
.................... 	enable_interrupts(INT_TIMER2);
061A:  BSF    F9D.1
.................... 
.................... 	/* set I2C slave address, which is always an even number */
.................... 	i2c_slaveaddr(0x36 + (read_dip_switch()<<1) );
061C:  RCALL  05CA
061E:  BCF    FD8.0
0620:  RLCF   01,W
0622:  ADDLW  36
0624:  MOVWF  FC8
0626:  GOTO   0D0A (RETURN)
.................... 
.................... }
.................... 
.................... 
.................... void action_now_ina(void) {
.................... 	timers.now_ina=0;
*
084A:  BCF    x62.1
.................... 
.................... 	/* sample INA228 at middle of 1 second window */
.................... 	next.vbus_a=ina228_read24(INA228_A_ADDR,INA228_REG_VBUS);
084C:  MOVLW  80
084E:  MOVWF  x71
0850:  MOVLW  05
0852:  MOVWF  x72
0854:  RCALL  0726
0856:  MOVFF  03,41
085A:  MOVFF  02,40
085E:  MOVFF  01,3F
0862:  MOVFF  00,3E
.................... 	next.vshunt_a=ina228_read24(INA228_A_ADDR,INA228_REG_VSHUNT);
0866:  MOVLW  80
0868:  MOVWF  x71
086A:  MOVLW  04
086C:  MOVWF  x72
086E:  RCALL  0726
0870:  MOVFF  03,45
0874:  MOVFF  02,44
0878:  MOVFF  01,43
087C:  MOVFF  00,42
.................... 
.................... 	next.vbus_b=ina228_read24(INA228_B_ADDR,INA228_REG_VBUS);
0880:  MOVLW  9A
0882:  MOVWF  x71
0884:  MOVLW  05
0886:  MOVWF  x72
0888:  RCALL  0726
088A:  MOVFF  03,49
088E:  MOVFF  02,48
0892:  MOVFF  01,47
0896:  MOVFF  00,46
.................... 	next.vshunt_b=ina228_read24(INA228_B_ADDR,INA228_REG_VSHUNT);
089A:  MOVLW  9A
089C:  MOVWF  x71
089E:  MOVLW  04
08A0:  MOVWF  x72
08A2:  RCALL  0726
08A4:  MOVFF  03,4D
08A8:  MOVFF  02,4C
08AC:  MOVFF  01,4B
08B0:  MOVFF  00,4A
.................... 
.................... 	next.dietemp_a=ina228_read16(INA228_A_ADDR,INA228_REG_DIETEMP);
08B4:  MOVLW  80
08B6:  MOVWF  x71
08B8:  MOVLW  06
08BA:  MOVWF  x72
08BC:  RCALL  07C4
08BE:  MOVFF  02,5F
08C2:  MOVFF  01,5E
.................... 	next.dietemp_b=ina228_read16(INA228_B_ADDR,INA228_REG_DIETEMP);
08C6:  MOVLW  9A
08C8:  MOVWF  x71
08CA:  MOVLW  06
08CC:  MOVWF  x72
08CE:  RCALL  07C4
08D0:  MOVFF  02,61
08D4:  MOVFF  01,60
08D8:  GOTO   0D82 (RETURN)
.................... }
.................... 
.................... 
.................... void periodic_millisecond(void) {
.................... 	timers.now_millisecond=0;
08DC:  BCF    x62.0
.................... 
.................... 	/* LED control */
.................... 	if ( 0==timers.led_on_a ) {
08DE:  MOVF   x63,F
08E0:  BNZ   08E8
.................... 		output_low(LED_A);
08E2:  BCF    F94.3
08E4:  BCF    F8B.3
.................... 	} else {
08E6:  BRA    08EE
.................... 		output_high(LED_A);
08E8:  BCF    F94.3
08EA:  BSF    F8B.3
.................... 		timers.led_on_a--;
08EC:  DECF   x63,F
.................... 	}
08EE:  GOTO   0D88 (RETURN)
.................... 
.................... 
.................... }
.................... 
.................... /* use to see if a give address is on the I2C bus */
.................... int8 get_ack_status(int8 address) {
.................... 	int8 status;
.................... 
.................... 	i2c_start(STREAM_MASTER);
.................... 	status = i2c_write(STREAM_MASTER,address);  // Status = 0 if got an ACK
.................... 	i2c_stop(STREAM_MASTER);
.................... 
.................... 	if ( 0 == status )
.................... 		return(TRUE);
.................... 
....................    return(FALSE);
.................... }
.................... 
.................... 
.................... void main(void) {
*
0C74:  CLRF   FF8
0C76:  BCF    FD0.7
0C78:  BSF    07.7
0C7A:  BSF    F93.6
0C7C:  BSF    F93.4
0C7E:  CLRF   FC8
0C80:  MOVLW  36
0C82:  MOVWF  FC6
0C84:  BSF    FC5.0
0C86:  BSF    FC5.7
0C88:  CLRF   19
0C8A:  BSF    FB8.3
0C8C:  MOVLW  A0
0C8E:  MOVWF  FAF
0C90:  MOVLW  01
0C92:  MOVWF  FB0
0C94:  MOVLW  A6
0C96:  MOVWF  FAC
0C98:  MOVLW  90
0C9A:  MOVWF  FAB
0C9C:  CLRF   x6F
0C9E:  CLRF   x6E
0CA0:  MOVLW  00
0CA2:  MOVWF  F7E
0CA4:  BCF    FC1.0
0CA6:  BCF    FC1.1
0CA8:  BCF    FC1.2
0CAA:  BCF    FC1.3
0CAC:  MOVWF  F7F
0CAE:  CLRF   F6C
0CB0:  CLRF   F6B
0CB2:  CLRF   F6D
0CB4:  BCF    x68.0
0CB6:  BCF    x68.1
0CB8:  BRA    0CCA
0CBA:  DATA 4A,40
0CBC:  DATA 1A,00
0CBE:  DATA 04,80
0CC0:  DATA FF,FF
0CC2:  DATA 00,00
0CC4:  DATA 05,40
0CC6:  DATA 69,00
0CC8:  DATA 00,00
0CCA:  MOVLW  00
0CCC:  MOVWF  FF8
0CCE:  MOVLW  0C
0CD0:  MOVWF  FF7
0CD2:  MOVLW  BA
0CD4:  MOVWF  FF6
0CD6:  TBLRD*+
0CD8:  MOVF   FF5,W
0CDA:  MOVWF  00
0CDC:  XORLW  00
0CDE:  BZ    0D06
0CE0:  TBLRD*+
0CE2:  MOVF   FF5,W
0CE4:  MOVWF  01
0CE6:  BTFSC  FE8.7
0CE8:  BRA    0CF4
0CEA:  ANDLW  3F
0CEC:  MOVWF  FEA
0CEE:  TBLRD*+
0CF0:  MOVFF  FF5,FE9
0CF4:  BTFSC  01.6
0CF6:  TBLRD*+
0CF8:  BTFSS  01.6
0CFA:  TBLRD*+
0CFC:  MOVFF  FF5,FEE
0D00:  DCFSNZ 00,F
0D02:  BRA    0CD6
0D04:  BRA    0CF8
0D06:  CLRF   FF8
.................... 	int8 i;
.................... 
.................... 	init();
0D08:  BRA    05E8
.................... 
.................... 
.................... 
.................... 	/* flash on startup */
.................... 	for ( i=0 ; i<5 ; i++ ) {
0D0A:  CLRF   x70
0D0C:  MOVF   x70,W
0D0E:  SUBLW  04
0D10:  BNC   0D2C
.................... 		restart_wdt();
0D12:  CLRWDT
.................... 		output_high(LED_A);
0D14:  BCF    F94.3
0D16:  BSF    F8B.3
.................... 		delay_ms(200);
0D18:  MOVLW  C8
0D1A:  MOVWF  x72
0D1C:  RCALL  062A
.................... 		output_low(LED_A);
0D1E:  BCF    F94.3
0D20:  BCF    F8B.3
.................... 		delay_ms(200);
0D22:  MOVLW  C8
0D24:  MOVWF  x72
0D26:  RCALL  062A
0D28:  INCF   x70,F
0D2A:  BRA    0D0C
.................... 	}
.................... 
.................... 	delay_ms(1000);
0D2C:  MOVLW  04
0D2E:  MOVWF  x71
0D30:  MOVLW  FA
0D32:  MOVWF  x72
0D34:  RCALL  062A
0D36:  DECFSZ x71,F
0D38:  BRA    0D30
.................... 
.................... 	fprintf(STREAM_FTDI,"# dcswc_module_voltage_current_counter %s\r\n",__DATE__);
0D3A:  MOVLW  56
0D3C:  MOVWF  FF6
0D3E:  MOVLW  04
0D40:  MOVWF  FF7
0D42:  MOVLW  27
0D44:  MOVWF  x72
0D46:  RCALL  0652
0D48:  MOVLW  82
0D4A:  MOVWF  FF6
0D4C:  MOVLW  04
0D4E:  MOVWF  FF7
0D50:  BRA    0672
0D52:  MOVLW  0D
0D54:  BTFSS  F9E.4
0D56:  BRA    0D54
0D58:  MOVWF  FAD
0D5A:  MOVLW  0A
0D5C:  BTFSS  F9E.4
0D5E:  BRA    0D5C
0D60:  MOVWF  FAD
.................... 
.................... 	delay_ms(1000);
0D62:  MOVLW  04
0D64:  MOVWF  x71
0D66:  MOVLW  FA
0D68:  MOVWF  x72
0D6A:  RCALL  062A
0D6C:  DECFSZ x71,F
0D6E:  BRA    0D66
.................... 
.................... 	timers.led_on_a=500;
0D70:  MOVLW  F4
0D72:  MOVWF  x63
.................... 
.................... 	enable_interrupts(GLOBAL);
0D74:  MOVLW  C0
0D76:  IORWF  FF2,F
.................... 
.................... 	/* enable I2C slave interrupt */
.................... 	enable_interrupts(INT_SSP);
0D78:  BSF    F9D.3
.................... 
.................... 	for ( ; ; ) {
.................... 		restart_wdt();
0D7A:  CLRWDT
.................... 
.................... 		/* query INA228's for next */
.................... 		if ( timers.now_ina ) {
0D7C:  BTFSS  x62.1
0D7E:  BRA    0D82
.................... 			action_now_ina();
0D80:  BRA    084A
.................... 		}
.................... 
.................... 		if ( timers.now_millisecond ) {
0D82:  BTFSS  x62.0
0D84:  BRA    0D88
.................... 			periodic_millisecond();
0D86:  BRA    08DC
.................... 		}
.................... 
.................... 		if ( kbhit() ) {
0D88:  BTFSS  F9E.5
0D8A:  BRA    1058
.................... 			getc();
0D8C:  BRA    08F2
.................... 
.................... 			fprintf(STREAM_FTDI,"# DIP SWITCHES: %d\r\n",
.................... 				read_dip_switch()
.................... 			);
0D8E:  RCALL  05CA
0D90:  MOVFF  01,71
0D94:  MOVLW  8C
0D96:  MOVWF  FF6
0D98:  MOVLW  04
0D9A:  MOVWF  FF7
0D9C:  MOVLW  10
0D9E:  MOVWF  x72
0DA0:  RCALL  0652
0DA2:  MOVFF  71,72
0DA6:  MOVLW  18
0DA8:  MOVWF  x73
0DAA:  BRA    0932
0DAC:  MOVLW  0D
0DAE:  BTFSS  F9E.4
0DB0:  BRA    0DAE
0DB2:  MOVWF  FAD
0DB4:  MOVLW  0A
0DB6:  BTFSS  F9E.4
0DB8:  BRA    0DB6
0DBA:  MOVWF  FAD
.................... 
.................... 			fprintf(STREAM_FTDI,"# A: 0x%08lx / 0x%08lx / 0x%04lu\r\n",
.................... 				current.vbus_a,
.................... 				current.vshunt_a,
.................... 				current.dietemp_a
.................... 			);
0DBC:  MOVLW  A2
0DBE:  MOVWF  FF6
0DC0:  MOVLW  04
0DC2:  MOVWF  FF7
0DC4:  MOVLW  07
0DC6:  MOVWF  x72
0DC8:  RCALL  0652
0DCA:  MOVFF  1D,71
0DCE:  MOVLW  57
0DD0:  MOVWF  x72
0DD2:  RCALL  09E6
0DD4:  MOVFF  1C,71
0DD8:  MOVLW  57
0DDA:  MOVWF  x72
0DDC:  RCALL  09E6
0DDE:  MOVFF  1B,71
0DE2:  MOVLW  57
0DE4:  MOVWF  x72
0DE6:  RCALL  09E6
0DE8:  MOVFF  1A,71
0DEC:  MOVLW  57
0DEE:  MOVWF  x72
0DF0:  RCALL  09E6
0DF2:  MOVLW  AE
0DF4:  MOVWF  FF6
0DF6:  MOVLW  04
0DF8:  MOVWF  FF7
0DFA:  MOVLW  05
0DFC:  MOVWF  x72
0DFE:  RCALL  0652
0E00:  MOVFF  21,71
0E04:  MOVLW  57
0E06:  MOVWF  x72
0E08:  RCALL  09E6
0E0A:  MOVFF  20,71
0E0E:  MOVLW  57
0E10:  MOVWF  x72
0E12:  RCALL  09E6
0E14:  MOVFF  1F,71
0E18:  MOVLW  57
0E1A:  MOVWF  x72
0E1C:  RCALL  09E6
0E1E:  MOVFF  1E,71
0E22:  MOVLW  57
0E24:  MOVWF  x72
0E26:  RCALL  09E6
0E28:  MOVLW  B8
0E2A:  MOVWF  FF6
0E2C:  MOVLW  04
0E2E:  MOVWF  FF7
0E30:  MOVLW  05
0E32:  MOVWF  x72
0E34:  RCALL  0652
0E36:  MOVLW  09
0E38:  MOVWF  FE9
0E3A:  MOVFF  3B,72
0E3E:  MOVFF  3A,71
0E42:  RCALL  0A28
0E44:  MOVLW  0D
0E46:  BTFSS  F9E.4
0E48:  BRA    0E46
0E4A:  MOVWF  FAD
0E4C:  MOVLW  0A
0E4E:  BTFSS  F9E.4
0E50:  BRA    0E4E
0E52:  MOVWF  FAD
.................... 			fprintf(STREAM_FTDI,"# B: 0x%08lx / 0x%08lx / 0x%04lu\r\n",
.................... 				current.vbus_b,
.................... 				current.vshunt_b,
.................... 				current.dietemp_b
.................... 			);
0E54:  MOVLW  C6
0E56:  MOVWF  FF6
0E58:  MOVLW  04
0E5A:  MOVWF  FF7
0E5C:  MOVLW  07
0E5E:  MOVWF  x72
0E60:  CALL   0652
0E64:  MOVFF  25,71
0E68:  MOVLW  57
0E6A:  MOVWF  x72
0E6C:  RCALL  09E6
0E6E:  MOVFF  24,71
0E72:  MOVLW  57
0E74:  MOVWF  x72
0E76:  RCALL  09E6
0E78:  MOVFF  23,71
0E7C:  MOVLW  57
0E7E:  MOVWF  x72
0E80:  RCALL  09E6
0E82:  MOVFF  22,71
0E86:  MOVLW  57
0E88:  MOVWF  x72
0E8A:  RCALL  09E6
0E8C:  MOVLW  D2
0E8E:  MOVWF  FF6
0E90:  MOVLW  04
0E92:  MOVWF  FF7
0E94:  MOVLW  05
0E96:  MOVWF  x72
0E98:  CALL   0652
0E9C:  MOVFF  29,71
0EA0:  MOVLW  57
0EA2:  MOVWF  x72
0EA4:  RCALL  09E6
0EA6:  MOVFF  28,71
0EAA:  MOVLW  57
0EAC:  MOVWF  x72
0EAE:  RCALL  09E6
0EB0:  MOVFF  27,71
0EB4:  MOVLW  57
0EB6:  MOVWF  x72
0EB8:  RCALL  09E6
0EBA:  MOVFF  26,71
0EBE:  MOVLW  57
0EC0:  MOVWF  x72
0EC2:  RCALL  09E6
0EC4:  MOVLW  DC
0EC6:  MOVWF  FF6
0EC8:  MOVLW  04
0ECA:  MOVWF  FF7
0ECC:  MOVLW  05
0ECE:  MOVWF  x72
0ED0:  CALL   0652
0ED4:  MOVLW  09
0ED6:  MOVWF  FE9
0ED8:  MOVFF  3D,72
0EDC:  MOVFF  3C,71
0EE0:  RCALL  0A28
0EE2:  MOVLW  0D
0EE4:  BTFSS  F9E.4
0EE6:  BRA    0EE4
0EE8:  MOVWF  FAD
0EEA:  MOVLW  0A
0EEC:  BTFSS  F9E.4
0EEE:  BRA    0EEC
0EF0:  MOVWF  FAD
.................... 
.................... 			fprintf(STREAM_FTDI,"# current.count_a_last_second=%lu\r\n",
.................... 				current.count_a_last_second
.................... 			);
0EF2:  MOVLW  EA
0EF4:  MOVWF  FF6
0EF6:  MOVLW  04
0EF8:  MOVWF  FF7
0EFA:  MOVLW  1E
0EFC:  MOVWF  x72
0EFE:  CALL   0652
0F02:  MOVLW  10
0F04:  MOVWF  FE9
0F06:  MOVFF  2B,72
0F0A:  MOVFF  2A,71
0F0E:  RCALL  0A28
0F10:  MOVLW  0D
0F12:  BTFSS  F9E.4
0F14:  BRA    0F12
0F16:  MOVWF  FAD
0F18:  MOVLW  0A
0F1A:  BTFSS  F9E.4
0F1C:  BRA    0F1A
0F1E:  MOVWF  FAD
.................... 			fprintf(STREAM_FTDI,"# current.count_b_last_second=%lu\r\n",
.................... 				current.count_b_last_second
.................... 			);
0F20:  MOVLW  0E
0F22:  MOVWF  FF6
0F24:  MOVLW  05
0F26:  MOVWF  FF7
0F28:  MOVLW  1E
0F2A:  MOVWF  x72
0F2C:  CALL   0652
0F30:  MOVLW  10
0F32:  MOVWF  FE9
0F34:  MOVFF  2D,72
0F38:  MOVFF  2C,71
0F3C:  RCALL  0A28
0F3E:  MOVLW  0D
0F40:  BTFSS  F9E.4
0F42:  BRA    0F40
0F44:  MOVWF  FAD
0F46:  MOVLW  0A
0F48:  BTFSS  F9E.4
0F4A:  BRA    0F48
0F4C:  MOVWF  FAD
.................... 			fprintf(STREAM_FTDI,"# current.count_a_long=%lu\r\n",
.................... 				current.count_a_long
.................... 			);
0F4E:  MOVLW  32
0F50:  MOVWF  FF6
0F52:  MOVLW  05
0F54:  MOVWF  FF7
0F56:  MOVLW  17
0F58:  MOVWF  x72
0F5A:  CALL   0652
0F5E:  MOVLW  41
0F60:  MOVWF  FE9
0F62:  MOVFF  31,74
0F66:  MOVFF  30,73
0F6A:  MOVFF  2F,72
0F6E:  MOVFF  2E,71
0F72:  RCALL  0B62
0F74:  MOVLW  0D
0F76:  BTFSS  F9E.4
0F78:  BRA    0F76
0F7A:  MOVWF  FAD
0F7C:  MOVLW  0A
0F7E:  BTFSS  F9E.4
0F80:  BRA    0F7E
0F82:  MOVWF  FAD
.................... 			fprintf(STREAM_FTDI,"# current.count_b_long=%lu\r\n",
.................... 				current.count_b_long
.................... 			);
0F84:  MOVLW  50
0F86:  MOVWF  FF6
0F88:  MOVLW  05
0F8A:  MOVWF  FF7
0F8C:  MOVLW  17
0F8E:  MOVWF  x72
0F90:  CALL   0652
0F94:  MOVLW  41
0F96:  MOVWF  FE9
0F98:  MOVFF  35,74
0F9C:  MOVFF  34,73
0FA0:  MOVFF  33,72
0FA4:  MOVFF  32,71
0FA8:  RCALL  0B62
0FAA:  MOVLW  0D
0FAC:  BTFSS  F9E.4
0FAE:  BRA    0FAC
0FB0:  MOVWF  FAD
0FB2:  MOVLW  0A
0FB4:  BTFSS  F9E.4
0FB6:  BRA    0FB4
0FB8:  MOVWF  FAD
.................... 
.................... 			fprintf(STREAM_FTDI,"# current.count_seconds_long=%lu\r\n",
.................... 				current.count_seconds_long
.................... 			);
0FBA:  MOVLW  6E
0FBC:  MOVWF  FF6
0FBE:  MOVLW  05
0FC0:  MOVWF  FF7
0FC2:  MOVLW  1D
0FC4:  MOVWF  x72
0FC6:  CALL   0652
0FCA:  MOVLW  41
0FCC:  MOVWF  FE9
0FCE:  MOVFF  39,74
0FD2:  MOVFF  38,73
0FD6:  MOVFF  37,72
0FDA:  MOVFF  36,71
0FDE:  RCALL  0B62
0FE0:  MOVLW  0D
0FE2:  BTFSS  F9E.4
0FE4:  BRA    0FE2
0FE6:  MOVWF  FAD
0FE8:  MOVLW  0A
0FEA:  BTFSS  F9E.4
0FEC:  BRA    0FEA
0FEE:  MOVWF  FAD
.................... 
.................... 			fprintf(STREAM_FTDI,"# input(PIC_ADDR_MSB)=%u\r\n",input(PIC_ADDR_MSB));
0FF0:  BSF    F94.6
0FF2:  MOVLW  00
0FF4:  BTFSC  F82.6
0FF6:  MOVLW  01
0FF8:  MOVWF  x71
0FFA:  MOVLW  92
0FFC:  MOVWF  FF6
0FFE:  MOVLW  05
1000:  MOVWF  FF7
1002:  MOVLW  16
1004:  MOVWF  x72
1006:  CALL   0652
100A:  MOVFF  71,72
100E:  MOVLW  1B
1010:  MOVWF  x73
1012:  RCALL  0C08
1014:  MOVLW  0D
1016:  BTFSS  F9E.4
1018:  BRA    1016
101A:  MOVWF  FAD
101C:  MOVLW  0A
101E:  BTFSS  F9E.4
1020:  BRA    101E
1022:  MOVWF  FAD
.................... 			fprintf(STREAM_FTDI,"# input(PIC_ADDR_LSB)=%u\r\n",input(PIC_ADDR_LSB));
1024:  BSF    F94.7
1026:  MOVLW  00
1028:  BTFSC  F82.7
102A:  MOVLW  01
102C:  MOVWF  x71
102E:  MOVLW  AE
1030:  MOVWF  FF6
1032:  MOVLW  05
1034:  MOVWF  FF7
1036:  MOVLW  16
1038:  MOVWF  x72
103A:  CALL   0652
103E:  MOVFF  71,72
1042:  MOVLW  1B
1044:  MOVWF  x73
1046:  RCALL  0C08
1048:  MOVLW  0D
104A:  BTFSS  F9E.4
104C:  BRA    104A
104E:  MOVWF  FAD
1050:  MOVLW  0A
1052:  BTFSS  F9E.4
1054:  BRA    1052
1056:  MOVWF  FAD
.................... 
.................... 		}
1058:  BRA    0D7A
.................... 
.................... 
.................... 	}
.................... 
.................... 
.................... }
105A:  BRA    105A

Configuration Fuses:
   Word  1: 2200   HS NOPLLEN PCLKEN NOFCMEN NOIESO
   Word  2: 1819   NOPUT NOBROWNOUT BORV19 NOWDT WDT4096
   Word  3: 0000   NOHFOFST NOMCLR
   Word  4: 0009   STVREN NOLVP BBSIZ2K NOXINST DEBUG
   Word  5: C003   NOPROTECT NOCPB NOCPD
   Word  6: E003   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 4003   NOEBTR NOEBTRB

   Some fuses have been forced to be compatible with the ICD debugger.

ROM data:
F00000: 00 00 40 00                                        ..@.
