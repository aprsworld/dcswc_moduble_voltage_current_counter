CCS PCH C Compiler, Version 5.090, 49113               07-Jan-22 18:52

               Filename:   C:\Users\James Jarvis\Desktop\planetPrecision\dcswc_module_voltage_current_counter\dcswc_module_voltage_current_counter.lst

               ROM used:   3728 bytes (24%)
                           Largest free fragment is 11820
               RAM used:   112 (22%) at main() level
                           143 (28%) worst case
               Stack used: 4 locations (2 in main + 2 for interrupts)
               Stack size: 30

0000:  GOTO   0AB0
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  FF5,15
003C:  MOVFF  FF6,16
0040:  MOVFF  FF7,17
0044:  MOVFF  00,0E
0048:  MOVFF  01,0F
004C:  MOVFF  02,10
0050:  MOVFF  03,11
0054:  BTFSS  F9D.1
0056:  GOTO   0060
005A:  BTFSC  F9E.1
005C:  GOTO   00BA
0060:  BTFSS  F9D.3
0062:  GOTO   006C
0066:  BTFSC  F9E.3
0068:  GOTO   01E6
006C:  MOVFF  0E,00
0070:  MOVFF  0F,01
0074:  MOVFF  10,02
0078:  MOVFF  11,03
007C:  MOVFF  0C,FE9
0080:  MOVFF  07,FEA
0084:  BSF    07.7
0086:  MOVFF  08,FE1
008A:  MOVFF  09,FE2
008E:  MOVFF  0A,FD9
0092:  MOVFF  0B,FDA
0096:  MOVFF  12,FF3
009A:  MOVFF  13,FF4
009E:  MOVFF  14,FFA
00A2:  MOVFF  15,FF5
00A6:  MOVFF  16,FF6
00AA:  MOVFF  17,FF7
00AE:  MOVF   04,W
00B0:  MOVFF  06,FE0
00B4:  MOVFF  05,FD8
00B8:  RETFIE 0
.................... #include "dcswc_module_voltage_current_counter.h"
.................... #include <18F14K22.h>
.................... //////////// Standard Header file for the PIC18F14K22 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18F14K22
*
029A:  DATA 23,20
029C:  DATA 64,63
029E:  DATA 73,77
02A0:  DATA 63,5F
02A2:  DATA 6D,6F
02A4:  DATA 64,75
02A6:  DATA 6C,65
02A8:  DATA 5F,76
02AA:  DATA 6F,6C
02AC:  DATA 74,61
02AE:  DATA 67,65
02B0:  DATA 5F,63
02B2:  DATA 75,72
02B4:  DATA 72,65
02B6:  DATA 6E,74
02B8:  DATA 5F,63
02BA:  DATA 6F,75
02BC:  DATA 6E,74
02BE:  DATA 65,72
02C0:  DATA 20,25
02C2:  DATA 73,0D
02C4:  DATA 0A,00
02C6:  DATA 37,2D
02C8:  DATA 4A,61
02CA:  DATA 6E,2D
02CC:  DATA 32,32
02CE:  DATA 00,00
02D0:  DATA 23,20
02D2:  DATA 44,49
02D4:  DATA 50,20
02D6:  DATA 53,57
02D8:  DATA 49,54
02DA:  DATA 43,48
02DC:  DATA 45,53
02DE:  DATA 3A,20
02E0:  DATA 25,64
02E2:  DATA 0D,0A
02E4:  DATA 00,00
02E6:  DATA 23,20
02E8:  DATA 41,3A
02EA:  DATA 20,30
02EC:  DATA 78,25
02EE:  DATA 30,38
02F0:  DATA 6C,78
02F2:  DATA 20,2F
02F4:  DATA 20,30
02F6:  DATA 78,25
02F8:  DATA 30,38
02FA:  DATA 6C,78
02FC:  DATA 20,2F
02FE:  DATA 20,30
0300:  DATA 78,25
0302:  DATA 30,34
0304:  DATA 6C,75
0306:  DATA 0D,0A
0308:  DATA 00,00
030A:  DATA 23,20
030C:  DATA 42,3A
030E:  DATA 20,30
0310:  DATA 78,25
0312:  DATA 30,38
0314:  DATA 6C,78
0316:  DATA 20,2F
0318:  DATA 20,30
031A:  DATA 78,25
031C:  DATA 30,38
031E:  DATA 6C,78
0320:  DATA 20,2F
0322:  DATA 20,30
0324:  DATA 78,25
0326:  DATA 30,34
0328:  DATA 6C,75
032A:  DATA 0D,0A
032C:  DATA 00,00
032E:  DATA 23,20
0330:  DATA 63,75
0332:  DATA 72,72
0334:  DATA 65,6E
0336:  DATA 74,2E
0338:  DATA 63,6F
033A:  DATA 75,6E
033C:  DATA 74,5F
033E:  DATA 61,5F
0340:  DATA 6C,61
0342:  DATA 73,74
0344:  DATA 5F,73
0346:  DATA 65,63
0348:  DATA 6F,6E
034A:  DATA 64,3D
034C:  DATA 25,6C
034E:  DATA 75,0D
0350:  DATA 0A,00
0352:  DATA 23,20
0354:  DATA 63,75
0356:  DATA 72,72
0358:  DATA 65,6E
035A:  DATA 74,2E
035C:  DATA 63,6F
035E:  DATA 75,6E
0360:  DATA 74,5F
0362:  DATA 62,5F
0364:  DATA 6C,61
0366:  DATA 73,74
0368:  DATA 5F,73
036A:  DATA 65,63
036C:  DATA 6F,6E
036E:  DATA 64,3D
0370:  DATA 25,6C
0372:  DATA 75,0D
0374:  DATA 0A,00
0376:  DATA 23,20
0378:  DATA 63,75
037A:  DATA 72,72
037C:  DATA 65,6E
037E:  DATA 74,2E
0380:  DATA 63,6F
0382:  DATA 75,6E
0384:  DATA 74,5F
0386:  DATA 61,5F
0388:  DATA 6C,6F
038A:  DATA 6E,67
038C:  DATA 3D,25
038E:  DATA 6C,75
0390:  DATA 0D,0A
0392:  DATA 00,00
0394:  DATA 23,20
0396:  DATA 63,75
0398:  DATA 72,72
039A:  DATA 65,6E
039C:  DATA 74,2E
039E:  DATA 63,6F
03A0:  DATA 75,6E
03A2:  DATA 74,5F
03A4:  DATA 62,5F
03A6:  DATA 6C,6F
03A8:  DATA 6E,67
03AA:  DATA 3D,25
03AC:  DATA 6C,75
03AE:  DATA 0D,0A
03B0:  DATA 00,00
03B2:  DATA 23,20
03B4:  DATA 63,75
03B6:  DATA 72,72
03B8:  DATA 65,6E
03BA:  DATA 74,2E
03BC:  DATA 63,6F
03BE:  DATA 75,6E
03C0:  DATA 74,5F
03C2:  DATA 73,65
03C4:  DATA 63,6F
03C6:  DATA 6E,64
03C8:  DATA 73,5F
03CA:  DATA 6C,6F
03CC:  DATA 6E,67
03CE:  DATA 3D,25
03D0:  DATA 6C,75
03D2:  DATA 0D,0A
03D4:  DATA 00,00
03D6:  DATA 23,20
03D8:  DATA 69,6E
03DA:  DATA 70,75
03DC:  DATA 74,28
03DE:  DATA 50,49
03E0:  DATA 43,5F
03E2:  DATA 41,44
03E4:  DATA 44,52
03E6:  DATA 5F,4D
03E8:  DATA 53,42
03EA:  DATA 29,3D
03EC:  DATA 25,75
03EE:  DATA 0D,0A
03F0:  DATA 00,00
03F2:  DATA 23,20
03F4:  DATA 69,6E
03F6:  DATA 70,75
03F8:  DATA 74,28
03FA:  DATA 50,49
03FC:  DATA 43,5F
03FE:  DATA 41,44
0400:  DATA 44,52
0402:  DATA 5F,4C
0404:  DATA 53,42
0406:  DATA 29,3D
0408:  DATA 25,75
040A:  DATA 0D,0A
040C:  DATA 00,00
*
046E:  TBLRD*+
0470:  MOVFF  FF6,71
0474:  MOVFF  FF7,72
0478:  MOVF   FF5,W
047A:  BTFSS  F9E.4
047C:  BRA    047A
047E:  MOVWF  FAD
0480:  MOVFF  71,FF6
0484:  MOVFF  72,FF7
0488:  DECFSZ x70,F
048A:  BRA    046E
048C:  RETURN 0
048E:  TBLRD*+
0490:  MOVF   FF5,F
0492:  BZ    04AE
0494:  MOVFF  FF6,6F
0498:  MOVFF  FF7,70
049C:  MOVF   FF5,W
049E:  BTFSS  F9E.4
04A0:  BRA    049E
04A2:  MOVWF  FAD
04A4:  MOVFF  6F,FF6
04A8:  MOVFF  70,FF7
04AC:  BRA    048E
04AE:  GOTO   0B8A (RETURN)
*
0746:  MOVF   x77,W
0748:  CLRF   01
074A:  SUBWF  x76,W
074C:  BC    0754
074E:  MOVFF  76,00
0752:  BRA    076C
0754:  CLRF   00
0756:  MOVLW  08
0758:  MOVWF  x78
075A:  RLCF   x76,F
075C:  RLCF   00,F
075E:  MOVF   x77,W
0760:  SUBWF  00,W
0762:  BTFSC  FD8.0
0764:  MOVWF  00
0766:  RLCF   01,F
0768:  DECFSZ x78,F
076A:  BRA    075A
076C:  RETURN 0
076E:  MOVLW  20
0770:  BTFSS  x71.4
0772:  MOVLW  30
0774:  MOVWF  x72
0776:  MOVFF  70,00
077A:  BTFSS  x70.7
077C:  BRA    078E
077E:  COMF   00,F
0780:  INCF   00,F
0782:  MOVFF  00,70
0786:  MOVLW  2D
0788:  MOVWF  x72
078A:  BSF    x71.7
078C:  BSF    x71.0
078E:  MOVF   01,W
0790:  MOVFF  70,76
0794:  MOVLW  64
0796:  MOVWF  x77
0798:  RCALL  0746
079A:  MOVFF  00,70
079E:  MOVLW  30
07A0:  ADDWF  01,W
07A2:  MOVWF  x73
07A4:  MOVFF  70,76
07A8:  MOVLW  0A
07AA:  MOVWF  x77
07AC:  RCALL  0746
07AE:  MOVLW  30
07B0:  ADDWF  00,W
07B2:  MOVWF  x75
07B4:  MOVLW  30
07B6:  ADDWF  01,W
07B8:  MOVWF  x74
07BA:  MOVFF  72,00
07BE:  MOVLW  30
07C0:  SUBWF  x73,W
07C2:  BZ    07CC
07C4:  BSF    x71.1
07C6:  BTFSC  x71.7
07C8:  BSF    x71.2
07CA:  BRA    07F0
07CC:  MOVFF  72,73
07D0:  MOVLW  20
07D2:  MOVWF  x72
07D4:  MOVLW  30
07D6:  SUBWF  x74,W
07D8:  BZ    07E2
07DA:  BSF    x71.0
07DC:  BTFSC  x71.7
07DE:  BSF    x71.1
07E0:  BRA    07F0
07E2:  BTFSS  FD8.2
07E4:  BSF    x71.0
07E6:  BNZ   07F0
07E8:  MOVFF  73,74
07EC:  MOVLW  20
07EE:  MOVWF  x73
07F0:  BTFSC  x71.2
07F2:  BRA    07FE
07F4:  BTFSC  x71.1
07F6:  BRA    0806
07F8:  BTFSC  x71.0
07FA:  BRA    080E
07FC:  BRA    0816
07FE:  MOVF   x72,W
0800:  BTFSS  F9E.4
0802:  BRA    0800
0804:  MOVWF  FAD
0806:  MOVF   x73,W
0808:  BTFSS  F9E.4
080A:  BRA    0808
080C:  MOVWF  FAD
080E:  MOVF   x74,W
0810:  BTFSS  F9E.4
0812:  BRA    0810
0814:  MOVWF  FAD
0816:  MOVF   x75,W
0818:  BTFSS  F9E.4
081A:  BRA    0818
081C:  MOVWF  FAD
081E:  GOTO   0BE4 (RETURN)
0822:  BTFSC  x70.7
0824:  BRA    0846
0826:  MOVLW  0F
0828:  MOVWF  00
082A:  SWAPF  x6F,W
082C:  ANDWF  00,F
082E:  MOVLW  0A
0830:  SUBWF  00,W
0832:  BC    083A
0834:  MOVLW  30
0836:  ADDWF  00,F
0838:  BRA    083E
083A:  MOVF   x70,W
083C:  ADDWF  00,F
083E:  MOVF   00,W
0840:  BTFSS  F9E.4
0842:  BRA    0840
0844:  MOVWF  FAD
0846:  MOVLW  0F
0848:  ANDWF  x6F,F
084A:  MOVLW  0A
084C:  SUBWF  x6F,W
084E:  BC    0854
0850:  MOVLW  30
0852:  BRA    0858
0854:  BCF    x70.7
0856:  MOVF   x70,W
0858:  ADDWF  x6F,F
085A:  MOVF   x6F,W
085C:  BTFSS  F9E.4
085E:  BRA    085C
0860:  MOVWF  FAD
0862:  RETURN 0
0864:  MOVFF  FEA,77
0868:  MOVFF  FE9,76
086C:  SWAPF  x70,W
086E:  IORLW  F0
0870:  MOVWF  x72
0872:  ADDWF  x72,F
0874:  ADDLW  E2
0876:  MOVWF  x73
0878:  ADDLW  32
087A:  MOVWF  x75
087C:  MOVF   x70,W
087E:  ANDLW  0F
0880:  ADDWF  x73,F
0882:  ADDWF  x73,F
0884:  ADDWF  x75,F
0886:  ADDLW  E9
0888:  MOVWF  x74
088A:  ADDWF  x74,F
088C:  ADDWF  x74,F
088E:  SWAPF  x6F,W
0890:  ANDLW  0F
0892:  ADDWF  x74,F
0894:  ADDWF  x75,F
0896:  RLCF   x74,F
0898:  RLCF   x75,F
089A:  COMF   x75,F
089C:  RLCF   x75,F
089E:  MOVF   x6F,W
08A0:  ANDLW  0F
08A2:  ADDWF  x75,F
08A4:  RLCF   x72,F
08A6:  MOVLW  07
08A8:  MOVWF  x71
08AA:  MOVLW  0A
08AC:  DECF   x74,F
08AE:  ADDWF  x75,F
08B0:  BNC   08AC
08B2:  DECF   x73,F
08B4:  ADDWF  x74,F
08B6:  BNC   08B2
08B8:  DECF   x72,F
08BA:  ADDWF  x73,F
08BC:  BNC   08B8
08BE:  DECF   x71,F
08C0:  ADDWF  x72,F
08C2:  BNC   08BE
08C4:  CLRF   FEA
08C6:  MOVLW  71
08C8:  MOVWF  FE9
08CA:  MOVLW  07
08CC:  ANDWF  x76,W
08CE:  BCF    x76.6
08D0:  ADDWF  FE9,F
08D2:  MOVLW  00
08D4:  ADDWFC FEA,F
08D6:  MOVF   FE9,W
08D8:  SUBLW  75
08DA:  BNZ   08E2
08DC:  MOVF   FEA,F
08DE:  BNZ   08E2
08E0:  BSF    x76.6
08E2:  MOVF   FEF,W
08E4:  MOVWF  00
08E6:  BNZ   08F8
08E8:  BTFSC  x76.6
08EA:  BRA    08F8
08EC:  BTFSC  x76.4
08EE:  BRA    0908
08F0:  BTFSC  x76.3
08F2:  BRA    08F8
08F4:  MOVLW  20
08F6:  BRA    08FE
08F8:  BSF    x76.3
08FA:  BCF    x76.4
08FC:  MOVLW  30
08FE:  ADDWF  00,F
0900:  MOVF   00,W
0902:  BTFSS  F9E.4
0904:  BRA    0902
0906:  MOVWF  FAD
0908:  MOVF   FEE,W
090A:  BTFSS  x76.6
090C:  BRA    08D6
090E:  RETURN 0
0910:  BTFSC  FD8.1
0912:  BRA    091A
0914:  CLRF   FEA
0916:  MOVLW  83
0918:  MOVWF  FE9
091A:  CLRF   00
091C:  CLRF   01
091E:  CLRF   02
0920:  CLRF   03
0922:  CLRF   x83
0924:  CLRF   x84
0926:  CLRF   x85
0928:  CLRF   x86
092A:  MOVF   x82,W
092C:  IORWF  x81,W
092E:  IORWF  x80,W
0930:  IORWF  x7F,W
0932:  BZ    098C
0934:  MOVLW  20
0936:  MOVWF  x87
0938:  BCF    FD8.0
093A:  RLCF   x7B,F
093C:  RLCF   x7C,F
093E:  RLCF   x7D,F
0940:  RLCF   x7E,F
0942:  RLCF   x83,F
0944:  RLCF   x84,F
0946:  RLCF   x85,F
0948:  RLCF   x86,F
094A:  MOVF   x82,W
094C:  SUBWF  x86,W
094E:  BNZ   0960
0950:  MOVF   x81,W
0952:  SUBWF  x85,W
0954:  BNZ   0960
0956:  MOVF   x80,W
0958:  SUBWF  x84,W
095A:  BNZ   0960
095C:  MOVF   x7F,W
095E:  SUBWF  x83,W
0960:  BNC   0980
0962:  MOVF   x7F,W
0964:  SUBWF  x83,F
0966:  MOVF   x80,W
0968:  BTFSS  FD8.0
096A:  INCFSZ x80,W
096C:  SUBWF  x84,F
096E:  MOVF   x81,W
0970:  BTFSS  FD8.0
0972:  INCFSZ x81,W
0974:  SUBWF  x85,F
0976:  MOVF   x82,W
0978:  BTFSS  FD8.0
097A:  INCFSZ x82,W
097C:  SUBWF  x86,F
097E:  BSF    FD8.0
0980:  RLCF   00,F
0982:  RLCF   01,F
0984:  RLCF   02,F
0986:  RLCF   03,F
0988:  DECFSZ x87,F
098A:  BRA    0938
098C:  MOVFF  83,FEF
0990:  MOVFF  84,FEC
0994:  MOVFF  85,FEC
0998:  MOVFF  86,FEC
099C:  RETURN 0
099E:  MOVF   FE9,W
09A0:  MOVWF  x73
09A2:  MOVLW  3B
09A4:  MOVWF  x7A
09A6:  MOVLW  9A
09A8:  MOVWF  x79
09AA:  MOVLW  CA
09AC:  MOVWF  x78
09AE:  CLRF   x77
09B0:  MOVLW  0A
09B2:  MOVWF  x75
09B4:  BSF    FD8.1
09B6:  CLRF   FEA
09B8:  MOVLW  6F
09BA:  MOVWF  FE9
09BC:  MOVFF  72,7E
09C0:  MOVFF  71,7D
09C4:  MOVFF  70,7C
09C8:  MOVFF  6F,7B
09CC:  MOVFF  7A,82
09D0:  MOVFF  79,81
09D4:  MOVFF  78,80
09D8:  MOVFF  77,7F
09DC:  RCALL  0910
09DE:  MOVF   01,W
09E0:  MOVF   00,F
09E2:  BNZ   0A02
09E4:  MOVF   x75,W
09E6:  XORLW  01
09E8:  BZ    0A02
09EA:  MOVF   x73,W
09EC:  BZ    0A04
09EE:  ANDLW  0F
09F0:  SUBWF  x75,W
09F2:  BZ    09F6
09F4:  BC    0A10
09F6:  BTFSC  x73.7
09F8:  BRA    0A10
09FA:  BTFSC  x73.6
09FC:  BRA    0A04
09FE:  MOVLW  20
0A00:  BRA    0A06
0A02:  CLRF   x73
0A04:  MOVLW  30
0A06:  ADDWF  00,F
0A08:  MOVF   00,W
0A0A:  BTFSS  F9E.4
0A0C:  BRA    0A0A
0A0E:  MOVWF  FAD
0A10:  BCF    FD8.1
0A12:  MOVFF  7A,7E
0A16:  MOVFF  79,7D
0A1A:  MOVFF  78,7C
0A1E:  MOVFF  77,7B
0A22:  CLRF   x82
0A24:  CLRF   x81
0A26:  CLRF   x80
0A28:  MOVLW  0A
0A2A:  MOVWF  x7F
0A2C:  RCALL  0910
0A2E:  MOVFF  03,7A
0A32:  MOVFF  02,79
0A36:  MOVFF  01,78
0A3A:  MOVFF  00,77
0A3E:  DECFSZ x75,F
0A40:  BRA    09B4
0A42:  RETURN 0
0A44:  MOVF   01,W
0A46:  MOVFF  70,76
0A4A:  MOVLW  64
0A4C:  MOVWF  x77
0A4E:  RCALL  0746
0A50:  MOVFF  00,70
0A54:  MOVF   01,W
0A56:  MOVLW  30
0A58:  BNZ   0A68
0A5A:  BTFSS  x71.1
0A5C:  BRA    0A78
0A5E:  BTFSC  x71.3
0A60:  BRA    0A78
0A62:  BTFSC  x71.4
0A64:  MOVLW  20
0A66:  BRA    0A6E
0A68:  BCF    x71.3
0A6A:  BCF    x71.4
0A6C:  BSF    x71.0
0A6E:  ADDWF  01,F
0A70:  MOVF   01,W
0A72:  BTFSS  F9E.4
0A74:  BRA    0A72
0A76:  MOVWF  FAD
0A78:  MOVFF  70,76
0A7C:  MOVLW  0A
0A7E:  MOVWF  x77
0A80:  RCALL  0746
0A82:  MOVFF  00,70
0A86:  MOVF   01,W
0A88:  MOVLW  30
0A8A:  BNZ   0A98
0A8C:  BTFSC  x71.3
0A8E:  BRA    0AA2
0A90:  BTFSS  x71.0
0A92:  BRA    0AA2
0A94:  BTFSC  x71.4
0A96:  MOVLW  20
0A98:  ADDWF  01,F
0A9A:  MOVF   01,W
0A9C:  BTFSS  F9E.4
0A9E:  BRA    0A9C
0AA0:  MOVWF  FAD
0AA2:  MOVLW  30
0AA4:  ADDWF  x70,F
0AA6:  MOVF   x70,W
0AA8:  BTFSS  F9E.4
0AAA:  BRA    0AA8
0AAC:  MOVWF  FAD
0AAE:  RETURN 0
.................... 
.................... #list
.................... 
.................... #device ADC=10
.................... #device *=16
.................... #use delay(clock=16MHz)
*
0446:  CLRF   FEA
0448:  MOVLW  70
044A:  MOVWF  FE9
044C:  MOVF   FEF,W
044E:  BZ    046C
0450:  MOVLW  05
0452:  MOVWF  01
0454:  CLRF   00
0456:  DECFSZ 00,F
0458:  BRA    0456
045A:  DECFSZ 01,F
045C:  BRA    0454
045E:  MOVLW  2E
0460:  MOVWF  00
0462:  DECFSZ 00,F
0464:  BRA    0462
0466:  BRA    0468
0468:  DECFSZ FEF,F
046A:  BRA    0450
046C:  RETURN 0
.................... 
.................... /* hardware I2C port is slave and is connected to DCSWC bus */
.................... #use i2c(stream=STREAM_SLAVE,SLAVE, I2C1, address=0x34, FORCE_HW)
*
01D0:  MOVF   FC9,W
01D2:  MOVFF  8B,FC9
01D6:  BSF    FC6.4
01D8:  BCF    F9E.3
01DA:  BTFSC  FC7.0
01DC:  BRA    01DA
01DE:  CLRF   01
01E0:  BTFSS  FC5.6
01E2:  INCF   01,F
01E4:  RETURN 0
.................... /* Linux / i2cdetect will use the CCS address >>1. So 0x34 becomes 0x1a */
.................... 
.................... 
.................... 
.................... #fuses HS
.................... #fuses NOPLLEN
.................... #fuses NOFCMEN
.................... #fuses NOIESO
.................... #fuses PUT
.................... #fuses BROWNOUT
.................... #fuses WDT4096
.................... #fuses NOHFOFST
.................... #fuses NOMCLR
.................... #fuses STVREN
.................... #fuses NOLVP
.................... #fuses NOXINST
.................... #fuses NODEBUG
.................... #fuses NOPROTECT
.................... #fuses NOWRT
.................... #fuses NOWRTC 
.................... #fuses NOWRTB
.................... #fuses NOWRTD
.................... #fuses NOEBTR
.................... #fuses NOEBTRB
.................... 
.................... #use standard_io(ALL)
.................... 
.................... #use rs232(UART1,stream=STREAM_FTDI,baud=9600,errors)	
*
070E:  BTFSS  F9E.5
0710:  BRA    070E
0712:  MOVFF  FAB,19
0716:  MOVFF  FAE,01
071A:  BTFSS  19.1
071C:  BRA    0722
071E:  BCF    FAB.4
0720:  BSF    FAB.4
0722:  GOTO   0BC6 (RETURN)
.................... 
.................... /* program config CRC of 0 and a serial_prefix of 'A' ... that will trigger a write default on first boot */
.................... #ROM 0xF00000 = { 0x00, 0x00, 0x40, 0x00 }
.................... 
.................... 
.................... 
.................... #define COUNT_B              PIN_C5
.................... #define COUNT_A              PIN_C4
.................... #define LED_A                PIN_C3
.................... #define PIC_ADDR_MSB         PIN_C6
.................... #define PIC_ADDR_LSB         PIN_C7
.................... #define SER_TO_PC            PIN_B7
.................... 
.................... #define INA_ALERT            PIN_A2
.................... #define I2C_SW_SDA           PIN_C0
.................... #define I2C_SW_SCL           PIN_C1
.................... #define TP2                  PIN_C2
.................... #define I2C_SDA              PIN_B4
.................... #define SER_FROM_PC          PIN_B5
.................... #define I2C_SCL              PIN_B6
.................... 
.................... 
.................... /* software I2C port is maser and is connected to two INA228A */
.................... #use i2c(stream=STREAM_MASTER, MASTER, FAST, FORCE_SW, scl=I2C_SW_SCL, sda=I2C_SW_SDA)
*
04B2:  MOVLW  08
04B4:  MOVWF  01
04B6:  NOP   
04B8:  BCF    F8B.1
04BA:  BCF    F94.1
04BC:  NOP   
04BE:  RLCF   x76,F
04C0:  BCF    F8B.0
04C2:  BTFSC  FD8.0
04C4:  BSF    F94.0
04C6:  BTFSS  FD8.0
04C8:  BCF    F94.0
04CA:  BSF    F94.1
04CC:  BTFSS  F82.1
04CE:  BRA    04CC
04D0:  DECFSZ 01,F
04D2:  BRA    04B6
04D4:  NOP   
04D6:  BCF    F8B.1
04D8:  BCF    F94.1
04DA:  NOP   
04DC:  BSF    F94.0
04DE:  NOP   
04E0:  NOP   
04E2:  BSF    F94.1
04E4:  BTFSS  F82.1
04E6:  BRA    04E4
04E8:  CLRF   01
04EA:  NOP   
04EC:  BTFSC  F82.0
04EE:  BSF    01.0
04F0:  BCF    F8B.1
04F2:  BCF    F94.1
04F4:  BCF    F8B.0
04F6:  BCF    F94.0
04F8:  RETURN 0
04FA:  MOVLW  08
04FC:  MOVWF  x78
04FE:  MOVFF  00,79
0502:  BSF    F94.0
0504:  NOP   
0506:  BSF    F94.1
0508:  BTFSS  F82.1
050A:  BRA    0508
050C:  BTFSC  F82.0
050E:  BSF    FD8.0
0510:  BTFSS  F82.0
0512:  BCF    FD8.0
0514:  RLCF   01,F
0516:  NOP   
0518:  BCF    F94.1
051A:  BCF    F8B.1
051C:  DECFSZ x78,F
051E:  BRA    0502
0520:  BSF    F94.0
0522:  NOP   
0524:  BCF    F8B.0
0526:  MOVF   x79,W
0528:  BTFSS  FD8.2
052A:  BCF    F94.0
052C:  NOP   
052E:  BSF    F94.1
0530:  BTFSS  F82.1
0532:  BRA    0530
0534:  NOP   
0536:  BCF    F8B.1
0538:  BCF    F94.1
053A:  NOP   
053C:  BCF    F8B.0
053E:  BCF    F94.0
0540:  RETURN 0
.................... 
.................... 
.................... 
.................... #define INA228_A_ADDR      0x80
.................... #define INA228_B_ADDR      0x9a
.................... 
.................... 
.................... 
.................... 
.................... typedef struct {
.................... 	int8 serial_prefix;
.................... 	int16 serial_number;
.................... 	int16 startup_power_on_delay;
.................... } struct_config;
.................... 
.................... 
.................... 
.................... typedef struct {
.................... 	int32 vbus_a, vshunt_a;
.................... 	int32 vbus_b, vshunt_b;
.................... 
.................... 	int16 count_a_last_second, count_b_last_second;
.................... 
.................... 	int32 count_a_long;
.................... 	int32 count_b_long;
.................... 	int32 count_seconds_long;
.................... 
.................... 	int16 dietemp_a;
.................... 	int16 dietemp_b;
.................... } struct_current;
.................... 
.................... typedef struct {
.................... 	/* action flags */
.................... 	int1 now_millisecond;
.................... 
.................... 	int1 now_ina;    // query ina registers
.................... 
.................... 	/* timers */
.................... 	int8 led_on_a;
.................... } struct_time_keep;
.................... 
.................... /* global structures */
.................... struct_current current={0};
.................... struct_current next={0};
.................... struct_time_keep timers={0};
.................... 
.................... #include "ina228.c"
.................... #define INA228_REG_CONFIG       0x00  // 16 bits, configuration
.................... #define INA228_REG_ADC_CONFIG   0x01  // 16 bits, ADC configuration
.................... #define INA228_REG_SHUNT_CAL    0x02  // 16 bits, shunt calibration
.................... #define INA228_REG_SHUNT_TEMPCO 0x03  // 16 bits, shunt temperature coefficient
.................... #define INA228_REG_VSHUNT       0x04  // 24 bits, shunt voltage measurement
.................... #define INA228_REG_VBUS         0x05  // 24 bits, bus voltage measurement
.................... #define INA228_REG_DIETEMP      0x06  // 16 bits, temperature measurement
.................... #define INA228_REG_CURRENT      0x07  // 24 bits, current result
.................... #define INA228_REG_POWER        0x08  // 24 bits, power result 
.................... #define INA228_REG_ENERGY       0x09  // 40 bits, energy result
.................... #define INA228_REG_CHARGE       0x0a  // 40 bits, charge result
.................... #define INA228_REG_DIAG_ALRT    0x0b  // 16 bits, diagnostic flags and alert
.................... #define INA228_REG_SOVL         0x0c  // 16 bits, shunt overvoltage threshold
.................... #define INA228_REG_SUVL         0x0d  // 16 bits, shunt undervoltage threshold
.................... #define INA228_REG_BOVL         0x0e  // 16 bits, bus overvoltage threshold
.................... #define INA228_REG_BUVL         0x0f  // 16 bits, bus undervoltage threshold
.................... #define INA228_REG_TEMP_LIMIT   0x10  // 16 bits, temperature over-limit threshold
.................... #define INA228_REG_PWR_LIMIT    0x11  // 16 bits, power over-limit threshold
.................... #define INA228_REG_MFG_ID       0x3e  // 16 bits, manufacturer ID
.................... #define INA228_REG_DEVICE_ID    0x3f  // 16 bits, device ID
.................... 
.................... #define INA228_I2C_WRITE        0x00
.................... #define INA228_I2C_READ         0x01 
.................... 
.................... 
.................... int16 ina228_read16(int8 i2c_address, int8 regaddr) {
.................... 	int16 data;
.................... 
.................... 	i2c_start(STREAM_MASTER);
*
05E0:  BSF    F94.0
05E2:  NOP   
05E4:  BSF    F94.1
05E6:  NOP   
05E8:  BCF    F8B.0
05EA:  BCF    F94.0
05EC:  NOP   
05EE:  BCF    F8B.1
05F0:  BCF    F94.1
.................... 	delay_us(15);
05F2:  MOVLW  13
05F4:  MOVWF  00
05F6:  DECFSZ 00,F
05F8:  BRA    05F6
05FA:  BRA    05FC
.................... 	i2c_write(STREAM_MASTER,i2c_address);
05FC:  MOVFF  6F,76
0600:  RCALL  04B2
.................... 	i2c_write(STREAM_MASTER,regaddr);
0602:  MOVFF  70,76
0606:  RCALL  04B2
.................... 	i2c_start(STREAM_MASTER);
0608:  BSF    F94.0
060A:  NOP   
060C:  BSF    F94.1
060E:  NOP   
0610:  BTFSS  F82.1
0612:  BRA    0610
0614:  BCF    F8B.0
0616:  BCF    F94.0
0618:  NOP   
061A:  BCF    F8B.1
061C:  BCF    F94.1
.................... 	delay_us(15);
061E:  MOVLW  13
0620:  MOVWF  00
0622:  DECFSZ 00,F
0624:  BRA    0622
0626:  BRA    0628
.................... 	i2c_write(STREAM_MASTER,i2c_address | INA228_I2C_READ);  // read cycle
0628:  MOVF   x6F,W
062A:  IORLW  01
062C:  MOVWF  x73
062E:  MOVWF  x76
0630:  RCALL  04B2
.................... 	data=make16(i2c_read(STREAM_MASTER,1),i2c_read(STREAM_MASTER,0));                                 
0632:  MOVLW  01
0634:  MOVWF  00
0636:  RCALL  04FA
0638:  MOVFF  01,73
063C:  CLRF   00
063E:  RCALL  04FA
0640:  MOVFF  73,72
0644:  MOVFF  01,71
.................... 	i2c_stop(STREAM_MASTER);
0648:  BCF    F94.0
064A:  NOP   
064C:  BSF    F94.1
064E:  BTFSS  F82.1
0650:  BRA    064E
0652:  NOP   
0654:  BRA    0656
0656:  NOP   
0658:  BSF    F94.0
065A:  NOP   
.................... 
.................... 	return data;
065C:  MOVFF  71,01
0660:  MOVFF  72,02
0664:  RETURN 0
.................... }
.................... 
.................... int32 ina228_read24(int8 i2c_address, int8 regaddr) {
.................... 	int32 data;
.................... 
.................... 	i2c_start(STREAM_MASTER);
*
0542:  BSF    F94.0
0544:  NOP   
0546:  BSF    F94.1
0548:  NOP   
054A:  BCF    F8B.0
054C:  BCF    F94.0
054E:  NOP   
0550:  BCF    F8B.1
0552:  BCF    F94.1
.................... 	delay_us(15);
0554:  MOVLW  13
0556:  MOVWF  00
0558:  DECFSZ 00,F
055A:  BRA    0558
055C:  BRA    055E
.................... 	i2c_write(STREAM_MASTER,i2c_address);
055E:  MOVFF  6F,76
0562:  RCALL  04B2
.................... 	i2c_write(STREAM_MASTER,regaddr);
0564:  MOVFF  70,76
0568:  RCALL  04B2
.................... 	i2c_start(STREAM_MASTER);
056A:  BSF    F94.0
056C:  NOP   
056E:  BSF    F94.1
0570:  NOP   
0572:  BTFSS  F82.1
0574:  BRA    0572
0576:  BCF    F8B.0
0578:  BCF    F94.0
057A:  NOP   
057C:  BCF    F8B.1
057E:  BCF    F94.1
.................... 	delay_us(15);
0580:  MOVLW  13
0582:  MOVWF  00
0584:  DECFSZ 00,F
0586:  BRA    0584
0588:  BRA    058A
.................... 	i2c_write(STREAM_MASTER,i2c_address | INA228_I2C_READ);  // read cycle
058A:  MOVF   x6F,W
058C:  IORLW  01
058E:  MOVWF  x75
0590:  MOVWF  x76
0592:  RCALL  04B2
.................... 	data=make32(0,i2c_read(STREAM_MASTER,1),i2c_read(STREAM_MASTER,1),i2c_read(STREAM_MASTER,0));
0594:  MOVLW  01
0596:  MOVWF  00
0598:  RCALL  04FA
059A:  MOVFF  01,75
059E:  MOVLW  01
05A0:  MOVWF  00
05A2:  RCALL  04FA
05A4:  MOVFF  01,76
05A8:  CLRF   00
05AA:  RCALL  04FA
05AC:  CLRF   x74
05AE:  MOVFF  75,73
05B2:  MOVFF  76,72
05B6:  MOVFF  01,71
.................... 	i2c_stop(STREAM_MASTER);
05BA:  BCF    F94.0
05BC:  NOP   
05BE:  BSF    F94.1
05C0:  BTFSS  F82.1
05C2:  BRA    05C0
05C4:  NOP   
05C6:  BRA    05C8
05C8:  NOP   
05CA:  BSF    F94.0
05CC:  NOP   
.................... 
.................... 	return data;
05CE:  MOVFF  71,00
05D2:  MOVFF  72,01
05D6:  MOVFF  73,02
05DA:  MOVFF  74,03
05DE:  RETURN 0
.................... }
.................... 
.................... void ina228_write16(int8 i2c_address, int8 regaddr, int16 value) {
.................... 	i2c_start(STREAM_MASTER);
.................... 	delay_us(15);                                                 
.................... 	i2c_write(STREAM_MASTER,i2c_address); // write cycle                       
.................... 	i2c_write(STREAM_MASTER,regaddr);  // write cycle         
.................... 	i2c_write(STREAM_MASTER,make8(value,1));
.................... 	i2c_write(STREAM_MASTER,make8(value,0));
.................... 	i2c_stop(STREAM_MASTER);
.................... }
.................... 
.................... void ina228_init(int8 i2c_address) {
.................... 	ina228_write16(i2c_address,INA228_REG_CONFIG,0b1000000000000000);
.................... }
.................... 
.................... #include "i2c_handler_dcswc_module_voltage_current_counter.c"
.................... #include "registers_dcswc_module_voltage_current_counter.h"
.................... /* 32 bit INA228 bus and shunt voltages */
.................... #define I2C_REG_VBUS_A_MSW                    0
.................... #define I2C_REG_VBUS_A_LSW                    1
.................... #define I2C_REG_VSHUNT_A_MSW                  2
.................... #define I2C_REG_VSHUNT_A_LSW                  3
.................... 
.................... #define I2C_REG_VBUS_B_MSW                    4
.................... #define I2C_REG_VBUS_B_LSW                    5
.................... #define I2C_REG_VSHUNT_B_MSW                  6
.................... #define I2C_REG_VSHUNT_B_LSW                  7
.................... 
.................... /* 16 bit count of last (not current) second */
.................... #define I2C_REG_COUNT_A_LAST_SECOND           8
.................... #define I2C_REG_COUNT_B_LAST_SECOND           9
.................... 
.................... /* 32 bit count since reset */
.................... #define I2C_REG_COUNT_A_LONG_MSW              10
.................... #define I2C_REG_COUNT_A_LONG_LSW              11
.................... #define I2C_REG_COUNT_B_LONG_MSW              12
.................... #define I2C_REG_COUNT_B_LONG_LSW              13
.................... 
.................... /* 32 bit seconds since count reset */
.................... #define I2C_REG_COUNT_LONG_SECONDS_MSW        14
.................... #define I2C_REG_COUNT_LONG_SECONDS_LSW        15
.................... 
.................... /* 16 bit INA228 die temperatures */
.................... #define I2C_REG_DIETEMP_A                     16
.................... #define I2C_REG_DIETEMP_B                     17
.................... 
.................... 
.................... void write_i2c(int8 address, int16 value) {
.................... 	switch ( address ) {
*
01BA:  MOVF   x8C,W
.................... #if 0
.................... 		case I2C_REG_LED_A: 
.................... 			timers.led_on_a=make8(value,0);
.................... 			break;
.................... 		case I2C_REG_LED_B: 
.................... 			timers.led_on_b=make8(value,0);
.................... 			break;
.................... 		case I2C_REG_TIME_WATCHDOG_WRITE_SECONDS:
.................... 			timers.write_watchdog_seconds=0;
.................... 			break;
.................... 		case I2C_REG_COMMAND_OFF:
.................... 			timers.command_off_seconds=value;
.................... 			break;
.................... 		case I2C_REG_CONFIG_SERIAL_PREFIX: 
.................... 			if ( current.factory_unlocked && value >= 'A' && value <='Z' ) 
.................... 				config.serial_prefix=value;
.................... 			break;
.................... 		case I2C_REG_CONFIG_SERIAL_NUMBER:
.................... 			if (  current.factory_unlocked  ) {
.................... 				config.serial_number=value;
.................... 			}
.................... 			break;
.................... 		case I2C_REG_CONFIG_PARAM_WRITE:
.................... 			if ( 1 == value ) {
.................... 				timers.now_write_config=1;
.................... 			} else if ( 2 == value ) {
.................... 				timers.now_reset_config=1;
.................... 			} else if ( 1802 == value ) {
.................... 				current.factory_unlocked =1;
.................... 			} else if ( 65535 == value ) {
.................... 				reset_cpu();
.................... 			}
.................... 			break;
.................... 		case I2C_REG_CONFIG_TICKS_ADC:
.................... 			config.adc_sample_ticks=value;
.................... 			break;
.................... 		case I2C_REG_CONFIG_STARTUP_POWER_ON_DELAY:
.................... 			config.startup_power_on_delay=value;
.................... 			break;
.................... 		case I2C_REG_CONFIG_COMMAND_OFF_HOLD_TIME:
.................... 			config.command_off_hold_time=value;
.................... 			break;
.................... 		case I2C_REG_CONFIG_READ_WATCHDOG_OFF_THRESHOLD:
.................... 			config.read_watchdog_off_threshold=value;
.................... 			break;
.................... 		case I2C_REG_CONFIG_READ_WATCHDOG_OFF_HOLD_TIME:
.................... 			config.read_watchdog_off_hold_time=value;
.................... 			break;
.................... 		case I2C_REG_CONFIG_WRITE_WATCHDOG_OFF_THRESHOLD:
.................... 			config.write_watchdog_off_threshold=value;
.................... 			break;
.................... 		case I2C_REG_CONFIG_WRITE_WATCHDOG_OFF_HOLD_TIME:
.................... 			config.write_watchdog_off_hold_time=value;
.................... 			break;
.................... 		case I2C_REG_CONFIG_LVD_DISCONNECT_VOLTAGE:
.................... 			config.lvd_disconnect_adc=value;
.................... 			break;
.................... 		case I2C_REG_CONFIG_LVD_DISCONNECT_DELAY:
.................... 			config.lvd_disconnect_delay=value;
.................... 			break;
.................... 		case I2C_REG_CONFIG_LVD_RECONNECT_VOLTAGE:
.................... 			config.lvd_reconnect_adc=value;
.................... 			break;
.................... 		case I2C_REG_CONFIG_HVD_DISCONNECT_VOLTAGE:
.................... 			config.hvd_disconnect_adc=value;
.................... 			break;
.................... 		case I2C_REG_CONFIG_HVD_DISCONNECT_DELAY:
.................... 			config.hvd_disconnect_delay=value;
.................... 			break;
.................... 		case I2C_REG_CONFIG_HVD_RECONNECT_VOLTAGE:
.................... 			config.hvd_reconnect_adc=value;
.................... 			break;
.................... #endif
.................... 		default:
.................... 			/* do nothing */
.................... 	}
01BC:  GOTO   0260 (RETURN)
.................... 
.................... }
.................... 
.................... 
.................... int16 map_i2c(int8 addr) {
.................... 
.................... 	timers.led_on_a=100;
01C0:  MOVLW  64
01C2:  MOVWF  x63
.................... 
.................... 
.................... 
.................... 	switch ( addr ) {
01C4:  MOVF   x8B,W
.................... #if 0
.................... 		/* analog channels */
.................... 		/* input voltage */
.................... 		case I2C_REG_VOLTAGE_INPUT_NOW: 
.................... 			return (int16) current.adc_buffer[0][current.adc_buffer_index];
.................... 		case I2C_REG_VOLTAGE_INPUT_AVG: 
.................... 			return (int16) adc_get(0);
.................... 
.................... 		/* temperature sensor */
.................... 		case I2C_REG_TEMPERATURE_BOARD_NOW: 
.................... 			return (int16) current.adc_buffer[1][current.adc_buffer_index];
.................... 		case I2C_REG_TEMPERATURE_BOARD_AVG: 
.................... 			return (int16) adc_get(1);
.................... #endif
.................... 
.................... #if 0
.................... 		/* switch channels */
.................... 		case I2C_REG_SWITCH_MAGNET_NOW: 
.................... 			return (int16) ! input(SW_MAGNET);
.................... 		case I2C_REG_SWITCH_MAGNET_LATCH: 
.................... 			return (int16) current.latch_sw_magnet;
.................... #endif
.................... 
.................... #if 0		
.................... 		/* status */
.................... 		case I2C_REG_SEQUENCE_NUMBER: 
.................... 			return (int16) current.sequence_number++;
.................... 		case I2C_REG_TIME_INTERVAL_MILLISECONDS: 
.................... 			return (int16) current.interval_milliseconds; /* milliseconds since last query */
.................... 		case I2C_REG_TIME_UPTIME_MINUTES: 
.................... 			return (int16) current.uptime_minutes; 
.................... 		case I2C_REG_TIME_WATCHDOG_READ_SECONDS: 
.................... 			return (int16) timers.read_watchdog_seconds; 
.................... 		case I2C_REG_TIME_WATCHDOG_WRITE_SECONDS: 
.................... 			return (int16) timers.write_watchdog_seconds;
.................... 		case I2C_REG_DEFAULT_PARAMS_WRITTEN:
.................... 			return (int16) current.default_params_written;
.................... 		case I2C_REG_COMMAND_OFF:
.................... 			return (int16) timers.command_off_seconds;
.................... 		case I2C_REG_POWER_OFF_FLAGS:
.................... 			return (int16) current.power_off_flags;
.................... 
.................... 
.................... 		/* configuration */
.................... 		case I2C_REG_CONFIG_SERIAL_PREFIX: 
.................... 			return (int16) config.serial_prefix;
.................... 		case I2C_REG_CONFIG_SERIAL_NUMBER: 
.................... 			return (int16) config.serial_number;
.................... 		case I2C_REG_CONFIG_HARDWARE_MODEL: 
.................... 			return (int16) 'P';
.................... 		case I2C_REG_CONFIG_HARDWARE_VERSION: 
.................... 			return (int16) 'Z';
.................... 		case I2C_REG_CONFIG_SOFTWARE_MODEL: 
.................... 			return (int16) 'P';
.................... 		case I2C_REG_CONFIG_SOFTWARE_VERSION: 
.................... 			return (int16) 3;
.................... 		case I2C_REG_CONFIG_SOFTWARE_YEAR:
.................... 			return (int16) current.compile_year;
.................... 		case I2C_REG_CONFIG_SOFTWARE_MONTH:
.................... 			return (int16) current.compile_month;
.................... 		case I2C_REG_CONFIG_SOFTWARE_DAY:
.................... 			return (int16) current.compile_day;
.................... 
.................... 		case I2C_REG_CONFIG_PARAM_WRITE:
.................... 			/* 1 if factory unlocked */ 
.................... 			return (int16) current.factory_unlocked; 	
.................... 		case I2C_REG_CONFIG_TICKS_ADC: 
.................... 			return (int16) config.adc_sample_ticks;
.................... 		case I2C_REG_CONFIG_STARTUP_POWER_ON_DELAY: 
.................... 			return (int16) config.startup_power_on_delay;
.................... 		case I2C_REG_CONFIG_COMMAND_OFF_HOLD_TIME:
.................... 			return (int16) config.command_off_hold_time;
.................... 		case I2C_REG_CONFIG_READ_WATCHDOG_OFF_THRESHOLD:
.................... 			return (int16) config.read_watchdog_off_threshold;
.................... 		case I2C_REG_CONFIG_READ_WATCHDOG_OFF_HOLD_TIME:
.................... 			return (int16) config.read_watchdog_off_hold_time;
.................... 		case I2C_REG_CONFIG_WRITE_WATCHDOG_OFF_THRESHOLD:
.................... 			return (int16) config.write_watchdog_off_threshold;
.................... 		case I2C_REG_CONFIG_WRITE_WATCHDOG_OFF_HOLD_TIME:
.................... 			return (int16) config.write_watchdog_off_hold_time;
.................... 		case I2C_REG_CONFIG_LVD_DISCONNECT_VOLTAGE:
.................... 			return (int16) config.lvd_disconnect_adc;
.................... 		case I2C_REG_CONFIG_LVD_DISCONNECT_DELAY:
.................... 			return (int16) config.lvd_disconnect_delay;
.................... 		case I2C_REG_CONFIG_LVD_RECONNECT_VOLTAGE:
.................... 			return (int16) config.lvd_reconnect_adc;
.................... 		case I2C_REG_CONFIG_HVD_DISCONNECT_VOLTAGE:
.................... 			return (int16) config.hvd_disconnect_adc;
.................... 		case I2C_REG_CONFIG_HVD_DISCONNECT_DELAY:
.................... 			return (int16) config.hvd_disconnect_delay;
.................... 		case I2C_REG_CONFIG_HVD_RECONNECT_VOLTAGE:
.................... 			return (int16) config.hvd_reconnect_adc;
.................... #endif
.................... 
.................... 		/* we should have range checked, and never gotten here ... or read unimplemented (future) register */
.................... 		default: return (int16) addr;
01C6:  MOVFF  8B,01
01CA:  CLRF   02
.................... 	}
01CC:  GOTO   0274 (RETURN)
.................... 
.................... }
.................... 
.................... 
.................... 
.................... #include "interrupt_dcswc_module_voltage_current_counter.c"
.................... #int_timer2
.................... void isr_timer2() {
.................... 	static int16 ticks=0;
.................... 	static short count_a_last=0;
.................... 	static short count_b_last=0;
.................... 	short count_a_now;
.................... 	short count_b_now;
.................... 
.................... 
.................... 	/* external input counting */
.................... 	count_a_now=input(COUNT_A);
*
00BA:  BSF    F94.4
00BC:  BCF    x88.0
00BE:  BTFSC  F82.4
00C0:  BSF    x88.0
.................... 	if ( 0 == count_a_now && 1 == count_a_last ) {
00C2:  BTFSC  x88.0
00C4:  BRA    00D0
00C6:  BTFSS  x66.0
00C8:  BRA    00D0
.................... 		next.count_a_last_second++;
00CA:  INCF   4E,F
00CC:  BTFSC  FD8.2
00CE:  INCF   4F,F
.................... 	}
.................... 	count_a_last=count_a_now;
00D0:  BCF    x66.0
00D2:  BTFSC  x88.0
00D4:  BSF    x66.0
.................... 
.................... 	count_b_now=input(COUNT_B);
00D6:  BSF    F94.5
00D8:  BCF    x88.1
00DA:  BTFSC  F82.5
00DC:  BSF    x88.1
.................... 	if ( 0 == count_b_now && 1 == count_b_last ) {
00DE:  BTFSC  x88.1
00E0:  BRA    00EC
00E2:  BTFSS  x66.1
00E4:  BRA    00EC
.................... 		next.count_b_last_second++;
00E6:  INCF   50,F
00E8:  BTFSC  FD8.2
00EA:  INCF   51,F
.................... 	}
.................... 	count_b_last=count_b_now;
00EC:  BCF    x66.1
00EE:  BTFSC  x88.1
00F0:  BSF    x66.1
.................... 
.................... 
.................... 	/* timing */
.................... 
.................... 	timers.now_millisecond=1;
00F2:  BSF    x62.0
.................... 
.................... 	ticks++;
00F4:  INCF   x64,F
00F6:  BTFSC  FD8.2
00F8:  INCF   x65,F
.................... 	if ( 500 == ticks ) {
00FA:  MOVF   x64,W
00FC:  SUBLW  F4
00FE:  BNZ   0108
0100:  DECFSZ x65,W
0102:  BRA    0108
.................... 		timers.now_ina=1;
0104:  BSF    x62.1
.................... 	} else if ( 1000 == ticks ) {
0106:  BRA    01B0
0108:  MOVF   x64,W
010A:  SUBLW  E8
010C:  BNZ   01B0
010E:  MOVF   x65,W
0110:  SUBLW  03
0112:  BNZ   01B0
.................... //		timers.now_strobe=1;
.................... 		output_high(TP2);
0114:  BCF    F94.2
0116:  BSF    F8B.2
.................... 
.................... 		current.vbus_a=next.vbus_a;
0118:  MOVFF  41,1D
011C:  MOVFF  40,1C
0120:  MOVFF  3F,1B
0124:  MOVFF  3E,1A
.................... 		current.vshunt_a=next.vshunt_a;
0128:  MOVFF  45,21
012C:  MOVFF  44,20
0130:  MOVFF  43,1F
0134:  MOVFF  42,1E
.................... 		current.dietemp_a=next.dietemp_a;	
0138:  MOVFF  5F,3B
013C:  MOVFF  5E,3A
.................... 
.................... 		current.vbus_b=next.vbus_b;
0140:  MOVFF  49,25
0144:  MOVFF  48,24
0148:  MOVFF  47,23
014C:  MOVFF  46,22
.................... 		current.vshunt_b=next.vshunt_b;
0150:  MOVFF  4D,29
0154:  MOVFF  4C,28
0158:  MOVFF  4B,27
015C:  MOVFF  4A,26
.................... 		current.dietemp_b=next.dietemp_b;
0160:  MOVFF  61,3D
0164:  MOVFF  60,3C
.................... 
.................... 		current.count_a_last_second=next.count_a_last_second;
0168:  MOVFF  4F,2B
016C:  MOVFF  4E,2A
.................... 
.................... 		current.count_b_last_second=next.count_b_last_second;	
0170:  MOVFF  51,2D
0174:  MOVFF  50,2C
.................... 
.................... 		current.count_a_long += current.count_a_last_second;
0178:  MOVF   2A,W
017A:  ADDWF  2E,F
017C:  MOVF   2B,W
017E:  ADDWFC 2F,F
0180:  MOVLW  00
0182:  ADDWFC 30,F
0184:  ADDWFC 31,F
.................... 		current.count_b_long += current.count_b_last_second;
0186:  MOVF   2C,W
0188:  ADDWF  32,F
018A:  MOVF   2D,W
018C:  ADDWFC 33,F
018E:  MOVLW  00
0190:  ADDWFC 34,F
0192:  ADDWFC 35,F
.................... 	
.................... 		current.count_seconds_long++;
0194:  MOVLW  01
0196:  ADDWF  36,F
0198:  BTFSC  FD8.0
019A:  INCF   37,F
019C:  BTFSC  FD8.2
019E:  INCF   38,F
01A0:  BTFSC  FD8.2
01A2:  INCF   39,F
.................... 
.................... 		/* reset our counters */
.................... 		next.count_a_last_second=0;
01A4:  CLRF   4F
01A6:  CLRF   4E
.................... 		next.count_b_last_second=0;
01A8:  CLRF   51
01AA:  CLRF   50
.................... 
.................... 		ticks=0;
01AC:  CLRF   x65
01AE:  CLRF   x64
.................... 	}
.................... 
.................... 	output_low(TP2);
01B0:  BCF    F94.2
01B2:  BCF    F8B.2
.................... }
.................... 
.................... 
.................... 
.................... #if 1
.................... 
.................... 	/*
.................... .................... 	state = i2c_isr_state();
.................... *
.................... 025A:  BTFSC  FC7.5	// if data, go to 0264
.................... 025C:  BRA    0264
.................... 
.................... 025E:  CLRF   x9D	// set i=0 
.................... 
.................... 0260:  BTFSC  FC7.2	// if read, then set high bit of i 
.................... 0262:  BSF    x9D.7
.................... 
.................... 0264:  MOVF   x9D,W // increment i and put result in state
.................... 0266:  INCF   x9D,F
.................... 0268:  MOVWF  xC7
.................... 
.................... 	x9D is static variable for state
.................... 	xC7 is returned value of state
.................... */
.................... 
.................... /*
.................... .................... 	state = i2c_isr_state();
.................... 025A:  BTFSC  FC7.5 // bit test SSPSTAT.5, skip instruction below if DATA/!ADDRESS is indicating address
.................... 025C:  BRA    0264  // goto 0264
.................... 
.................... 025E:  CLRF   x9F   // set x9F to 0
.................... 0260:  BTFSC  FC7.2 // bit test SSPSTAT.2, skip instruction below if READ/!WRITE is indicating write
.................... 0262:  BSF    x9F.7 // set the high bit of x9F
.................... 
.................... 0264:  MOVF   x9F,W	// move x9F to W register
.................... 0266:  INCF   x9F,F // increment x9F
.................... 0268:  MOVWF  x9A	// move W to x9A (ie move x9F to x9A)
.................... 
.................... that makes 9a the value of state that is used by the program and x9F as a static state variable
.................... */
.................... 
.................... 
01B4:  BCF    F9E.1
01B6:  GOTO   006C
.................... #byte SSPSTAT=GETENV("SFR:SSPSTAT")
.................... #INT_SSP
.................... void ssp_interrupt () {
.................... 	static int8 sstate;
.................... 	int8 state;
.................... 	int8 incoming;
.................... 	static int16 lastValue;
.................... 	static int8 lastMSB;
.................... 	static int8 address;
.................... 
.................... 
.................... //	state = i2c_isr_state(STREAM_SLAVE);
.................... 
.................... 
.................... 	/* 
.................... 	our implementation of i2c_isr_state() that won't overflow and switch states
.................... 
.................... 	but it will quit counting at 127 bytes. 
.................... 
.................... 	If more bytes are needed, external counting variables can be used or the size of state can be made larger
.................... 	*/
.................... 
.................... 
.................... 	if ( ! bit_test(SSPSTAT,5) ) {
*
01E6:  BTFSC  FC7.5
01E8:  BRA    01F2
.................... 		/* address */
.................... 		sstate=0;
01EA:  CLRF   x67
.................... 
.................... 		if ( bit_test(SSPSTAT,2) ) {
01EC:  BTFSS  FC7.2
01EE:  BRA    01F2
.................... 			/* set high bit if read */
.................... 			bit_set(sstate,7);
01F0:  BSF    x67.7
.................... 		}
.................... 	} else {
.................... 		/* data */
.................... 	}
.................... 
.................... 	/* state variable used below is not incremented */
.................... 	state=sstate;
01F2:  MOVFF  67,88
.................... 
.................... 	/* increment the state counter for next pass through unless it will overflow us into another state */
.................... 	if ( sstate != 0x7f && sstate != 0xff) {
01F6:  MOVF   x67,W
01F8:  SUBLW  7F
01FA:  BZ    0204
01FC:  INCFSZ x67,W
01FE:  BRA    0202
0200:  BRA    0204
.................... 		sstate++;
0202:  INCF   x67,F
.................... 	}
.................... 
.................... 	
.................... 	/* i2c_isr_state() return an 8 bit int
.................... 		0 - Address match received with R/W bit clear, perform i2c_read( ) to read the I2C address.
.................... 
.................... 		1-0x7F - Master has written data; i2c_read() will immediately return the data
.................... 
.................... 		0x80 - Address match received with R/W bit set; perform i2c_read( ) to read the I2C address,
.................... 		and use i2c_write( ) to pre-load the transmit buffer for the next transaction (next I2C read
.................... 		performed by master will read this byte).
.................... 
.................... 		0x81-0xFF - Transmission completed and acknowledged; respond with i2c_write() to pre-load
.................... 		the transmit buffer for the next transition (the next I2C read performed by master will read this
.................... 		byte).
.................... 
.................... 		Function:
.................... 		Returns the state of I2C communications in I2C slave mode after an SSP interrupt. The return
.................... 		value increments with each byte received or sent.
.................... 		If 0x00 or 0x80 is returned, an i2C_read( ) needs to be performed to read the I2C address that
.................... 		was sent (it will match the address configured by #USE I2C so this value can be ignored)
.................... 	*/
.................... 
.................... 	if ( state <= 0x80 ) {                      
0204:  MOVF   x88,W
0206:  SUBLW  80
0208:  BNC   0260
.................... 		/* I2C master is sending us data */
.................... 		if ( 0x80 == state ) {
020A:  MOVF   x88,W
020C:  SUBLW  80
020E:  BNZ   0216
.................... 			/* i2c_read(2) casues the function to read the SSPBUF without releasing the clock */
.................... 			incoming = i2c_read(STREAM_SLAVE,2);
0210:  MOVFF  FC9,89
.................... 		} else {
0214:  BRA    0222
.................... 			incoming = i2c_read(STREAM_SLAVE);
0216:  BCF    FC6.6
0218:  BTFSS  FC7.0
021A:  BRA    0218
021C:  MOVF   FC9,W
021E:  BSF    FC6.4
0220:  MOVWF  x89
.................... 		}
.................... 
.................... 		if ( 1 == state ) {      
0222:  DECFSZ x88,W
0224:  BRA    022C
.................... 			/* first byte is address */                
.................... 			address = incoming;
0226:  MOVFF  89,6B
.................... 		} else if ( state >= 2 && 0x80 != state ) {
022A:  BRA    0260
022C:  MOVF   x88,W
022E:  SUBLW  01
0230:  BC    0260
0232:  MOVF   x88,W
0234:  SUBLW  80
0236:  BZ    0260
.................... 			/* received byte is data */
.................... 		
.................... 			/* save MSB and we'll process it on next */
.................... 			if ( 2 == state ) {
0238:  MOVF   x88,W
023A:  SUBLW  02
023C:  BNZ   0244
.................... 				lastMSB=incoming;
023E:  MOVFF  89,6A
.................... 			} else if ( 3 == state ) {
0242:  BRA    0260
0244:  MOVF   x88,W
0246:  SUBLW  03
0248:  BNZ   0260
.................... 				/* 16 bit value made of previous byte and this byte */
.................... 				write_i2c(address,make16(lastMSB,incoming));
024A:  MOVFF  6A,8B
024E:  MOVFF  89,8A
0252:  MOVFF  6B,8C
0256:  MOVFF  6A,8E
025A:  MOVFF  89,8D
025E:  BRA    01BA
.................... 			}
.................... 		}
.................... 	}
.................... 
.................... 
.................... 	if ( state >= 0x80 ) {
0260:  MOVF   x88,W
0262:  SUBLW  7F
0264:  BC    0294
.................... 		/* I2C master is requesting data from us */
.................... 
.................... 		if ( ! bit_test(address,0) ) {
0266:  BTFSC  x6B.0
0268:  BRA    0288
.................... 			/* read 16 bit register (register address half of I2C address) on even address */
.................... 			lastValue=map_i2c(address>>1);
026A:  BCF    FD8.0
026C:  RRCF   x6B,W
026E:  MOVWF  x8A
0270:  MOVWF  x8B
0272:  BRA    01C0
0274:  MOVFF  02,69
0278:  MOVFF  01,68
.................... 
.................... 			/* send the MSB */
.................... 			i2c_write(STREAM_SLAVE,make8(lastValue,1));
027C:  MOVFF  69,8A
0280:  MOVFF  69,8B
0284:  RCALL  01D0
.................... 		} else {
0286:  BRA    0292
.................... 			/* send LSB of 16 bit register on odd address */
.................... 			i2c_write(STREAM_SLAVE,make8(lastValue,0));
0288:  MOVFF  68,8A
028C:  MOVFF  68,8B
0290:  RCALL  01D0
.................... 		}
.................... 
.................... 		address++;
0292:  INCF   x6B,F
.................... 	}
.................... 
.................... 	/* reset watchdog timer */
.................... //	timers.read_watchdog_seconds=0;
.................... }
0294:  BCF    F9E.3
0296:  GOTO   006C
.................... #endif
.................... 
.................... 
.................... 
.................... void init(void) {
.................... 	setup_vref(VREF_OFF);
*
040E:  CLRF   FBA
.................... 	setup_dac(DAC_OFF);
0410:  CLRF   FBB
.................... 	setup_adc(ADC_OFF);
0412:  BCF    FC2.0
.................... 	setup_adc_ports(NO_ANALOGS);
0414:  MOVLW  00
0416:  MOVWF  F7E
0418:  BCF    FC1.0
041A:  BCF    FC1.1
041C:  BCF    FC1.2
041E:  BCF    FC1.3
0420:  MOVWF  F7F
.................... 
.................... 
.................... 
.................... 	set_tris_a    (0b00111111);
0422:  MOVLW  3F
0424:  MOVWF  F92
.................... 	port_a_pullups(0b00110000);
0426:  MOVLW  30
0428:  MOVWF  F77
042A:  BCF    FF1.7
.................... //                   76543210
.................... 
.................... 	set_tris_b    (0b01110000);
042C:  MOVLW  70
042E:  MOVWF  F93
.................... 	port_b_pullups(0b00000000);
0430:  CLRF   F78
.................... //                   76543210
.................... 
.................... 	set_tris_c    (0b11110011);
0432:  MOVLW  F3
0434:  MOVWF  F94
.................... //                   76543210
.................... 
.................... 
.................... 	/* data structure initialization */
.................... 	/* all initialized to 0 on declaration. Just do this if need non-zero */
.................... 
.................... 
.................... 	/* one periodic interrupt @ 1mS. Generated from system 16 MHz clock */
.................... 	/* prescale=16, match=249, postscale=1. Match is 249 because when match occurs, one cycle is lost */
.................... 	setup_timer_2(T2_DIV_BY_16,249,1);
0436:  MOVLW  00
0438:  IORLW  06
043A:  MOVWF  FCA
043C:  MOVLW  F9
043E:  MOVWF  FCB
.................... 
.................... 	enable_interrupts(INT_TIMER2);
0440:  BSF    F9D.1
0442:  GOTO   0B42 (RETURN)
.................... }
.................... 
.................... int8 read_dip_switch(void) {
.................... 	/* nomenclature is backwards on netlist. We actually want LSB on top */
.................... 	return ( ! input(PIC_ADDR_LSB)<<1 ) | ( ! input(PIC_ADDR_MSB) );
*
0726:  BSF    F94.7
0728:  MOVLW  00
072A:  BTFSS  F82.7
072C:  MOVLW  01
072E:  MOVWF  00
0730:  BCF    FD8.0
0732:  RLCF   00,W
0734:  MOVWF  x6F
0736:  BSF    F94.6
0738:  MOVLW  00
073A:  BTFSS  F82.6
073C:  MOVLW  01
073E:  IORWF  x6F,W
0740:  MOVWF  01
0742:  GOTO   0BC8 (RETURN)
.................... }
.................... 
.................... void action_now_ina(void) {
.................... 	timers.now_ina=0;
*
0666:  BCF    x62.1
.................... 
.................... 	/* sample INA228 at middle of 1 second window */
.................... 	next.vbus_a=ina228_read24(INA228_A_ADDR,INA228_REG_VBUS);
0668:  MOVLW  80
066A:  MOVWF  x6F
066C:  MOVLW  05
066E:  MOVWF  x70
0670:  RCALL  0542
0672:  MOVFF  03,41
0676:  MOVFF  02,40
067A:  MOVFF  01,3F
067E:  MOVFF  00,3E
.................... 	next.vshunt_a=ina228_read24(INA228_A_ADDR,INA228_REG_VSHUNT);
0682:  MOVLW  80
0684:  MOVWF  x6F
0686:  MOVLW  04
0688:  MOVWF  x70
068A:  RCALL  0542
068C:  MOVFF  03,45
0690:  MOVFF  02,44
0694:  MOVFF  01,43
0698:  MOVFF  00,42
.................... 
.................... 	next.vbus_b=ina228_read24(INA228_B_ADDR,INA228_REG_VBUS);
069C:  MOVLW  9A
069E:  MOVWF  x6F
06A0:  MOVLW  05
06A2:  MOVWF  x70
06A4:  RCALL  0542
06A6:  MOVFF  03,49
06AA:  MOVFF  02,48
06AE:  MOVFF  01,47
06B2:  MOVFF  00,46
.................... 	next.vshunt_b=ina228_read24(INA228_B_ADDR,INA228_REG_VSHUNT);
06B6:  MOVLW  9A
06B8:  MOVWF  x6F
06BA:  MOVLW  04
06BC:  MOVWF  x70
06BE:  RCALL  0542
06C0:  MOVFF  03,4D
06C4:  MOVFF  02,4C
06C8:  MOVFF  01,4B
06CC:  MOVFF  00,4A
.................... 
.................... 	next.dietemp_a=ina228_read16(INA228_A_ADDR,INA228_REG_DIETEMP);
06D0:  MOVLW  80
06D2:  MOVWF  x6F
06D4:  MOVLW  06
06D6:  MOVWF  x70
06D8:  RCALL  05E0
06DA:  MOVFF  02,5F
06DE:  MOVFF  01,5E
.................... 	next.dietemp_b=ina228_read16(INA228_B_ADDR,INA228_REG_DIETEMP);
06E2:  MOVLW  9A
06E4:  MOVWF  x6F
06E6:  MOVLW  06
06E8:  MOVWF  x70
06EA:  RCALL  05E0
06EC:  MOVFF  02,61
06F0:  MOVFF  01,60
06F4:  GOTO   0BBA (RETURN)
.................... }
.................... 
.................... 
.................... void periodic_millisecond(void) {
.................... 	timers.now_millisecond=0;
06F8:  BCF    x62.0
.................... 
.................... 	/* LED control */
.................... 	if ( 0==timers.led_on_a ) {
06FA:  MOVF   x63,F
06FC:  BNZ   0704
.................... 		output_low(LED_A);
06FE:  BCF    F94.3
0700:  BCF    F8B.3
.................... 	} else {
0702:  BRA    070A
.................... 		output_high(LED_A);
0704:  BCF    F94.3
0706:  BSF    F8B.3
.................... 		timers.led_on_a--;
0708:  DECF   x63,F
.................... 	}
070A:  GOTO   0BC0 (RETURN)
.................... 
.................... 
.................... }
.................... 
.................... int8 get_ack_status(int8 address) {
.................... 	int8 status;
.................... 
.................... 	i2c_start(STREAM_MASTER);
.................... 	status = i2c_write(STREAM_MASTER,address);  // Status = 0 if got an ACK
.................... 	i2c_stop(STREAM_MASTER);
.................... 
.................... 	if ( 0 == status )
.................... 		return(TRUE);
.................... 
....................    return(FALSE);
.................... }
.................... 
.................... 
.................... void main(void) {
*
0AB0:  CLRF   FF8
0AB2:  BCF    FD0.7
0AB4:  BSF    07.7
0AB6:  BSF    F93.6
0AB8:  BSF    F93.4
0ABA:  MOVLW  34
0ABC:  MOVWF  FC8
0ABE:  MOVLW  36
0AC0:  MOVWF  FC6
0AC2:  BSF    FC5.0
0AC4:  BSF    FC5.7
0AC6:  CLRF   19
0AC8:  BSF    FB8.3
0ACA:  MOVLW  A0
0ACC:  MOVWF  FAF
0ACE:  MOVLW  01
0AD0:  MOVWF  FB0
0AD2:  MOVLW  A6
0AD4:  MOVWF  FAC
0AD6:  MOVLW  90
0AD8:  MOVWF  FAB
0ADA:  CLRF   x6D
0ADC:  CLRF   x6C
0ADE:  MOVLW  00
0AE0:  MOVWF  F7E
0AE2:  BCF    FC1.0
0AE4:  BCF    FC1.1
0AE6:  BCF    FC1.2
0AE8:  BCF    FC1.3
0AEA:  MOVWF  F7F
0AEC:  CLRF   F6C
0AEE:  CLRF   F6B
0AF0:  CLRF   F6D
0AF2:  BCF    x66.0
0AF4:  BCF    x66.1
0AF6:  BRA    0B02
0AF8:  DATA 4C,40
0AFA:  DATA 1A,00
0AFC:  DATA 05,40
0AFE:  DATA 67,00
0B00:  DATA 00,00
0B02:  MOVLW  00
0B04:  MOVWF  FF8
0B06:  MOVLW  0A
0B08:  MOVWF  FF7
0B0A:  MOVLW  F8
0B0C:  MOVWF  FF6
0B0E:  TBLRD*+
0B10:  MOVF   FF5,W
0B12:  MOVWF  00
0B14:  XORLW  00
0B16:  BZ    0B3E
0B18:  TBLRD*+
0B1A:  MOVF   FF5,W
0B1C:  MOVWF  01
0B1E:  BTFSC  FE8.7
0B20:  BRA    0B2C
0B22:  ANDLW  3F
0B24:  MOVWF  FEA
0B26:  TBLRD*+
0B28:  MOVFF  FF5,FE9
0B2C:  BTFSC  01.6
0B2E:  TBLRD*+
0B30:  BTFSS  01.6
0B32:  TBLRD*+
0B34:  MOVFF  FF5,FEE
0B38:  DCFSNZ 00,F
0B3A:  BRA    0B0E
0B3C:  BRA    0B30
0B3E:  CLRF   FF8
.................... 	int8 i;
.................... 
.................... 	init();
0B40:  BRA    040E
.................... 
.................... 
.................... 
.................... 	/* flash on startup */
.................... 	for ( i=0 ; i<5 ; i++ ) {
0B42:  CLRF   x6E
0B44:  MOVF   x6E,W
0B46:  SUBLW  04
0B48:  BNC   0B64
.................... 		restart_wdt();
0B4A:  CLRWDT
.................... 		output_high(LED_A);
0B4C:  BCF    F94.3
0B4E:  BSF    F8B.3
.................... 		delay_ms(200);
0B50:  MOVLW  C8
0B52:  MOVWF  x70
0B54:  RCALL  0446
.................... 		output_low(LED_A);
0B56:  BCF    F94.3
0B58:  BCF    F8B.3
.................... 		delay_ms(200);
0B5A:  MOVLW  C8
0B5C:  MOVWF  x70
0B5E:  RCALL  0446
0B60:  INCF   x6E,F
0B62:  BRA    0B44
.................... 	}
.................... 
.................... 	delay_ms(1000);
0B64:  MOVLW  04
0B66:  MOVWF  x6F
0B68:  MOVLW  FA
0B6A:  MOVWF  x70
0B6C:  RCALL  0446
0B6E:  DECFSZ x6F,F
0B70:  BRA    0B68
.................... 
.................... 	fprintf(STREAM_FTDI,"# dcswc_module_voltage_current_counter %s\r\n",__DATE__);
0B72:  MOVLW  9A
0B74:  MOVWF  FF6
0B76:  MOVLW  02
0B78:  MOVWF  FF7
0B7A:  MOVLW  27
0B7C:  MOVWF  x70
0B7E:  RCALL  046E
0B80:  MOVLW  C6
0B82:  MOVWF  FF6
0B84:  MOVLW  02
0B86:  MOVWF  FF7
0B88:  BRA    048E
0B8A:  MOVLW  0D
0B8C:  BTFSS  F9E.4
0B8E:  BRA    0B8C
0B90:  MOVWF  FAD
0B92:  MOVLW  0A
0B94:  BTFSS  F9E.4
0B96:  BRA    0B94
0B98:  MOVWF  FAD
.................... 
.................... 	delay_ms(1000);
0B9A:  MOVLW  04
0B9C:  MOVWF  x6F
0B9E:  MOVLW  FA
0BA0:  MOVWF  x70
0BA2:  RCALL  0446
0BA4:  DECFSZ x6F,F
0BA6:  BRA    0B9E
.................... 
.................... 	timers.led_on_a=500;
0BA8:  MOVLW  F4
0BAA:  MOVWF  x63
.................... 
.................... 	enable_interrupts(GLOBAL);
0BAC:  MOVLW  C0
0BAE:  IORWF  FF2,F
.................... 
.................... 	/* enable I2C slave interrupt */
.................... 	enable_interrupts(INT_SSP);
0BB0:  BSF    F9D.3
.................... 
.................... 	for ( ; ; ) {
.................... 		restart_wdt();
0BB2:  CLRWDT
.................... 
.................... 		/* query INA228's for next */
.................... 		if ( timers.now_ina ) {
0BB4:  BTFSS  x62.1
0BB6:  BRA    0BBA
.................... 			action_now_ina();
0BB8:  BRA    0666
.................... 		}
.................... 
.................... 		if ( timers.now_millisecond ) {
0BBA:  BTFSS  x62.0
0BBC:  BRA    0BC0
.................... 			periodic_millisecond();
0BBE:  BRA    06F8
.................... 		}
.................... 
.................... 		if ( kbhit() ) {
0BC0:  BTFSS  F9E.5
0BC2:  BRA    0E90
.................... 			getc();
0BC4:  BRA    070E
.................... 
.................... 			fprintf(STREAM_FTDI,"# DIP SWITCHES: %d\r\n",
.................... 				read_dip_switch()
.................... 			);
0BC6:  BRA    0726
0BC8:  MOVFF  01,6F
0BCC:  MOVLW  D0
0BCE:  MOVWF  FF6
0BD0:  MOVLW  02
0BD2:  MOVWF  FF7
0BD4:  MOVLW  10
0BD6:  MOVWF  x70
0BD8:  RCALL  046E
0BDA:  MOVFF  6F,70
0BDE:  MOVLW  18
0BE0:  MOVWF  x71
0BE2:  BRA    076E
0BE4:  MOVLW  0D
0BE6:  BTFSS  F9E.4
0BE8:  BRA    0BE6
0BEA:  MOVWF  FAD
0BEC:  MOVLW  0A
0BEE:  BTFSS  F9E.4
0BF0:  BRA    0BEE
0BF2:  MOVWF  FAD
.................... 
.................... 			fprintf(STREAM_FTDI,"# A: 0x%08lx / 0x%08lx / 0x%04lu\r\n",
.................... 				current.vbus_a,
.................... 				current.vshunt_a,
.................... 				current.dietemp_a
.................... 			);
0BF4:  MOVLW  E6
0BF6:  MOVWF  FF6
0BF8:  MOVLW  02
0BFA:  MOVWF  FF7
0BFC:  MOVLW  07
0BFE:  MOVWF  x70
0C00:  RCALL  046E
0C02:  MOVFF  1D,6F
0C06:  MOVLW  57
0C08:  MOVWF  x70
0C0A:  RCALL  0822
0C0C:  MOVFF  1C,6F
0C10:  MOVLW  57
0C12:  MOVWF  x70
0C14:  RCALL  0822
0C16:  MOVFF  1B,6F
0C1A:  MOVLW  57
0C1C:  MOVWF  x70
0C1E:  RCALL  0822
0C20:  MOVFF  1A,6F
0C24:  MOVLW  57
0C26:  MOVWF  x70
0C28:  RCALL  0822
0C2A:  MOVLW  F2
0C2C:  MOVWF  FF6
0C2E:  MOVLW  02
0C30:  MOVWF  FF7
0C32:  MOVLW  05
0C34:  MOVWF  x70
0C36:  RCALL  046E
0C38:  MOVFF  21,6F
0C3C:  MOVLW  57
0C3E:  MOVWF  x70
0C40:  RCALL  0822
0C42:  MOVFF  20,6F
0C46:  MOVLW  57
0C48:  MOVWF  x70
0C4A:  RCALL  0822
0C4C:  MOVFF  1F,6F
0C50:  MOVLW  57
0C52:  MOVWF  x70
0C54:  RCALL  0822
0C56:  MOVFF  1E,6F
0C5A:  MOVLW  57
0C5C:  MOVWF  x70
0C5E:  RCALL  0822
0C60:  MOVLW  FC
0C62:  MOVWF  FF6
0C64:  MOVLW  02
0C66:  MOVWF  FF7
0C68:  MOVLW  05
0C6A:  MOVWF  x70
0C6C:  RCALL  046E
0C6E:  MOVLW  09
0C70:  MOVWF  FE9
0C72:  MOVFF  3B,70
0C76:  MOVFF  3A,6F
0C7A:  RCALL  0864
0C7C:  MOVLW  0D
0C7E:  BTFSS  F9E.4
0C80:  BRA    0C7E
0C82:  MOVWF  FAD
0C84:  MOVLW  0A
0C86:  BTFSS  F9E.4
0C88:  BRA    0C86
0C8A:  MOVWF  FAD
.................... 			fprintf(STREAM_FTDI,"# B: 0x%08lx / 0x%08lx / 0x%04lu\r\n",
.................... 				current.vbus_b,
.................... 				current.vshunt_b,
.................... 				current.dietemp_b
.................... 			);
0C8C:  MOVLW  0A
0C8E:  MOVWF  FF6
0C90:  MOVLW  03
0C92:  MOVWF  FF7
0C94:  MOVLW  07
0C96:  MOVWF  x70
0C98:  CALL   046E
0C9C:  MOVFF  25,6F
0CA0:  MOVLW  57
0CA2:  MOVWF  x70
0CA4:  RCALL  0822
0CA6:  MOVFF  24,6F
0CAA:  MOVLW  57
0CAC:  MOVWF  x70
0CAE:  RCALL  0822
0CB0:  MOVFF  23,6F
0CB4:  MOVLW  57
0CB6:  MOVWF  x70
0CB8:  RCALL  0822
0CBA:  MOVFF  22,6F
0CBE:  MOVLW  57
0CC0:  MOVWF  x70
0CC2:  RCALL  0822
0CC4:  MOVLW  16
0CC6:  MOVWF  FF6
0CC8:  MOVLW  03
0CCA:  MOVWF  FF7
0CCC:  MOVLW  05
0CCE:  MOVWF  x70
0CD0:  CALL   046E
0CD4:  MOVFF  29,6F
0CD8:  MOVLW  57
0CDA:  MOVWF  x70
0CDC:  RCALL  0822
0CDE:  MOVFF  28,6F
0CE2:  MOVLW  57
0CE4:  MOVWF  x70
0CE6:  RCALL  0822
0CE8:  MOVFF  27,6F
0CEC:  MOVLW  57
0CEE:  MOVWF  x70
0CF0:  RCALL  0822
0CF2:  MOVFF  26,6F
0CF6:  MOVLW  57
0CF8:  MOVWF  x70
0CFA:  RCALL  0822
0CFC:  MOVLW  20
0CFE:  MOVWF  FF6
0D00:  MOVLW  03
0D02:  MOVWF  FF7
0D04:  MOVLW  05
0D06:  MOVWF  x70
0D08:  CALL   046E
0D0C:  MOVLW  09
0D0E:  MOVWF  FE9
0D10:  MOVFF  3D,70
0D14:  MOVFF  3C,6F
0D18:  RCALL  0864
0D1A:  MOVLW  0D
0D1C:  BTFSS  F9E.4
0D1E:  BRA    0D1C
0D20:  MOVWF  FAD
0D22:  MOVLW  0A
0D24:  BTFSS  F9E.4
0D26:  BRA    0D24
0D28:  MOVWF  FAD
.................... 
.................... 			fprintf(STREAM_FTDI,"# current.count_a_last_second=%lu\r\n",
.................... 				current.count_a_last_second
.................... 			);
0D2A:  MOVLW  2E
0D2C:  MOVWF  FF6
0D2E:  MOVLW  03
0D30:  MOVWF  FF7
0D32:  MOVLW  1E
0D34:  MOVWF  x70
0D36:  CALL   046E
0D3A:  MOVLW  10
0D3C:  MOVWF  FE9
0D3E:  MOVFF  2B,70
0D42:  MOVFF  2A,6F
0D46:  RCALL  0864
0D48:  MOVLW  0D
0D4A:  BTFSS  F9E.4
0D4C:  BRA    0D4A
0D4E:  MOVWF  FAD
0D50:  MOVLW  0A
0D52:  BTFSS  F9E.4
0D54:  BRA    0D52
0D56:  MOVWF  FAD
.................... 			fprintf(STREAM_FTDI,"# current.count_b_last_second=%lu\r\n",
.................... 				current.count_b_last_second
.................... 			);
0D58:  MOVLW  52
0D5A:  MOVWF  FF6
0D5C:  MOVLW  03
0D5E:  MOVWF  FF7
0D60:  MOVLW  1E
0D62:  MOVWF  x70
0D64:  CALL   046E
0D68:  MOVLW  10
0D6A:  MOVWF  FE9
0D6C:  MOVFF  2D,70
0D70:  MOVFF  2C,6F
0D74:  RCALL  0864
0D76:  MOVLW  0D
0D78:  BTFSS  F9E.4
0D7A:  BRA    0D78
0D7C:  MOVWF  FAD
0D7E:  MOVLW  0A
0D80:  BTFSS  F9E.4
0D82:  BRA    0D80
0D84:  MOVWF  FAD
.................... 			fprintf(STREAM_FTDI,"# current.count_a_long=%lu\r\n",
.................... 				current.count_a_long
.................... 			);
0D86:  MOVLW  76
0D88:  MOVWF  FF6
0D8A:  MOVLW  03
0D8C:  MOVWF  FF7
0D8E:  MOVLW  17
0D90:  MOVWF  x70
0D92:  CALL   046E
0D96:  MOVLW  41
0D98:  MOVWF  FE9
0D9A:  MOVFF  31,72
0D9E:  MOVFF  30,71
0DA2:  MOVFF  2F,70
0DA6:  MOVFF  2E,6F
0DAA:  RCALL  099E
0DAC:  MOVLW  0D
0DAE:  BTFSS  F9E.4
0DB0:  BRA    0DAE
0DB2:  MOVWF  FAD
0DB4:  MOVLW  0A
0DB6:  BTFSS  F9E.4
0DB8:  BRA    0DB6
0DBA:  MOVWF  FAD
.................... 			fprintf(STREAM_FTDI,"# current.count_b_long=%lu\r\n",
.................... 				current.count_b_long
.................... 			);
0DBC:  MOVLW  94
0DBE:  MOVWF  FF6
0DC0:  MOVLW  03
0DC2:  MOVWF  FF7
0DC4:  MOVLW  17
0DC6:  MOVWF  x70
0DC8:  CALL   046E
0DCC:  MOVLW  41
0DCE:  MOVWF  FE9
0DD0:  MOVFF  35,72
0DD4:  MOVFF  34,71
0DD8:  MOVFF  33,70
0DDC:  MOVFF  32,6F
0DE0:  RCALL  099E
0DE2:  MOVLW  0D
0DE4:  BTFSS  F9E.4
0DE6:  BRA    0DE4
0DE8:  MOVWF  FAD
0DEA:  MOVLW  0A
0DEC:  BTFSS  F9E.4
0DEE:  BRA    0DEC
0DF0:  MOVWF  FAD
.................... 
.................... 			fprintf(STREAM_FTDI,"# current.count_seconds_long=%lu\r\n",
.................... 				current.count_seconds_long
.................... 			);
0DF2:  MOVLW  B2
0DF4:  MOVWF  FF6
0DF6:  MOVLW  03
0DF8:  MOVWF  FF7
0DFA:  MOVLW  1D
0DFC:  MOVWF  x70
0DFE:  CALL   046E
0E02:  MOVLW  41
0E04:  MOVWF  FE9
0E06:  MOVFF  39,72
0E0A:  MOVFF  38,71
0E0E:  MOVFF  37,70
0E12:  MOVFF  36,6F
0E16:  RCALL  099E
0E18:  MOVLW  0D
0E1A:  BTFSS  F9E.4
0E1C:  BRA    0E1A
0E1E:  MOVWF  FAD
0E20:  MOVLW  0A
0E22:  BTFSS  F9E.4
0E24:  BRA    0E22
0E26:  MOVWF  FAD
.................... 
.................... 			fprintf(STREAM_FTDI,"# input(PIC_ADDR_MSB)=%u\r\n",input(PIC_ADDR_MSB));
0E28:  BSF    F94.6
0E2A:  MOVLW  00
0E2C:  BTFSC  F82.6
0E2E:  MOVLW  01
0E30:  MOVWF  x6F
0E32:  MOVLW  D6
0E34:  MOVWF  FF6
0E36:  MOVLW  03
0E38:  MOVWF  FF7
0E3A:  MOVLW  16
0E3C:  MOVWF  x70
0E3E:  CALL   046E
0E42:  MOVFF  6F,70
0E46:  MOVLW  1B
0E48:  MOVWF  x71
0E4A:  RCALL  0A44
0E4C:  MOVLW  0D
0E4E:  BTFSS  F9E.4
0E50:  BRA    0E4E
0E52:  MOVWF  FAD
0E54:  MOVLW  0A
0E56:  BTFSS  F9E.4
0E58:  BRA    0E56
0E5A:  MOVWF  FAD
.................... 			fprintf(STREAM_FTDI,"# input(PIC_ADDR_LSB)=%u\r\n",input(PIC_ADDR_LSB));
0E5C:  BSF    F94.7
0E5E:  MOVLW  00
0E60:  BTFSC  F82.7
0E62:  MOVLW  01
0E64:  MOVWF  x6F
0E66:  MOVLW  F2
0E68:  MOVWF  FF6
0E6A:  MOVLW  03
0E6C:  MOVWF  FF7
0E6E:  MOVLW  16
0E70:  MOVWF  x70
0E72:  CALL   046E
0E76:  MOVFF  6F,70
0E7A:  MOVLW  1B
0E7C:  MOVWF  x71
0E7E:  RCALL  0A44
0E80:  MOVLW  0D
0E82:  BTFSS  F9E.4
0E84:  BRA    0E82
0E86:  MOVWF  FAD
0E88:  MOVLW  0A
0E8A:  BTFSS  F9E.4
0E8C:  BRA    0E8A
0E8E:  MOVWF  FAD
.................... 
.................... 		}
0E90:  BRA    0BB2
.................... 
.................... 
.................... 	}
.................... 
.................... 
.................... }
0E92:  BRA    0E92

Configuration Fuses:
   Word  1: 2200   HS NOPLLEN PCLKEN NOFCMEN NOIESO
   Word  2: 1819   NOPUT NOBROWNOUT BORV19 NOWDT WDT4096
   Word  3: 0000   NOHFOFST NOMCLR
   Word  4: 0009   STVREN NOLVP BBSIZ2K NOXINST DEBUG
   Word  5: C003   NOPROTECT NOCPB NOCPD
   Word  6: E003   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 4003   NOEBTR NOEBTRB

   Some fuses have been forced to be compatible with the ICD debugger.

ROM data:
F00000: 00 00 40 00                                        ..@.
