CCS PCH C Compiler, Version 5.090, 49113               11-Jan-22 15:09

               Filename:   C:\Users\James Jarvis\Desktop\planetPrecision\dcswc_module_voltage_current_counter\dcswc_module_voltage_current_counter.lst

               ROM used:   4186 bytes (27%)
                           Largest free fragment is 11362
               RAM used:   114 (22%) at main() level
                           145 (28%) worst case
               Stack used: 4 locations (2 in main + 2 for interrupts)
               Stack size: 30

0000:  GOTO   0C76
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  FF5,15
003C:  MOVFF  FF6,16
0040:  MOVFF  FF7,17
0044:  MOVFF  00,0E
0048:  MOVFF  01,0F
004C:  MOVFF  02,10
0050:  MOVFF  03,11
0054:  BTFSS  F9D.1
0056:  GOTO   0060
005A:  BTFSC  F9E.1
005C:  GOTO   00BA
0060:  BTFSS  F9D.3
0062:  GOTO   006C
0066:  BTFSC  F9E.3
0068:  GOTO   03A4
006C:  MOVFF  0E,00
0070:  MOVFF  0F,01
0074:  MOVFF  10,02
0078:  MOVFF  11,03
007C:  MOVFF  0C,FE9
0080:  MOVFF  07,FEA
0084:  BSF    07.7
0086:  MOVFF  08,FE1
008A:  MOVFF  09,FE2
008E:  MOVFF  0A,FD9
0092:  MOVFF  0B,FDA
0096:  MOVFF  12,FF3
009A:  MOVFF  13,FF4
009E:  MOVFF  14,FFA
00A2:  MOVFF  15,FF5
00A6:  MOVFF  16,FF6
00AA:  MOVFF  17,FF7
00AE:  MOVF   04,W
00B0:  MOVFF  06,FE0
00B4:  MOVFF  05,FD8
00B8:  RETFIE 0
.................... #include "dcswc_module_voltage_current_counter.h"
.................... #include <18F14K22.h>
.................... //////////// Standard Header file for the PIC18F14K22 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18F14K22
*
0458:  DATA 23,20
045A:  DATA 64,63
045C:  DATA 73,77
045E:  DATA 63,5F
0460:  DATA 6D,6F
0462:  DATA 64,75
0464:  DATA 6C,65
0466:  DATA 5F,76
0468:  DATA 6F,6C
046A:  DATA 74,61
046C:  DATA 67,65
046E:  DATA 5F,63
0470:  DATA 75,72
0472:  DATA 72,65
0474:  DATA 6E,74
0476:  DATA 5F,63
0478:  DATA 6F,75
047A:  DATA 6E,74
047C:  DATA 65,72
047E:  DATA 20,25
0480:  DATA 73,0D
0482:  DATA 0A,00
0484:  DATA 31,31
0486:  DATA 2D,4A
0488:  DATA 61,6E
048A:  DATA 2D,32
048C:  DATA 32,00
048E:  DATA 23,20
0490:  DATA 44,49
0492:  DATA 50,20
0494:  DATA 53,57
0496:  DATA 49,54
0498:  DATA 43,48
049A:  DATA 45,53
049C:  DATA 3A,20
049E:  DATA 25,64
04A0:  DATA 0D,0A
04A2:  DATA 00,00
04A4:  DATA 23,20
04A6:  DATA 41,3A
04A8:  DATA 20,30
04AA:  DATA 78,25
04AC:  DATA 30,38
04AE:  DATA 6C,78
04B0:  DATA 20,2F
04B2:  DATA 20,30
04B4:  DATA 78,25
04B6:  DATA 30,38
04B8:  DATA 6C,78
04BA:  DATA 20,2F
04BC:  DATA 20,30
04BE:  DATA 78,25
04C0:  DATA 30,34
04C2:  DATA 6C,75
04C4:  DATA 0D,0A
04C6:  DATA 00,00
04C8:  DATA 23,20
04CA:  DATA 42,3A
04CC:  DATA 20,30
04CE:  DATA 78,25
04D0:  DATA 30,38
04D2:  DATA 6C,78
04D4:  DATA 20,2F
04D6:  DATA 20,30
04D8:  DATA 78,25
04DA:  DATA 30,38
04DC:  DATA 6C,78
04DE:  DATA 20,2F
04E0:  DATA 20,30
04E2:  DATA 78,25
04E4:  DATA 30,34
04E6:  DATA 6C,75
04E8:  DATA 0D,0A
04EA:  DATA 00,00
04EC:  DATA 23,20
04EE:  DATA 63,75
04F0:  DATA 72,72
04F2:  DATA 65,6E
04F4:  DATA 74,2E
04F6:  DATA 63,6F
04F8:  DATA 75,6E
04FA:  DATA 74,5F
04FC:  DATA 61,5F
04FE:  DATA 6C,61
0500:  DATA 73,74
0502:  DATA 5F,73
0504:  DATA 65,63
0506:  DATA 6F,6E
0508:  DATA 64,3D
050A:  DATA 25,6C
050C:  DATA 75,0D
050E:  DATA 0A,00
0510:  DATA 23,20
0512:  DATA 63,75
0514:  DATA 72,72
0516:  DATA 65,6E
0518:  DATA 74,2E
051A:  DATA 63,6F
051C:  DATA 75,6E
051E:  DATA 74,5F
0520:  DATA 62,5F
0522:  DATA 6C,61
0524:  DATA 73,74
0526:  DATA 5F,73
0528:  DATA 65,63
052A:  DATA 6F,6E
052C:  DATA 64,3D
052E:  DATA 25,6C
0530:  DATA 75,0D
0532:  DATA 0A,00
0534:  DATA 23,20
0536:  DATA 63,75
0538:  DATA 72,72
053A:  DATA 65,6E
053C:  DATA 74,2E
053E:  DATA 63,6F
0540:  DATA 75,6E
0542:  DATA 74,5F
0544:  DATA 61,5F
0546:  DATA 6C,6F
0548:  DATA 6E,67
054A:  DATA 3D,25
054C:  DATA 6C,75
054E:  DATA 0D,0A
0550:  DATA 00,00
0552:  DATA 23,20
0554:  DATA 63,75
0556:  DATA 72,72
0558:  DATA 65,6E
055A:  DATA 74,2E
055C:  DATA 63,6F
055E:  DATA 75,6E
0560:  DATA 74,5F
0562:  DATA 62,5F
0564:  DATA 6C,6F
0566:  DATA 6E,67
0568:  DATA 3D,25
056A:  DATA 6C,75
056C:  DATA 0D,0A
056E:  DATA 00,00
0570:  DATA 23,20
0572:  DATA 63,75
0574:  DATA 72,72
0576:  DATA 65,6E
0578:  DATA 74,2E
057A:  DATA 63,6F
057C:  DATA 75,6E
057E:  DATA 74,5F
0580:  DATA 73,65
0582:  DATA 63,6F
0584:  DATA 6E,64
0586:  DATA 73,5F
0588:  DATA 6C,6F
058A:  DATA 6E,67
058C:  DATA 3D,25
058E:  DATA 6C,75
0590:  DATA 0D,0A
0592:  DATA 00,00
0594:  DATA 23,20
0596:  DATA 69,6E
0598:  DATA 70,75
059A:  DATA 74,28
059C:  DATA 50,49
059E:  DATA 43,5F
05A0:  DATA 41,44
05A2:  DATA 44,52
05A4:  DATA 5F,4D
05A6:  DATA 53,42
05A8:  DATA 29,3D
05AA:  DATA 25,75
05AC:  DATA 0D,0A
05AE:  DATA 00,00
05B0:  DATA 23,20
05B2:  DATA 69,6E
05B4:  DATA 70,75
05B6:  DATA 74,28
05B8:  DATA 50,49
05BA:  DATA 43,5F
05BC:  DATA 41,44
05BE:  DATA 44,52
05C0:  DATA 5F,4C
05C2:  DATA 53,42
05C4:  DATA 29,3D
05C6:  DATA 25,75
05C8:  DATA 0D,0A
05CA:  DATA 00,00
*
0654:  TBLRD*+
0656:  MOVFF  FF6,73
065A:  MOVFF  FF7,74
065E:  MOVF   FF5,W
0660:  BTFSS  F9E.4
0662:  BRA    0660
0664:  MOVWF  FAD
0666:  MOVFF  73,FF6
066A:  MOVFF  74,FF7
066E:  DECFSZ x72,F
0670:  BRA    0654
0672:  RETURN 0
0674:  TBLRD*+
0676:  MOVF   FF5,F
0678:  BZ    0694
067A:  MOVFF  FF6,71
067E:  MOVFF  FF7,72
0682:  MOVF   FF5,W
0684:  BTFSS  F9E.4
0686:  BRA    0684
0688:  MOVWF  FAD
068A:  MOVFF  71,FF6
068E:  MOVFF  72,FF7
0692:  BRA    0674
0694:  GOTO   0D54 (RETURN)
*
090C:  MOVF   x79,W
090E:  CLRF   01
0910:  SUBWF  x78,W
0912:  BC    091A
0914:  MOVFF  78,00
0918:  BRA    0932
091A:  CLRF   00
091C:  MOVLW  08
091E:  MOVWF  x7A
0920:  RLCF   x78,F
0922:  RLCF   00,F
0924:  MOVF   x79,W
0926:  SUBWF  00,W
0928:  BTFSC  FD8.0
092A:  MOVWF  00
092C:  RLCF   01,F
092E:  DECFSZ x7A,F
0930:  BRA    0920
0932:  RETURN 0
0934:  MOVLW  20
0936:  BTFSS  x73.4
0938:  MOVLW  30
093A:  MOVWF  x74
093C:  MOVFF  72,00
0940:  BTFSS  x72.7
0942:  BRA    0954
0944:  COMF   00,F
0946:  INCF   00,F
0948:  MOVFF  00,72
094C:  MOVLW  2D
094E:  MOVWF  x74
0950:  BSF    x73.7
0952:  BSF    x73.0
0954:  MOVF   01,W
0956:  MOVFF  72,78
095A:  MOVLW  64
095C:  MOVWF  x79
095E:  RCALL  090C
0960:  MOVFF  00,72
0964:  MOVLW  30
0966:  ADDWF  01,W
0968:  MOVWF  x75
096A:  MOVFF  72,78
096E:  MOVLW  0A
0970:  MOVWF  x79
0972:  RCALL  090C
0974:  MOVLW  30
0976:  ADDWF  00,W
0978:  MOVWF  x77
097A:  MOVLW  30
097C:  ADDWF  01,W
097E:  MOVWF  x76
0980:  MOVFF  74,00
0984:  MOVLW  30
0986:  SUBWF  x75,W
0988:  BZ    0992
098A:  BSF    x73.1
098C:  BTFSC  x73.7
098E:  BSF    x73.2
0990:  BRA    09B6
0992:  MOVFF  74,75
0996:  MOVLW  20
0998:  MOVWF  x74
099A:  MOVLW  30
099C:  SUBWF  x76,W
099E:  BZ    09A8
09A0:  BSF    x73.0
09A2:  BTFSC  x73.7
09A4:  BSF    x73.1
09A6:  BRA    09B6
09A8:  BTFSS  FD8.2
09AA:  BSF    x73.0
09AC:  BNZ   09B6
09AE:  MOVFF  75,76
09B2:  MOVLW  20
09B4:  MOVWF  x75
09B6:  BTFSC  x73.2
09B8:  BRA    09C4
09BA:  BTFSC  x73.1
09BC:  BRA    09CC
09BE:  BTFSC  x73.0
09C0:  BRA    09D4
09C2:  BRA    09DC
09C4:  MOVF   x74,W
09C6:  BTFSS  F9E.4
09C8:  BRA    09C6
09CA:  MOVWF  FAD
09CC:  MOVF   x75,W
09CE:  BTFSS  F9E.4
09D0:  BRA    09CE
09D2:  MOVWF  FAD
09D4:  MOVF   x76,W
09D6:  BTFSS  F9E.4
09D8:  BRA    09D6
09DA:  MOVWF  FAD
09DC:  MOVF   x77,W
09DE:  BTFSS  F9E.4
09E0:  BRA    09DE
09E2:  MOVWF  FAD
09E4:  GOTO   0DAE (RETURN)
09E8:  BTFSC  x72.7
09EA:  BRA    0A0C
09EC:  MOVLW  0F
09EE:  MOVWF  00
09F0:  SWAPF  x71,W
09F2:  ANDWF  00,F
09F4:  MOVLW  0A
09F6:  SUBWF  00,W
09F8:  BC    0A00
09FA:  MOVLW  30
09FC:  ADDWF  00,F
09FE:  BRA    0A04
0A00:  MOVF   x72,W
0A02:  ADDWF  00,F
0A04:  MOVF   00,W
0A06:  BTFSS  F9E.4
0A08:  BRA    0A06
0A0A:  MOVWF  FAD
0A0C:  MOVLW  0F
0A0E:  ANDWF  x71,F
0A10:  MOVLW  0A
0A12:  SUBWF  x71,W
0A14:  BC    0A1A
0A16:  MOVLW  30
0A18:  BRA    0A1E
0A1A:  BCF    x72.7
0A1C:  MOVF   x72,W
0A1E:  ADDWF  x71,F
0A20:  MOVF   x71,W
0A22:  BTFSS  F9E.4
0A24:  BRA    0A22
0A26:  MOVWF  FAD
0A28:  RETURN 0
0A2A:  MOVFF  FEA,79
0A2E:  MOVFF  FE9,78
0A32:  SWAPF  x72,W
0A34:  IORLW  F0
0A36:  MOVWF  x74
0A38:  ADDWF  x74,F
0A3A:  ADDLW  E2
0A3C:  MOVWF  x75
0A3E:  ADDLW  32
0A40:  MOVWF  x77
0A42:  MOVF   x72,W
0A44:  ANDLW  0F
0A46:  ADDWF  x75,F
0A48:  ADDWF  x75,F
0A4A:  ADDWF  x77,F
0A4C:  ADDLW  E9
0A4E:  MOVWF  x76
0A50:  ADDWF  x76,F
0A52:  ADDWF  x76,F
0A54:  SWAPF  x71,W
0A56:  ANDLW  0F
0A58:  ADDWF  x76,F
0A5A:  ADDWF  x77,F
0A5C:  RLCF   x76,F
0A5E:  RLCF   x77,F
0A60:  COMF   x77,F
0A62:  RLCF   x77,F
0A64:  MOVF   x71,W
0A66:  ANDLW  0F
0A68:  ADDWF  x77,F
0A6A:  RLCF   x74,F
0A6C:  MOVLW  07
0A6E:  MOVWF  x73
0A70:  MOVLW  0A
0A72:  DECF   x76,F
0A74:  ADDWF  x77,F
0A76:  BNC   0A72
0A78:  DECF   x75,F
0A7A:  ADDWF  x76,F
0A7C:  BNC   0A78
0A7E:  DECF   x74,F
0A80:  ADDWF  x75,F
0A82:  BNC   0A7E
0A84:  DECF   x73,F
0A86:  ADDWF  x74,F
0A88:  BNC   0A84
0A8A:  CLRF   FEA
0A8C:  MOVLW  73
0A8E:  MOVWF  FE9
0A90:  MOVLW  07
0A92:  ANDWF  x78,W
0A94:  BCF    x78.6
0A96:  ADDWF  FE9,F
0A98:  MOVLW  00
0A9A:  ADDWFC FEA,F
0A9C:  MOVF   FE9,W
0A9E:  SUBLW  77
0AA0:  BNZ   0AA8
0AA2:  MOVF   FEA,F
0AA4:  BNZ   0AA8
0AA6:  BSF    x78.6
0AA8:  MOVF   FEF,W
0AAA:  MOVWF  00
0AAC:  BNZ   0ABE
0AAE:  BTFSC  x78.6
0AB0:  BRA    0ABE
0AB2:  BTFSC  x78.4
0AB4:  BRA    0ACE
0AB6:  BTFSC  x78.3
0AB8:  BRA    0ABE
0ABA:  MOVLW  20
0ABC:  BRA    0AC4
0ABE:  BSF    x78.3
0AC0:  BCF    x78.4
0AC2:  MOVLW  30
0AC4:  ADDWF  00,F
0AC6:  MOVF   00,W
0AC8:  BTFSS  F9E.4
0ACA:  BRA    0AC8
0ACC:  MOVWF  FAD
0ACE:  MOVF   FEE,W
0AD0:  BTFSS  x78.6
0AD2:  BRA    0A9C
0AD4:  RETURN 0
0AD6:  BTFSC  FD8.1
0AD8:  BRA    0AE0
0ADA:  CLRF   FEA
0ADC:  MOVLW  85
0ADE:  MOVWF  FE9
0AE0:  CLRF   00
0AE2:  CLRF   01
0AE4:  CLRF   02
0AE6:  CLRF   03
0AE8:  CLRF   x85
0AEA:  CLRF   x86
0AEC:  CLRF   x87
0AEE:  CLRF   x88
0AF0:  MOVF   x84,W
0AF2:  IORWF  x83,W
0AF4:  IORWF  x82,W
0AF6:  IORWF  x81,W
0AF8:  BZ    0B52
0AFA:  MOVLW  20
0AFC:  MOVWF  x89
0AFE:  BCF    FD8.0
0B00:  RLCF   x7D,F
0B02:  RLCF   x7E,F
0B04:  RLCF   x7F,F
0B06:  RLCF   x80,F
0B08:  RLCF   x85,F
0B0A:  RLCF   x86,F
0B0C:  RLCF   x87,F
0B0E:  RLCF   x88,F
0B10:  MOVF   x84,W
0B12:  SUBWF  x88,W
0B14:  BNZ   0B26
0B16:  MOVF   x83,W
0B18:  SUBWF  x87,W
0B1A:  BNZ   0B26
0B1C:  MOVF   x82,W
0B1E:  SUBWF  x86,W
0B20:  BNZ   0B26
0B22:  MOVF   x81,W
0B24:  SUBWF  x85,W
0B26:  BNC   0B46
0B28:  MOVF   x81,W
0B2A:  SUBWF  x85,F
0B2C:  MOVF   x82,W
0B2E:  BTFSS  FD8.0
0B30:  INCFSZ x82,W
0B32:  SUBWF  x86,F
0B34:  MOVF   x83,W
0B36:  BTFSS  FD8.0
0B38:  INCFSZ x83,W
0B3A:  SUBWF  x87,F
0B3C:  MOVF   x84,W
0B3E:  BTFSS  FD8.0
0B40:  INCFSZ x84,W
0B42:  SUBWF  x88,F
0B44:  BSF    FD8.0
0B46:  RLCF   00,F
0B48:  RLCF   01,F
0B4A:  RLCF   02,F
0B4C:  RLCF   03,F
0B4E:  DECFSZ x89,F
0B50:  BRA    0AFE
0B52:  MOVFF  85,FEF
0B56:  MOVFF  86,FEC
0B5A:  MOVFF  87,FEC
0B5E:  MOVFF  88,FEC
0B62:  RETURN 0
0B64:  MOVF   FE9,W
0B66:  MOVWF  x75
0B68:  MOVLW  3B
0B6A:  MOVWF  x7C
0B6C:  MOVLW  9A
0B6E:  MOVWF  x7B
0B70:  MOVLW  CA
0B72:  MOVWF  x7A
0B74:  CLRF   x79
0B76:  MOVLW  0A
0B78:  MOVWF  x77
0B7A:  BSF    FD8.1
0B7C:  CLRF   FEA
0B7E:  MOVLW  71
0B80:  MOVWF  FE9
0B82:  MOVFF  74,80
0B86:  MOVFF  73,7F
0B8A:  MOVFF  72,7E
0B8E:  MOVFF  71,7D
0B92:  MOVFF  7C,84
0B96:  MOVFF  7B,83
0B9A:  MOVFF  7A,82
0B9E:  MOVFF  79,81
0BA2:  RCALL  0AD6
0BA4:  MOVF   01,W
0BA6:  MOVF   00,F
0BA8:  BNZ   0BC8
0BAA:  MOVF   x77,W
0BAC:  XORLW  01
0BAE:  BZ    0BC8
0BB0:  MOVF   x75,W
0BB2:  BZ    0BCA
0BB4:  ANDLW  0F
0BB6:  SUBWF  x77,W
0BB8:  BZ    0BBC
0BBA:  BC    0BD6
0BBC:  BTFSC  x75.7
0BBE:  BRA    0BD6
0BC0:  BTFSC  x75.6
0BC2:  BRA    0BCA
0BC4:  MOVLW  20
0BC6:  BRA    0BCC
0BC8:  CLRF   x75
0BCA:  MOVLW  30
0BCC:  ADDWF  00,F
0BCE:  MOVF   00,W
0BD0:  BTFSS  F9E.4
0BD2:  BRA    0BD0
0BD4:  MOVWF  FAD
0BD6:  BCF    FD8.1
0BD8:  MOVFF  7C,80
0BDC:  MOVFF  7B,7F
0BE0:  MOVFF  7A,7E
0BE4:  MOVFF  79,7D
0BE8:  CLRF   x84
0BEA:  CLRF   x83
0BEC:  CLRF   x82
0BEE:  MOVLW  0A
0BF0:  MOVWF  x81
0BF2:  RCALL  0AD6
0BF4:  MOVFF  03,7C
0BF8:  MOVFF  02,7B
0BFC:  MOVFF  01,7A
0C00:  MOVFF  00,79
0C04:  DECFSZ x77,F
0C06:  BRA    0B7A
0C08:  RETURN 0
0C0A:  MOVF   01,W
0C0C:  MOVFF  72,78
0C10:  MOVLW  64
0C12:  MOVWF  x79
0C14:  RCALL  090C
0C16:  MOVFF  00,72
0C1A:  MOVF   01,W
0C1C:  MOVLW  30
0C1E:  BNZ   0C2E
0C20:  BTFSS  x73.1
0C22:  BRA    0C3E
0C24:  BTFSC  x73.3
0C26:  BRA    0C3E
0C28:  BTFSC  x73.4
0C2A:  MOVLW  20
0C2C:  BRA    0C34
0C2E:  BCF    x73.3
0C30:  BCF    x73.4
0C32:  BSF    x73.0
0C34:  ADDWF  01,F
0C36:  MOVF   01,W
0C38:  BTFSS  F9E.4
0C3A:  BRA    0C38
0C3C:  MOVWF  FAD
0C3E:  MOVFF  72,78
0C42:  MOVLW  0A
0C44:  MOVWF  x79
0C46:  RCALL  090C
0C48:  MOVFF  00,72
0C4C:  MOVF   01,W
0C4E:  MOVLW  30
0C50:  BNZ   0C5E
0C52:  BTFSC  x73.3
0C54:  BRA    0C68
0C56:  BTFSS  x73.0
0C58:  BRA    0C68
0C5A:  BTFSC  x73.4
0C5C:  MOVLW  20
0C5E:  ADDWF  01,F
0C60:  MOVF   01,W
0C62:  BTFSS  F9E.4
0C64:  BRA    0C62
0C66:  MOVWF  FAD
0C68:  MOVLW  30
0C6A:  ADDWF  x72,F
0C6C:  MOVF   x72,W
0C6E:  BTFSS  F9E.4
0C70:  BRA    0C6E
0C72:  MOVWF  FAD
0C74:  RETURN 0
.................... 
.................... #list
.................... 
.................... #device ADC=10
.................... #device *=16
.................... #use delay(clock=16MHz)
*
062C:  CLRF   FEA
062E:  MOVLW  72
0630:  MOVWF  FE9
0632:  MOVF   FEF,W
0634:  BZ    0652
0636:  MOVLW  05
0638:  MOVWF  01
063A:  CLRF   00
063C:  DECFSZ 00,F
063E:  BRA    063C
0640:  DECFSZ 01,F
0642:  BRA    063A
0644:  MOVLW  2E
0646:  MOVWF  00
0648:  DECFSZ 00,F
064A:  BRA    0648
064C:  BRA    064E
064E:  DECFSZ FEF,F
0650:  BRA    0636
0652:  RETURN 0
.................... 
.................... /* hardware I2C port is slave and is connected to DCSWC bus */
.................... #use i2c(stream=STREAM_SLAVE,SLAVE, I2C1, FORCE_HW)
*
038E:  MOVF   FC9,W
0390:  MOVFF  8D,FC9
0394:  BSF    FC6.4
0396:  BCF    F9E.3
0398:  BTFSC  FC7.0
039A:  BRA    0398
039C:  CLRF   01
039E:  BTFSS  FC5.6
03A0:  INCF   01,F
03A2:  RETURN 0
.................... /* slave address set based on dip switch in init() */
.................... /* Linux / i2cdetect will use the CCS address >>1. So 0x34 becomes 0x1a */
.................... 
.................... 
.................... 
.................... #fuses HS
.................... #fuses NOPLLEN
.................... #fuses NOFCMEN
.................... #fuses NOIESO
.................... #fuses PUT
.................... #fuses BROWNOUT
.................... #fuses WDT4096
.................... #fuses NOHFOFST
.................... #fuses NOMCLR
.................... #fuses STVREN
.................... #fuses NOLVP
.................... #fuses NOXINST
.................... #fuses NODEBUG
.................... #fuses NOPROTECT
.................... #fuses NOWRT
.................... #fuses NOWRTC 
.................... #fuses NOWRTB
.................... #fuses NOWRTD
.................... #fuses NOEBTR
.................... #fuses NOEBTRB
.................... 
.................... #use standard_io(ALL)
.................... 
.................... #use rs232(UART1,stream=STREAM_FTDI,baud=9600,errors)	
*
08F4:  BTFSS  F9E.5
08F6:  BRA    08F4
08F8:  MOVFF  FAB,19
08FC:  MOVFF  FAE,01
0900:  BTFSS  19.1
0902:  BRA    0908
0904:  BCF    FAB.4
0906:  BSF    FAB.4
0908:  GOTO   0D90 (RETURN)
.................... 
.................... /* program config CRC of 0 and a serial_prefix of 'A' ... that will trigger a write default on first boot */
.................... #ROM 0xF00000 = { 0x00, 0x00, 0x40, 0x00 }
.................... 
.................... 
.................... 
.................... #define COUNT_B              PIN_C5
.................... #define COUNT_A              PIN_C4
.................... #define LED_A                PIN_C3
.................... #define PIC_ADDR_MSB         PIN_C6
.................... #define PIC_ADDR_LSB         PIN_C7
.................... #define SER_TO_PC            PIN_B7
.................... 
.................... #define INA_ALERT            PIN_A2
.................... #define I2C_SW_SDA           PIN_C0
.................... #define I2C_SW_SCL           PIN_C1
.................... #define TP2                  PIN_C2
.................... #define I2C_SDA              PIN_B4
.................... #define SER_FROM_PC          PIN_B5
.................... #define I2C_SCL              PIN_B6
.................... 
.................... 
.................... /* software I2C port is maser and is connected to two INA228A */
.................... #use i2c(stream=STREAM_MASTER, MASTER, FAST, FORCE_SW, scl=I2C_SW_SCL, sda=I2C_SW_SDA)
*
0698:  MOVLW  08
069A:  MOVWF  01
069C:  NOP   
069E:  BCF    F8B.1
06A0:  BCF    F94.1
06A2:  NOP   
06A4:  RLCF   x78,F
06A6:  BCF    F8B.0
06A8:  BTFSC  FD8.0
06AA:  BSF    F94.0
06AC:  BTFSS  FD8.0
06AE:  BCF    F94.0
06B0:  BSF    F94.1
06B2:  BTFSS  F82.1
06B4:  BRA    06B2
06B6:  DECFSZ 01,F
06B8:  BRA    069C
06BA:  NOP   
06BC:  BCF    F8B.1
06BE:  BCF    F94.1
06C0:  NOP   
06C2:  BSF    F94.0
06C4:  NOP   
06C6:  NOP   
06C8:  BSF    F94.1
06CA:  BTFSS  F82.1
06CC:  BRA    06CA
06CE:  CLRF   01
06D0:  NOP   
06D2:  BTFSC  F82.0
06D4:  BSF    01.0
06D6:  BCF    F8B.1
06D8:  BCF    F94.1
06DA:  BCF    F8B.0
06DC:  BCF    F94.0
06DE:  RETURN 0
06E0:  MOVLW  08
06E2:  MOVWF  x7A
06E4:  MOVFF  00,7B
06E8:  BSF    F94.0
06EA:  NOP   
06EC:  BSF    F94.1
06EE:  BTFSS  F82.1
06F0:  BRA    06EE
06F2:  BTFSC  F82.0
06F4:  BSF    FD8.0
06F6:  BTFSS  F82.0
06F8:  BCF    FD8.0
06FA:  RLCF   01,F
06FC:  NOP   
06FE:  BCF    F94.1
0700:  BCF    F8B.1
0702:  DECFSZ x7A,F
0704:  BRA    06E8
0706:  BSF    F94.0
0708:  NOP   
070A:  BCF    F8B.0
070C:  MOVF   x7B,W
070E:  BTFSS  FD8.2
0710:  BCF    F94.0
0712:  NOP   
0714:  BSF    F94.1
0716:  BTFSS  F82.1
0718:  BRA    0716
071A:  NOP   
071C:  BCF    F8B.1
071E:  BCF    F94.1
0720:  NOP   
0722:  BCF    F8B.0
0724:  BCF    F94.0
0726:  RETURN 0
.................... 
.................... 
.................... 
.................... #define INA228_A_ADDR      0x80
.................... #define INA228_B_ADDR      0x9a
.................... 
.................... 
.................... 
.................... 
.................... typedef struct {
.................... 	int8 serial_prefix;
.................... 	int16 serial_number;
.................... 	int16 startup_power_on_delay;
.................... } struct_config;
.................... 
.................... 
.................... 
.................... typedef struct {
.................... 	int32 vbus_a, vshunt_a;
.................... 	int32 vbus_b, vshunt_b;
.................... 
.................... 	int16 count_a_last_second, count_b_last_second;
.................... 
.................... 	int32 count_a_long;
.................... 	int32 count_b_long;
.................... 	int32 count_seconds_long;
.................... 
.................... 	int16 dietemp_a;
.................... 	int16 dietemp_b;
.................... } struct_current;
.................... 
.................... typedef struct {
.................... 	/* action flags */
.................... 	int1 now_millisecond;
.................... 
.................... 	int1 now_ina;    // query ina registers
.................... 
.................... 	/* timers */
.................... 	int8 led_on_a;
.................... } struct_time_keep;
.................... 
.................... /* global structures */
.................... struct_current current={0};
.................... struct_current next={0};
.................... struct_time_keep timers={0};
.................... 
.................... #include "ina228.c"
.................... #define INA228_REG_CONFIG       0x00  // 16 bits, configuration
.................... #define INA228_REG_ADC_CONFIG   0x01  // 16 bits, ADC configuration
.................... #define INA228_REG_SHUNT_CAL    0x02  // 16 bits, shunt calibration
.................... #define INA228_REG_SHUNT_TEMPCO 0x03  // 16 bits, shunt temperature coefficient
.................... #define INA228_REG_VSHUNT       0x04  // 24 bits, shunt voltage measurement
.................... #define INA228_REG_VBUS         0x05  // 24 bits, bus voltage measurement
.................... #define INA228_REG_DIETEMP      0x06  // 16 bits, temperature measurement
.................... #define INA228_REG_CURRENT      0x07  // 24 bits, current result
.................... #define INA228_REG_POWER        0x08  // 24 bits, power result 
.................... #define INA228_REG_ENERGY       0x09  // 40 bits, energy result
.................... #define INA228_REG_CHARGE       0x0a  // 40 bits, charge result
.................... #define INA228_REG_DIAG_ALRT    0x0b  // 16 bits, diagnostic flags and alert
.................... #define INA228_REG_SOVL         0x0c  // 16 bits, shunt overvoltage threshold
.................... #define INA228_REG_SUVL         0x0d  // 16 bits, shunt undervoltage threshold
.................... #define INA228_REG_BOVL         0x0e  // 16 bits, bus overvoltage threshold
.................... #define INA228_REG_BUVL         0x0f  // 16 bits, bus undervoltage threshold
.................... #define INA228_REG_TEMP_LIMIT   0x10  // 16 bits, temperature over-limit threshold
.................... #define INA228_REG_PWR_LIMIT    0x11  // 16 bits, power over-limit threshold
.................... #define INA228_REG_MFG_ID       0x3e  // 16 bits, manufacturer ID
.................... #define INA228_REG_DEVICE_ID    0x3f  // 16 bits, device ID
.................... 
.................... #define INA228_I2C_WRITE        0x00
.................... #define INA228_I2C_READ         0x01 
.................... 
.................... 
.................... int16 ina228_read16(int8 i2c_address, int8 regaddr) {
.................... 	int16 data;
.................... 
.................... 	i2c_start(STREAM_MASTER);
*
07C6:  BSF    F94.0
07C8:  NOP   
07CA:  BSF    F94.1
07CC:  NOP   
07CE:  BCF    F8B.0
07D0:  BCF    F94.0
07D2:  NOP   
07D4:  BCF    F8B.1
07D6:  BCF    F94.1
.................... 	delay_us(15);
07D8:  MOVLW  13
07DA:  MOVWF  00
07DC:  DECFSZ 00,F
07DE:  BRA    07DC
07E0:  BRA    07E2
.................... 	i2c_write(STREAM_MASTER,i2c_address);
07E2:  MOVFF  71,78
07E6:  RCALL  0698
.................... 	i2c_write(STREAM_MASTER,regaddr);
07E8:  MOVFF  72,78
07EC:  RCALL  0698
.................... 	i2c_start(STREAM_MASTER);
07EE:  BSF    F94.0
07F0:  NOP   
07F2:  BSF    F94.1
07F4:  NOP   
07F6:  BTFSS  F82.1
07F8:  BRA    07F6
07FA:  BCF    F8B.0
07FC:  BCF    F94.0
07FE:  NOP   
0800:  BCF    F8B.1
0802:  BCF    F94.1
.................... 	delay_us(15);
0804:  MOVLW  13
0806:  MOVWF  00
0808:  DECFSZ 00,F
080A:  BRA    0808
080C:  BRA    080E
.................... 	i2c_write(STREAM_MASTER,i2c_address | INA228_I2C_READ);  // read cycle
080E:  MOVF   x71,W
0810:  IORLW  01
0812:  MOVWF  x75
0814:  MOVWF  x78
0816:  RCALL  0698
.................... 	data=make16(i2c_read(STREAM_MASTER,1),i2c_read(STREAM_MASTER,0));                                 
0818:  MOVLW  01
081A:  MOVWF  00
081C:  RCALL  06E0
081E:  MOVFF  01,75
0822:  CLRF   00
0824:  RCALL  06E0
0826:  MOVFF  75,74
082A:  MOVFF  01,73
.................... 	i2c_stop(STREAM_MASTER);
082E:  BCF    F94.0
0830:  NOP   
0832:  BSF    F94.1
0834:  BTFSS  F82.1
0836:  BRA    0834
0838:  NOP   
083A:  BRA    083C
083C:  NOP   
083E:  BSF    F94.0
0840:  NOP   
.................... 
.................... 	return data;
0842:  MOVFF  73,01
0846:  MOVFF  74,02
084A:  RETURN 0
.................... }
.................... 
.................... int32 ina228_read24(int8 i2c_address, int8 regaddr) {
.................... 	int32 data;
.................... 
.................... 	i2c_start(STREAM_MASTER);
*
0728:  BSF    F94.0
072A:  NOP   
072C:  BSF    F94.1
072E:  NOP   
0730:  BCF    F8B.0
0732:  BCF    F94.0
0734:  NOP   
0736:  BCF    F8B.1
0738:  BCF    F94.1
.................... 	delay_us(15);
073A:  MOVLW  13
073C:  MOVWF  00
073E:  DECFSZ 00,F
0740:  BRA    073E
0742:  BRA    0744
.................... 	i2c_write(STREAM_MASTER,i2c_address);
0744:  MOVFF  71,78
0748:  RCALL  0698
.................... 	i2c_write(STREAM_MASTER,regaddr);
074A:  MOVFF  72,78
074E:  RCALL  0698
.................... 	i2c_start(STREAM_MASTER);
0750:  BSF    F94.0
0752:  NOP   
0754:  BSF    F94.1
0756:  NOP   
0758:  BTFSS  F82.1
075A:  BRA    0758
075C:  BCF    F8B.0
075E:  BCF    F94.0
0760:  NOP   
0762:  BCF    F8B.1
0764:  BCF    F94.1
.................... 	delay_us(15);
0766:  MOVLW  13
0768:  MOVWF  00
076A:  DECFSZ 00,F
076C:  BRA    076A
076E:  BRA    0770
.................... 	i2c_write(STREAM_MASTER,i2c_address | INA228_I2C_READ);  // read cycle
0770:  MOVF   x71,W
0772:  IORLW  01
0774:  MOVWF  x77
0776:  MOVWF  x78
0778:  RCALL  0698
.................... 	data=make32(0,i2c_read(STREAM_MASTER,1),i2c_read(STREAM_MASTER,1),i2c_read(STREAM_MASTER,0));
077A:  MOVLW  01
077C:  MOVWF  00
077E:  RCALL  06E0
0780:  MOVFF  01,77
0784:  MOVLW  01
0786:  MOVWF  00
0788:  RCALL  06E0
078A:  MOVFF  01,78
078E:  CLRF   00
0790:  RCALL  06E0
0792:  CLRF   x76
0794:  MOVFF  77,75
0798:  MOVFF  78,74
079C:  MOVFF  01,73
.................... 	i2c_stop(STREAM_MASTER);
07A0:  BCF    F94.0
07A2:  NOP   
07A4:  BSF    F94.1
07A6:  BTFSS  F82.1
07A8:  BRA    07A6
07AA:  NOP   
07AC:  BRA    07AE
07AE:  NOP   
07B0:  BSF    F94.0
07B2:  NOP   
.................... 
.................... 	return data;
07B4:  MOVFF  73,00
07B8:  MOVFF  74,01
07BC:  MOVFF  75,02
07C0:  MOVFF  76,03
07C4:  RETURN 0
.................... }
.................... 
.................... void ina228_write16(int8 i2c_address, int8 regaddr, int16 value) {
.................... 	i2c_start(STREAM_MASTER);
.................... 	delay_us(15);                                                 
.................... 	i2c_write(STREAM_MASTER,i2c_address); // write cycle                       
.................... 	i2c_write(STREAM_MASTER,regaddr);  // write cycle         
.................... 	i2c_write(STREAM_MASTER,make8(value,1));
.................... 	i2c_write(STREAM_MASTER,make8(value,0));
.................... 	i2c_stop(STREAM_MASTER);
.................... }
.................... 
.................... void ina228_init(int8 i2c_address) {
.................... 	ina228_write16(i2c_address,INA228_REG_CONFIG,0b1000000000000000);
.................... }
.................... 
.................... #include "i2c_handler_dcswc_module_voltage_current_counter.c"
.................... #include "registers_dcswc_module_voltage_current_counter.h"
.................... /* 32 bit INA228 bus and shunt voltages */
.................... #define I2C_REG_VBUS_A_MSW                    0
.................... #define I2C_REG_VBUS_A_LSW                    1
.................... #define I2C_REG_VSHUNT_A_MSW                  2
.................... #define I2C_REG_VSHUNT_A_LSW                  3
.................... 
.................... #define I2C_REG_VBUS_B_MSW                    4
.................... #define I2C_REG_VBUS_B_LSW                    5
.................... #define I2C_REG_VSHUNT_B_MSW                  6
.................... #define I2C_REG_VSHUNT_B_LSW                  7
.................... 
.................... /* 16 bit count of last (not current) second */
.................... #define I2C_REG_COUNT_A_LAST_SECOND           8
.................... #define I2C_REG_COUNT_B_LAST_SECOND           9
.................... 
.................... /* 32 bit count since reset */
.................... #define I2C_REG_COUNT_A_LONG_MSW              10
.................... #define I2C_REG_COUNT_A_LONG_LSW              11
.................... #define I2C_REG_COUNT_B_LONG_MSW              12
.................... #define I2C_REG_COUNT_B_LONG_LSW              13
.................... 
.................... /* 32 bit seconds since count reset */
.................... #define I2C_REG_COUNT_LONG_SECONDS_MSW        14
.................... #define I2C_REG_COUNT_LONG_SECONDS_LSW        15
.................... 
.................... /* 16 bit INA228 die temperatures */
.................... #define I2C_REG_DIETEMP_A                     16
.................... #define I2C_REG_DIETEMP_B                     17
.................... 
.................... 
.................... 
.................... void write_i2c(int8 address, int16 value) {
.................... 	
.................... 	switch ( address ) {
*
01BA:  MOVF   x8E,W
01BC:  XORLW  0E
01BE:  BZ    01C6
01C0:  XORLW  01
01C2:  BZ    01C6
01C4:  BRA    01DE
.................... 		/* write anything to either of these addresses and we reset the long counter */
.................... 		case I2C_REG_COUNT_LONG_SECONDS_MSW:
.................... 		case I2C_REG_COUNT_LONG_SECONDS_LSW:
.................... 			current.count_a_long=0;
01C6:  CLRF   31
01C8:  CLRF   30
01CA:  CLRF   2F
01CC:  CLRF   2E
.................... 			current.count_b_long=0;
01CE:  CLRF   35
01D0:  CLRF   34
01D2:  CLRF   33
01D4:  CLRF   32
.................... 			current.count_seconds_long=0;
01D6:  CLRF   39
01D8:  CLRF   38
01DA:  CLRF   37
01DC:  CLRF   36
.................... 			break;
.................... 
....................  
.................... 		default:
.................... 			/* do nothing */
.................... 	}
01DE:  GOTO   041E (RETURN)
.................... 
.................... }
.................... 
.................... 
.................... int16 map_i2c(int8 addr) {
.................... 	static int16 lsw=0xffff;
.................... 
.................... 	timers.led_on_a=100;
01E2:  MOVLW  64
01E4:  MOVWF  x63
.................... 
.................... 
.................... 
.................... 	switch ( addr ) {
01E6:  MOVF   x8D,W
01E8:  BZ    0244
01EA:  XORLW  01
01EC:  BZ    0262
01EE:  XORLW  03
01F0:  BZ    026C
01F2:  XORLW  01
01F4:  BZ    028A
01F6:  XORLW  07
01F8:  BZ    0294
01FA:  XORLW  01
01FC:  BZ    02B2
01FE:  XORLW  03
0200:  BZ    02BC
0202:  XORLW  01
0204:  BZ    02DA
0206:  XORLW  0F
0208:  BTFSC  FD8.2
020A:  BRA    02E4
020C:  XORLW  01
020E:  BTFSC  FD8.2
0210:  BRA    02EE
0212:  XORLW  03
0214:  BTFSC  FD8.2
0216:  BRA    02F8
0218:  XORLW  01
021A:  BTFSC  FD8.2
021C:  BRA    0316
021E:  XORLW  07
0220:  BTFSC  FD8.2
0222:  BRA    0320
0224:  XORLW  01
0226:  BTFSC  FD8.2
0228:  BRA    033E
022A:  XORLW  03
022C:  BTFSC  FD8.2
022E:  BRA    0348
0230:  XORLW  01
0232:  BTFSC  FD8.2
0234:  BRA    0366
0236:  XORLW  1F
0238:  BTFSC  FD8.2
023A:  BRA    0370
023C:  XORLW  01
023E:  BTFSC  FD8.2
0240:  BRA    037A
0242:  BRA    0384
.................... 		/* 32 bit variables have the most significant word read first and that sets the
.................... 		   least sinificant word which can be read next. _LSW registers are only valid if
.................... 		   they are preceeded by a read on the matching _MSW register
.................... 		 */
.................... 		case I2C_REG_VBUS_A_MSW:
.................... 			lsw = make16(make8(current.vbus_a,1),make8(current.vbus_a,0));
0244:  MOVFF  1B,65
0248:  MOVFF  1A,64
.................... 			return (int16) make16(make8(current.vbus_a,3),make8(current.vbus_a,2));
024C:  MOVFF  1D,8E
0250:  MOVFF  1C,8F
0254:  MOVFF  1D,03
0258:  MOVFF  1C,01
025C:  MOVFF  1D,02
0260:  BRA    038A
.................... 		case I2C_REG_VBUS_A_LSW:
.................... 			return (int16) lsw;
0262:  MOVFF  64,01
0266:  MOVFF  65,02
026A:  BRA    038A
.................... 		case I2C_REG_VSHUNT_A_MSW:
.................... 			lsw = make16(make8(current.vshunt_a,1),make8(current.vshunt_a,0));
026C:  MOVFF  1F,65
0270:  MOVFF  1E,64
.................... 			return (int16) make16(make8(current.vshunt_a,3),make8(current.vshunt_a,2));
0274:  MOVFF  21,8E
0278:  MOVFF  20,8F
027C:  MOVFF  21,03
0280:  MOVFF  20,01
0284:  MOVFF  21,02
0288:  BRA    038A
.................... 		case I2C_REG_VSHUNT_A_LSW:
.................... 			return (int16) lsw;    
028A:  MOVFF  64,01
028E:  MOVFF  65,02
0292:  BRA    038A
.................... 
.................... 		case I2C_REG_VBUS_B_MSW:
.................... 			lsw = make16(make8(current.vbus_a,1),make8(current.vbus_a,0));
0294:  MOVFF  1B,65
0298:  MOVFF  1A,64
.................... 			return (int16) make16(make8(current.vbus_b,3),make8(current.vbus_b,2));
029C:  MOVFF  25,8E
02A0:  MOVFF  24,8F
02A4:  MOVFF  25,03
02A8:  MOVFF  24,01
02AC:  MOVFF  25,02
02B0:  BRA    038A
.................... 		case I2C_REG_VBUS_B_LSW:
.................... 			return (int16) lsw;
02B2:  MOVFF  64,01
02B6:  MOVFF  65,02
02BA:  BRA    038A
.................... 		case I2C_REG_VSHUNT_B_MSW:
.................... 			lsw = make16(make8(current.vshunt_b,1),make8(current.vshunt_b,0));
02BC:  MOVFF  27,65
02C0:  MOVFF  26,64
.................... 			return (int16) make16(make8(current.vshunt_b,3),make8(current.vshunt_b,2));
02C4:  MOVFF  29,8E
02C8:  MOVFF  28,8F
02CC:  MOVFF  29,03
02D0:  MOVFF  28,01
02D4:  MOVFF  29,02
02D8:  BRA    038A
.................... 		case I2C_REG_VSHUNT_B_LSW:
.................... 			return (int16) lsw;    
02DA:  MOVFF  64,01
02DE:  MOVFF  65,02
02E2:  BRA    038A
.................... 
.................... 
.................... 		case I2C_REG_COUNT_A_LAST_SECOND:
.................... 			return (int16) current.count_a_last_second;
02E4:  MOVFF  2A,01
02E8:  MOVFF  2B,02
02EC:  BRA    038A
.................... 		case I2C_REG_COUNT_B_LAST_SECOND:
.................... 			return (int16) current.count_b_last_second;
02EE:  MOVFF  2C,01
02F2:  MOVFF  2D,02
02F6:  BRA    038A
.................... 
.................... 		case I2C_REG_COUNT_A_LONG_MSW:
.................... 			lsw = make16(make8(current.count_a_long,1),make8(current.count_a_long,0));
02F8:  MOVFF  2F,65
02FC:  MOVFF  2E,64
.................... 			return (int16) make16(make8(current.count_a_long,3),make8(current.count_a_long,2));
0300:  MOVFF  31,8E
0304:  MOVFF  30,8F
0308:  MOVFF  31,03
030C:  MOVFF  30,01
0310:  MOVFF  31,02
0314:  BRA    038A
.................... 		case I2C_REG_COUNT_A_LONG_LSW:
.................... 			return (int16) lsw;
0316:  MOVFF  64,01
031A:  MOVFF  65,02
031E:  BRA    038A
.................... 		case I2C_REG_COUNT_B_LONG_MSW:
.................... 			lsw = make16(make8(current.count_b_long,1),make8(current.count_b_long,0));
0320:  MOVFF  33,65
0324:  MOVFF  32,64
.................... 			return (int16) make16(make8(current.count_b_long,3),make8(current.count_b_long,2));
0328:  MOVFF  35,8E
032C:  MOVFF  34,8F
0330:  MOVFF  35,03
0334:  MOVFF  34,01
0338:  MOVFF  35,02
033C:  BRA    038A
.................... 		case I2C_REG_COUNT_B_LONG_LSW:
.................... 			return (int16) lsw;
033E:  MOVFF  64,01
0342:  MOVFF  65,02
0346:  BRA    038A
.................... 		case I2C_REG_COUNT_LONG_SECONDS_MSW:
.................... 			lsw = make16(make8(current.count_seconds_long,1),make8(current.count_seconds_long,0));
0348:  MOVFF  37,65
034C:  MOVFF  36,64
.................... 			return (int16) make16(make8(current.count_seconds_long,3),make8(current.count_seconds_long,2));
0350:  MOVFF  39,8E
0354:  MOVFF  38,8F
0358:  MOVFF  39,03
035C:  MOVFF  38,01
0360:  MOVFF  39,02
0364:  BRA    038A
.................... 		case I2C_REG_COUNT_LONG_SECONDS_LSW:
.................... 			return (int16) lsw;
0366:  MOVFF  64,01
036A:  MOVFF  65,02
036E:  BRA    038A
.................... 
.................... 		case I2C_REG_DIETEMP_A:
.................... 			return (int16) current.dietemp_a;
0370:  MOVFF  3A,01
0374:  MOVFF  3B,02
0378:  BRA    038A
.................... 		case I2C_REG_DIETEMP_B:
.................... 			return (int16) current.dietemp_b;
037A:  MOVFF  3C,01
037E:  MOVFF  3D,02
0382:  BRA    038A
.................... 
.................... 		/* we should have range checked, and never gotten here ... or read unimplemented (future) register */
.................... 		default: return (int16) addr;
0384:  MOVFF  8D,01
0388:  CLRF   02
.................... 	}
038A:  GOTO   0432 (RETURN)
.................... 
.................... }
.................... 
.................... 
.................... 
.................... #include "interrupt_dcswc_module_voltage_current_counter.c"
.................... #int_timer2
.................... void isr_timer2() {
.................... 	static int16 ticks=0;
.................... 	static short count_a_last=0;
.................... 	static short count_b_last=0;
.................... 	short count_a_now;
.................... 	short count_b_now;
.................... 
.................... 
.................... 	/* external input counting */
.................... 	count_a_now=input(COUNT_A);
*
00BA:  BSF    F94.4
00BC:  BCF    x8A.0
00BE:  BTFSC  F82.4
00C0:  BSF    x8A.0
.................... 	if ( 0 == count_a_now && 1 == count_a_last ) {
00C2:  BTFSC  x8A.0
00C4:  BRA    00D0
00C6:  BTFSS  x68.0
00C8:  BRA    00D0
.................... 		next.count_a_last_second++;
00CA:  INCF   4E,F
00CC:  BTFSC  FD8.2
00CE:  INCF   4F,F
.................... 	}
.................... 	count_a_last=count_a_now;
00D0:  BCF    x68.0
00D2:  BTFSC  x8A.0
00D4:  BSF    x68.0
.................... 
.................... 	count_b_now=input(COUNT_B);
00D6:  BSF    F94.5
00D8:  BCF    x8A.1
00DA:  BTFSC  F82.5
00DC:  BSF    x8A.1
.................... 	if ( 0 == count_b_now && 1 == count_b_last ) {
00DE:  BTFSC  x8A.1
00E0:  BRA    00EC
00E2:  BTFSS  x68.1
00E4:  BRA    00EC
.................... 		next.count_b_last_second++;
00E6:  INCF   50,F
00E8:  BTFSC  FD8.2
00EA:  INCF   51,F
.................... 	}
.................... 	count_b_last=count_b_now;
00EC:  BCF    x68.1
00EE:  BTFSC  x8A.1
00F0:  BSF    x68.1
.................... 
.................... 
.................... 	/* timing */
.................... 
.................... 	timers.now_millisecond=1;
00F2:  BSF    x62.0
.................... 
.................... 	ticks++;
00F4:  INCF   x66,F
00F6:  BTFSC  FD8.2
00F8:  INCF   x67,F
.................... 	if ( 500 == ticks ) {
00FA:  MOVF   x66,W
00FC:  SUBLW  F4
00FE:  BNZ   0108
0100:  DECFSZ x67,W
0102:  BRA    0108
.................... 		timers.now_ina=1;
0104:  BSF    x62.1
.................... 	} else if ( 1000 == ticks ) {
0106:  BRA    01B0
0108:  MOVF   x66,W
010A:  SUBLW  E8
010C:  BNZ   01B0
010E:  MOVF   x67,W
0110:  SUBLW  03
0112:  BNZ   01B0
.................... //		timers.now_strobe=1;
.................... 		output_high(TP2);
0114:  BCF    F94.2
0116:  BSF    F8B.2
.................... 
.................... 		current.vbus_a=next.vbus_a;
0118:  MOVFF  41,1D
011C:  MOVFF  40,1C
0120:  MOVFF  3F,1B
0124:  MOVFF  3E,1A
.................... 		current.vshunt_a=next.vshunt_a;
0128:  MOVFF  45,21
012C:  MOVFF  44,20
0130:  MOVFF  43,1F
0134:  MOVFF  42,1E
.................... 		current.dietemp_a=next.dietemp_a;	
0138:  MOVFF  5F,3B
013C:  MOVFF  5E,3A
.................... 
.................... 		current.vbus_b=next.vbus_b;
0140:  MOVFF  49,25
0144:  MOVFF  48,24
0148:  MOVFF  47,23
014C:  MOVFF  46,22
.................... 		current.vshunt_b=next.vshunt_b;
0150:  MOVFF  4D,29
0154:  MOVFF  4C,28
0158:  MOVFF  4B,27
015C:  MOVFF  4A,26
.................... 		current.dietemp_b=next.dietemp_b;
0160:  MOVFF  61,3D
0164:  MOVFF  60,3C
.................... 
.................... 		current.count_a_last_second=next.count_a_last_second;
0168:  MOVFF  4F,2B
016C:  MOVFF  4E,2A
.................... 
.................... 		current.count_b_last_second=next.count_b_last_second;	
0170:  MOVFF  51,2D
0174:  MOVFF  50,2C
.................... 
.................... 		current.count_a_long += current.count_a_last_second;
0178:  MOVF   2A,W
017A:  ADDWF  2E,F
017C:  MOVF   2B,W
017E:  ADDWFC 2F,F
0180:  MOVLW  00
0182:  ADDWFC 30,F
0184:  ADDWFC 31,F
.................... 		current.count_b_long += current.count_b_last_second;
0186:  MOVF   2C,W
0188:  ADDWF  32,F
018A:  MOVF   2D,W
018C:  ADDWFC 33,F
018E:  MOVLW  00
0190:  ADDWFC 34,F
0192:  ADDWFC 35,F
.................... 	
.................... 		current.count_seconds_long++;
0194:  MOVLW  01
0196:  ADDWF  36,F
0198:  BTFSC  FD8.0
019A:  INCF   37,F
019C:  BTFSC  FD8.2
019E:  INCF   38,F
01A0:  BTFSC  FD8.2
01A2:  INCF   39,F
.................... 
.................... 		/* reset our counters */
.................... 		next.count_a_last_second=0;
01A4:  CLRF   4F
01A6:  CLRF   4E
.................... 		next.count_b_last_second=0;
01A8:  CLRF   51
01AA:  CLRF   50
.................... 
.................... 		ticks=0;
01AC:  CLRF   x67
01AE:  CLRF   x66
.................... 	}
.................... 
.................... 	output_low(TP2);
01B0:  BCF    F94.2
01B2:  BCF    F8B.2
.................... }
.................... 
.................... 
.................... 
.................... #if 1
.................... 
.................... 	/*
.................... .................... 	state = i2c_isr_state();
.................... *
.................... 025A:  BTFSC  FC7.5	// if data, go to 0264
.................... 025C:  BRA    0264
.................... 
.................... 025E:  CLRF   x9D	// set i=0 
.................... 
.................... 0260:  BTFSC  FC7.2	// if read, then set high bit of i 
.................... 0262:  BSF    x9D.7
.................... 
.................... 0264:  MOVF   x9D,W // increment i and put result in state
.................... 0266:  INCF   x9D,F
.................... 0268:  MOVWF  xC7
.................... 
.................... 	x9D is static variable for state
.................... 	xC7 is returned value of state
.................... */
.................... 
.................... /*
.................... .................... 	state = i2c_isr_state();
.................... 025A:  BTFSC  FC7.5 // bit test SSPSTAT.5, skip instruction below if DATA/!ADDRESS is indicating address
.................... 025C:  BRA    0264  // goto 0264
.................... 
.................... 025E:  CLRF   x9F   // set x9F to 0
.................... 0260:  BTFSC  FC7.2 // bit test SSPSTAT.2, skip instruction below if READ/!WRITE is indicating write
.................... 0262:  BSF    x9F.7 // set the high bit of x9F
.................... 
.................... 0264:  MOVF   x9F,W	// move x9F to W register
.................... 0266:  INCF   x9F,F // increment x9F
.................... 0268:  MOVWF  x9A	// move W to x9A (ie move x9F to x9A)
.................... 
.................... that makes 9a the value of state that is used by the program and x9F as a static state variable
.................... */
.................... 
.................... 
01B4:  BCF    F9E.1
01B6:  GOTO   006C
.................... #byte SSPSTAT=GETENV("SFR:SSPSTAT")
.................... #INT_SSP
.................... void ssp_interrupt () {
.................... 	static int8 sstate;
.................... 	int8 state;
.................... 	int8 incoming;
.................... 	static int16 lastValue;
.................... 	static int8 lastMSB;
.................... 	static int8 address;
.................... 
.................... 
.................... //	state = i2c_isr_state(STREAM_SLAVE);
.................... 
.................... 
.................... 	/* 
.................... 	our implementation of i2c_isr_state() that won't overflow and switch states
.................... 
.................... 	but it will quit counting at 127 bytes. 
.................... 
.................... 	If more bytes are needed, external counting variables can be used or the size of state can be made larger
.................... 	*/
.................... 
.................... 
.................... 	if ( ! bit_test(SSPSTAT,5) ) {
*
03A4:  BTFSC  FC7.5
03A6:  BRA    03B0
.................... 		/* address */
.................... 		sstate=0;
03A8:  CLRF   x69
.................... 
.................... 		if ( bit_test(SSPSTAT,2) ) {
03AA:  BTFSS  FC7.2
03AC:  BRA    03B0
.................... 			/* set high bit if read */
.................... 			bit_set(sstate,7);
03AE:  BSF    x69.7
.................... 		}
.................... 	} else {
.................... 		/* data */
.................... 	}
.................... 
.................... 	/* state variable used below is not incremented */
.................... 	state=sstate;
03B0:  MOVFF  69,8A
.................... 
.................... 	/* increment the state counter for next pass through unless it will overflow us into another state */
.................... 	if ( sstate != 0x7f && sstate != 0xff) {
03B4:  MOVF   x69,W
03B6:  SUBLW  7F
03B8:  BZ    03C2
03BA:  INCFSZ x69,W
03BC:  BRA    03C0
03BE:  BRA    03C2
.................... 		sstate++;
03C0:  INCF   x69,F
.................... 	}
.................... 
.................... 	
.................... 	/* i2c_isr_state() return an 8 bit int
.................... 		0 - Address match received with R/W bit clear, perform i2c_read( ) to read the I2C address.
.................... 
.................... 		1-0x7F - Master has written data; i2c_read() will immediately return the data
.................... 
.................... 		0x80 - Address match received with R/W bit set; perform i2c_read( ) to read the I2C address,
.................... 		and use i2c_write( ) to pre-load the transmit buffer for the next transaction (next I2C read
.................... 		performed by master will read this byte).
.................... 
.................... 		0x81-0xFF - Transmission completed and acknowledged; respond with i2c_write() to pre-load
.................... 		the transmit buffer for the next transition (the next I2C read performed by master will read this
.................... 		byte).
.................... 
.................... 		Function:
.................... 		Returns the state of I2C communications in I2C slave mode after an SSP interrupt. The return
.................... 		value increments with each byte received or sent.
.................... 		If 0x00 or 0x80 is returned, an i2C_read( ) needs to be performed to read the I2C address that
.................... 		was sent (it will match the address configured by #USE I2C so this value can be ignored)
.................... 	*/
.................... 
.................... 	if ( state <= 0x80 ) {                      
03C2:  MOVF   x8A,W
03C4:  SUBLW  80
03C6:  BNC   041E
.................... 		/* I2C master is sending us data */
.................... 		if ( 0x80 == state ) {
03C8:  MOVF   x8A,W
03CA:  SUBLW  80
03CC:  BNZ   03D4
.................... 			/* i2c_read(2) casues the function to read the SSPBUF without releasing the clock */
.................... 			incoming = i2c_read(STREAM_SLAVE,2);
03CE:  MOVFF  FC9,8B
.................... 		} else {
03D2:  BRA    03E0
.................... 			incoming = i2c_read(STREAM_SLAVE);
03D4:  BCF    FC6.6
03D6:  BTFSS  FC7.0
03D8:  BRA    03D6
03DA:  MOVF   FC9,W
03DC:  BSF    FC6.4
03DE:  MOVWF  x8B
.................... 		}
.................... 
.................... 		if ( 1 == state ) {      
03E0:  DECFSZ x8A,W
03E2:  BRA    03EA
.................... 			/* first byte is address */                
.................... 			address = incoming;
03E4:  MOVFF  8B,6D
.................... 		} else if ( state >= 2 && 0x80 != state ) {
03E8:  BRA    041E
03EA:  MOVF   x8A,W
03EC:  SUBLW  01
03EE:  BC    041E
03F0:  MOVF   x8A,W
03F2:  SUBLW  80
03F4:  BZ    041E
.................... 			/* received byte is data */
.................... 		
.................... 			/* save MSB and we'll process it on next */
.................... 			if ( 2 == state ) {
03F6:  MOVF   x8A,W
03F8:  SUBLW  02
03FA:  BNZ   0402
.................... 				lastMSB=incoming;
03FC:  MOVFF  8B,6C
.................... 			} else if ( 3 == state ) {
0400:  BRA    041E
0402:  MOVF   x8A,W
0404:  SUBLW  03
0406:  BNZ   041E
.................... 				/* 16 bit value made of previous byte and this byte */
.................... 				write_i2c(address,make16(lastMSB,incoming));
0408:  MOVFF  6C,8D
040C:  MOVFF  8B,8C
0410:  MOVFF  6D,8E
0414:  MOVFF  6C,90
0418:  MOVFF  8B,8F
041C:  BRA    01BA
.................... 			}
.................... 		}
.................... 	}
.................... 
.................... 
.................... 	if ( state >= 0x80 ) {
041E:  MOVF   x8A,W
0420:  SUBLW  7F
0422:  BC    0452
.................... 		/* I2C master is requesting data from us */
.................... 
.................... 		if ( ! bit_test(address,0) ) {
0424:  BTFSC  x6D.0
0426:  BRA    0446
.................... 			/* read 16 bit register (register address half of I2C address) on even address */
.................... 			lastValue=map_i2c(address>>1);
0428:  BCF    FD8.0
042A:  RRCF   x6D,W
042C:  MOVWF  x8C
042E:  MOVWF  x8D
0430:  BRA    01E2
0432:  MOVFF  02,6B
0436:  MOVFF  01,6A
.................... 
.................... 			/* send the MSB */
.................... 			i2c_write(STREAM_SLAVE,make8(lastValue,1));
043A:  MOVFF  6B,8C
043E:  MOVFF  6B,8D
0442:  RCALL  038E
.................... 		} else {
0444:  BRA    0450
.................... 			/* send LSB of 16 bit register on odd address */
.................... 			i2c_write(STREAM_SLAVE,make8(lastValue,0));
0446:  MOVFF  6A,8C
044A:  MOVFF  6A,8D
044E:  RCALL  038E
.................... 		}
.................... 
.................... 		address++;
0450:  INCF   x6D,F
.................... 	}
.................... 
.................... 	/* reset watchdog timer */
.................... //	timers.read_watchdog_seconds=0;
.................... }
0452:  BCF    F9E.3
0454:  GOTO   006C
.................... #endif
.................... 
.................... 
.................... int8 read_dip_switch(void) {
.................... 	/* nomenclature is backwards on netlist. We actually want LSB on top */
.................... 	return ( ! input(PIC_ADDR_LSB)<<1 ) | ( ! input(PIC_ADDR_MSB) );
*
05CC:  BSF    F94.7
05CE:  MOVLW  00
05D0:  BTFSS  F82.7
05D2:  MOVLW  01
05D4:  MOVWF  00
05D6:  BCF    FD8.0
05D8:  RLCF   00,W
05DA:  MOVWF  x71
05DC:  BSF    F94.6
05DE:  MOVLW  00
05E0:  BTFSS  F82.6
05E2:  MOVLW  01
05E4:  IORWF  x71,W
05E6:  MOVWF  01
05E8:  RETURN 0
.................... }
.................... 
.................... void init(void) {
.................... 	setup_vref(VREF_OFF);
05EA:  CLRF   FBA
.................... 	setup_dac(DAC_OFF);
05EC:  CLRF   FBB
.................... 	setup_adc(ADC_OFF);
05EE:  BCF    FC2.0
.................... 	setup_adc_ports(NO_ANALOGS);
05F0:  MOVLW  00
05F2:  MOVWF  F7E
05F4:  BCF    FC1.0
05F6:  BCF    FC1.1
05F8:  BCF    FC1.2
05FA:  BCF    FC1.3
05FC:  MOVWF  F7F
.................... 
.................... 
.................... 
.................... 	set_tris_a    (0b00111111);
05FE:  MOVLW  3F
0600:  MOVWF  F92
.................... 	port_a_pullups(0b00110000);
0602:  MOVLW  30
0604:  MOVWF  F77
0606:  BCF    FF1.7
.................... //                   76543210
.................... 
.................... 	set_tris_b    (0b01110000);
0608:  MOVLW  70
060A:  MOVWF  F93
.................... 	port_b_pullups(0b00000000);
060C:  CLRF   F78
.................... //                   76543210
.................... 
.................... 	set_tris_c    (0b11110011);
060E:  MOVLW  F3
0610:  MOVWF  F94
.................... //                   76543210
.................... 
.................... 
.................... 	/* data structure initialization */
.................... 	/* all initialized to 0 on declaration. Just do this if need non-zero */
.................... 
.................... 
.................... 	/* one periodic interrupt @ 1mS. Generated from system 16 MHz clock */
.................... 	/* prescale=16, match=249, postscale=1. Match is 249 because when match occurs, one cycle is lost */
.................... 	setup_timer_2(T2_DIV_BY_16,249,1);
0612:  MOVLW  00
0614:  IORLW  06
0616:  MOVWF  FCA
0618:  MOVLW  F9
061A:  MOVWF  FCB
.................... 
.................... 	enable_interrupts(INT_TIMER2);
061C:  BSF    F9D.1
.................... 
.................... 	/* set I2C slave address, which is always an even number */
.................... 	i2c_slaveaddr(0x36 + (read_dip_switch()<<1) );
061E:  RCALL  05CC
0620:  BCF    FD8.0
0622:  RLCF   01,W
0624:  ADDLW  36
0626:  MOVWF  FC8
0628:  GOTO   0D0C (RETURN)
.................... 
.................... }
.................... 
.................... 
.................... void action_now_ina(void) {
.................... 	timers.now_ina=0;
*
084C:  BCF    x62.1
.................... 
.................... 	/* sample INA228 at middle of 1 second window */
.................... 	next.vbus_a=ina228_read24(INA228_A_ADDR,INA228_REG_VBUS);
084E:  MOVLW  80
0850:  MOVWF  x71
0852:  MOVLW  05
0854:  MOVWF  x72
0856:  RCALL  0728
0858:  MOVFF  03,41
085C:  MOVFF  02,40
0860:  MOVFF  01,3F
0864:  MOVFF  00,3E
.................... 	next.vshunt_a=ina228_read24(INA228_A_ADDR,INA228_REG_VSHUNT);
0868:  MOVLW  80
086A:  MOVWF  x71
086C:  MOVLW  04
086E:  MOVWF  x72
0870:  RCALL  0728
0872:  MOVFF  03,45
0876:  MOVFF  02,44
087A:  MOVFF  01,43
087E:  MOVFF  00,42
.................... 
.................... 	next.vbus_b=ina228_read24(INA228_B_ADDR,INA228_REG_VBUS);
0882:  MOVLW  9A
0884:  MOVWF  x71
0886:  MOVLW  05
0888:  MOVWF  x72
088A:  RCALL  0728
088C:  MOVFF  03,49
0890:  MOVFF  02,48
0894:  MOVFF  01,47
0898:  MOVFF  00,46
.................... 	next.vshunt_b=ina228_read24(INA228_B_ADDR,INA228_REG_VSHUNT);
089C:  MOVLW  9A
089E:  MOVWF  x71
08A0:  MOVLW  04
08A2:  MOVWF  x72
08A4:  RCALL  0728
08A6:  MOVFF  03,4D
08AA:  MOVFF  02,4C
08AE:  MOVFF  01,4B
08B2:  MOVFF  00,4A
.................... 
.................... 	next.dietemp_a=ina228_read16(INA228_A_ADDR,INA228_REG_DIETEMP);
08B6:  MOVLW  80
08B8:  MOVWF  x71
08BA:  MOVLW  06
08BC:  MOVWF  x72
08BE:  RCALL  07C6
08C0:  MOVFF  02,5F
08C4:  MOVFF  01,5E
.................... 	next.dietemp_b=ina228_read16(INA228_B_ADDR,INA228_REG_DIETEMP);
08C8:  MOVLW  9A
08CA:  MOVWF  x71
08CC:  MOVLW  06
08CE:  MOVWF  x72
08D0:  RCALL  07C6
08D2:  MOVFF  02,61
08D6:  MOVFF  01,60
08DA:  GOTO   0D84 (RETURN)
.................... }
.................... 
.................... 
.................... void periodic_millisecond(void) {
.................... 	timers.now_millisecond=0;
08DE:  BCF    x62.0
.................... 
.................... 	/* LED control */
.................... 	if ( 0==timers.led_on_a ) {
08E0:  MOVF   x63,F
08E2:  BNZ   08EA
.................... 		output_low(LED_A);
08E4:  BCF    F94.3
08E6:  BCF    F8B.3
.................... 	} else {
08E8:  BRA    08F0
.................... 		output_high(LED_A);
08EA:  BCF    F94.3
08EC:  BSF    F8B.3
.................... 		timers.led_on_a--;
08EE:  DECF   x63,F
.................... 	}
08F0:  GOTO   0D8A (RETURN)
.................... 
.................... 
.................... }
.................... 
.................... /* use to see if a give address is on the I2C bus */
.................... int8 get_ack_status(int8 address) {
.................... 	int8 status;
.................... 
.................... 	i2c_start(STREAM_MASTER);
.................... 	status = i2c_write(STREAM_MASTER,address);  // Status = 0 if got an ACK
.................... 	i2c_stop(STREAM_MASTER);
.................... 
.................... 	if ( 0 == status )
.................... 		return(TRUE);
.................... 
....................    return(FALSE);
.................... }
.................... 
.................... 
.................... void main(void) {
*
0C76:  CLRF   FF8
0C78:  BCF    FD0.7
0C7A:  BSF    07.7
0C7C:  BSF    F93.6
0C7E:  BSF    F93.4
0C80:  CLRF   FC8
0C82:  MOVLW  36
0C84:  MOVWF  FC6
0C86:  BSF    FC5.0
0C88:  BSF    FC5.7
0C8A:  CLRF   19
0C8C:  BSF    FB8.3
0C8E:  MOVLW  A0
0C90:  MOVWF  FAF
0C92:  MOVLW  01
0C94:  MOVWF  FB0
0C96:  MOVLW  A6
0C98:  MOVWF  FAC
0C9A:  MOVLW  90
0C9C:  MOVWF  FAB
0C9E:  CLRF   x6F
0CA0:  CLRF   x6E
0CA2:  MOVLW  00
0CA4:  MOVWF  F7E
0CA6:  BCF    FC1.0
0CA8:  BCF    FC1.1
0CAA:  BCF    FC1.2
0CAC:  BCF    FC1.3
0CAE:  MOVWF  F7F
0CB0:  CLRF   F6C
0CB2:  CLRF   F6B
0CB4:  CLRF   F6D
0CB6:  BCF    x68.0
0CB8:  BCF    x68.1
0CBA:  BRA    0CCC
0CBC:  DATA 4A,40
0CBE:  DATA 1A,00
0CC0:  DATA 04,80
0CC2:  DATA FF,FF
0CC4:  DATA 00,00
0CC6:  DATA 05,40
0CC8:  DATA 69,00
0CCA:  DATA 00,00
0CCC:  MOVLW  00
0CCE:  MOVWF  FF8
0CD0:  MOVLW  0C
0CD2:  MOVWF  FF7
0CD4:  MOVLW  BC
0CD6:  MOVWF  FF6
0CD8:  TBLRD*+
0CDA:  MOVF   FF5,W
0CDC:  MOVWF  00
0CDE:  XORLW  00
0CE0:  BZ    0D08
0CE2:  TBLRD*+
0CE4:  MOVF   FF5,W
0CE6:  MOVWF  01
0CE8:  BTFSC  FE8.7
0CEA:  BRA    0CF6
0CEC:  ANDLW  3F
0CEE:  MOVWF  FEA
0CF0:  TBLRD*+
0CF2:  MOVFF  FF5,FE9
0CF6:  BTFSC  01.6
0CF8:  TBLRD*+
0CFA:  BTFSS  01.6
0CFC:  TBLRD*+
0CFE:  MOVFF  FF5,FEE
0D02:  DCFSNZ 00,F
0D04:  BRA    0CD8
0D06:  BRA    0CFA
0D08:  CLRF   FF8
.................... 	int8 i;
.................... 
.................... 	init();
0D0A:  BRA    05EA
.................... 
.................... 
.................... 
.................... 	/* flash on startup */
.................... 	for ( i=0 ; i<5 ; i++ ) {
0D0C:  CLRF   x70
0D0E:  MOVF   x70,W
0D10:  SUBLW  04
0D12:  BNC   0D2E
.................... 		restart_wdt();
0D14:  CLRWDT
.................... 		output_high(LED_A);
0D16:  BCF    F94.3
0D18:  BSF    F8B.3
.................... 		delay_ms(200);
0D1A:  MOVLW  C8
0D1C:  MOVWF  x72
0D1E:  RCALL  062C
.................... 		output_low(LED_A);
0D20:  BCF    F94.3
0D22:  BCF    F8B.3
.................... 		delay_ms(200);
0D24:  MOVLW  C8
0D26:  MOVWF  x72
0D28:  RCALL  062C
0D2A:  INCF   x70,F
0D2C:  BRA    0D0E
.................... 	}
.................... 
.................... 	delay_ms(1000);
0D2E:  MOVLW  04
0D30:  MOVWF  x71
0D32:  MOVLW  FA
0D34:  MOVWF  x72
0D36:  RCALL  062C
0D38:  DECFSZ x71,F
0D3A:  BRA    0D32
.................... 
.................... 	fprintf(STREAM_FTDI,"# dcswc_module_voltage_current_counter %s\r\n",__DATE__);
0D3C:  MOVLW  58
0D3E:  MOVWF  FF6
0D40:  MOVLW  04
0D42:  MOVWF  FF7
0D44:  MOVLW  27
0D46:  MOVWF  x72
0D48:  RCALL  0654
0D4A:  MOVLW  84
0D4C:  MOVWF  FF6
0D4E:  MOVLW  04
0D50:  MOVWF  FF7
0D52:  BRA    0674
0D54:  MOVLW  0D
0D56:  BTFSS  F9E.4
0D58:  BRA    0D56
0D5A:  MOVWF  FAD
0D5C:  MOVLW  0A
0D5E:  BTFSS  F9E.4
0D60:  BRA    0D5E
0D62:  MOVWF  FAD
.................... 
.................... 	delay_ms(1000);
0D64:  MOVLW  04
0D66:  MOVWF  x71
0D68:  MOVLW  FA
0D6A:  MOVWF  x72
0D6C:  RCALL  062C
0D6E:  DECFSZ x71,F
0D70:  BRA    0D68
.................... 
.................... 	timers.led_on_a=500;
0D72:  MOVLW  F4
0D74:  MOVWF  x63
.................... 
.................... 	enable_interrupts(GLOBAL);
0D76:  MOVLW  C0
0D78:  IORWF  FF2,F
.................... 
.................... 	/* enable I2C slave interrupt */
.................... 	enable_interrupts(INT_SSP);
0D7A:  BSF    F9D.3
.................... 
.................... 	for ( ; ; ) {
.................... 		restart_wdt();
0D7C:  CLRWDT
.................... 
.................... 		/* query INA228's for next */
.................... 		if ( timers.now_ina ) {
0D7E:  BTFSS  x62.1
0D80:  BRA    0D84
.................... 			action_now_ina();
0D82:  BRA    084C
.................... 		}
.................... 
.................... 		if ( timers.now_millisecond ) {
0D84:  BTFSS  x62.0
0D86:  BRA    0D8A
.................... 			periodic_millisecond();
0D88:  BRA    08DE
.................... 		}
.................... 
.................... 		if ( kbhit() ) {
0D8A:  BTFSS  F9E.5
0D8C:  BRA    105A
.................... 			getc();
0D8E:  BRA    08F4
.................... 
.................... 			fprintf(STREAM_FTDI,"# DIP SWITCHES: %d\r\n",
.................... 				read_dip_switch()
.................... 			);
0D90:  RCALL  05CC
0D92:  MOVFF  01,71
0D96:  MOVLW  8E
0D98:  MOVWF  FF6
0D9A:  MOVLW  04
0D9C:  MOVWF  FF7
0D9E:  MOVLW  10
0DA0:  MOVWF  x72
0DA2:  RCALL  0654
0DA4:  MOVFF  71,72
0DA8:  MOVLW  18
0DAA:  MOVWF  x73
0DAC:  BRA    0934
0DAE:  MOVLW  0D
0DB0:  BTFSS  F9E.4
0DB2:  BRA    0DB0
0DB4:  MOVWF  FAD
0DB6:  MOVLW  0A
0DB8:  BTFSS  F9E.4
0DBA:  BRA    0DB8
0DBC:  MOVWF  FAD
.................... 
.................... 			fprintf(STREAM_FTDI,"# A: 0x%08lx / 0x%08lx / 0x%04lu\r\n",
.................... 				current.vbus_a,
.................... 				current.vshunt_a,
.................... 				current.dietemp_a
.................... 			);
0DBE:  MOVLW  A4
0DC0:  MOVWF  FF6
0DC2:  MOVLW  04
0DC4:  MOVWF  FF7
0DC6:  MOVLW  07
0DC8:  MOVWF  x72
0DCA:  RCALL  0654
0DCC:  MOVFF  1D,71
0DD0:  MOVLW  57
0DD2:  MOVWF  x72
0DD4:  RCALL  09E8
0DD6:  MOVFF  1C,71
0DDA:  MOVLW  57
0DDC:  MOVWF  x72
0DDE:  RCALL  09E8
0DE0:  MOVFF  1B,71
0DE4:  MOVLW  57
0DE6:  MOVWF  x72
0DE8:  RCALL  09E8
0DEA:  MOVFF  1A,71
0DEE:  MOVLW  57
0DF0:  MOVWF  x72
0DF2:  RCALL  09E8
0DF4:  MOVLW  B0
0DF6:  MOVWF  FF6
0DF8:  MOVLW  04
0DFA:  MOVWF  FF7
0DFC:  MOVLW  05
0DFE:  MOVWF  x72
0E00:  RCALL  0654
0E02:  MOVFF  21,71
0E06:  MOVLW  57
0E08:  MOVWF  x72
0E0A:  RCALL  09E8
0E0C:  MOVFF  20,71
0E10:  MOVLW  57
0E12:  MOVWF  x72
0E14:  RCALL  09E8
0E16:  MOVFF  1F,71
0E1A:  MOVLW  57
0E1C:  MOVWF  x72
0E1E:  RCALL  09E8
0E20:  MOVFF  1E,71
0E24:  MOVLW  57
0E26:  MOVWF  x72
0E28:  RCALL  09E8
0E2A:  MOVLW  BA
0E2C:  MOVWF  FF6
0E2E:  MOVLW  04
0E30:  MOVWF  FF7
0E32:  MOVLW  05
0E34:  MOVWF  x72
0E36:  RCALL  0654
0E38:  MOVLW  09
0E3A:  MOVWF  FE9
0E3C:  MOVFF  3B,72
0E40:  MOVFF  3A,71
0E44:  RCALL  0A2A
0E46:  MOVLW  0D
0E48:  BTFSS  F9E.4
0E4A:  BRA    0E48
0E4C:  MOVWF  FAD
0E4E:  MOVLW  0A
0E50:  BTFSS  F9E.4
0E52:  BRA    0E50
0E54:  MOVWF  FAD
.................... 			fprintf(STREAM_FTDI,"# B: 0x%08lx / 0x%08lx / 0x%04lu\r\n",
.................... 				current.vbus_b,
.................... 				current.vshunt_b,
.................... 				current.dietemp_b
.................... 			);
0E56:  MOVLW  C8
0E58:  MOVWF  FF6
0E5A:  MOVLW  04
0E5C:  MOVWF  FF7
0E5E:  MOVLW  07
0E60:  MOVWF  x72
0E62:  CALL   0654
0E66:  MOVFF  25,71
0E6A:  MOVLW  57
0E6C:  MOVWF  x72
0E6E:  RCALL  09E8
0E70:  MOVFF  24,71
0E74:  MOVLW  57
0E76:  MOVWF  x72
0E78:  RCALL  09E8
0E7A:  MOVFF  23,71
0E7E:  MOVLW  57
0E80:  MOVWF  x72
0E82:  RCALL  09E8
0E84:  MOVFF  22,71
0E88:  MOVLW  57
0E8A:  MOVWF  x72
0E8C:  RCALL  09E8
0E8E:  MOVLW  D4
0E90:  MOVWF  FF6
0E92:  MOVLW  04
0E94:  MOVWF  FF7
0E96:  MOVLW  05
0E98:  MOVWF  x72
0E9A:  CALL   0654
0E9E:  MOVFF  29,71
0EA2:  MOVLW  57
0EA4:  MOVWF  x72
0EA6:  RCALL  09E8
0EA8:  MOVFF  28,71
0EAC:  MOVLW  57
0EAE:  MOVWF  x72
0EB0:  RCALL  09E8
0EB2:  MOVFF  27,71
0EB6:  MOVLW  57
0EB8:  MOVWF  x72
0EBA:  RCALL  09E8
0EBC:  MOVFF  26,71
0EC0:  MOVLW  57
0EC2:  MOVWF  x72
0EC4:  RCALL  09E8
0EC6:  MOVLW  DE
0EC8:  MOVWF  FF6
0ECA:  MOVLW  04
0ECC:  MOVWF  FF7
0ECE:  MOVLW  05
0ED0:  MOVWF  x72
0ED2:  CALL   0654
0ED6:  MOVLW  09
0ED8:  MOVWF  FE9
0EDA:  MOVFF  3D,72
0EDE:  MOVFF  3C,71
0EE2:  RCALL  0A2A
0EE4:  MOVLW  0D
0EE6:  BTFSS  F9E.4
0EE8:  BRA    0EE6
0EEA:  MOVWF  FAD
0EEC:  MOVLW  0A
0EEE:  BTFSS  F9E.4
0EF0:  BRA    0EEE
0EF2:  MOVWF  FAD
.................... 
.................... 			fprintf(STREAM_FTDI,"# current.count_a_last_second=%lu\r\n",
.................... 				current.count_a_last_second
.................... 			);
0EF4:  MOVLW  EC
0EF6:  MOVWF  FF6
0EF8:  MOVLW  04
0EFA:  MOVWF  FF7
0EFC:  MOVLW  1E
0EFE:  MOVWF  x72
0F00:  CALL   0654
0F04:  MOVLW  10
0F06:  MOVWF  FE9
0F08:  MOVFF  2B,72
0F0C:  MOVFF  2A,71
0F10:  RCALL  0A2A
0F12:  MOVLW  0D
0F14:  BTFSS  F9E.4
0F16:  BRA    0F14
0F18:  MOVWF  FAD
0F1A:  MOVLW  0A
0F1C:  BTFSS  F9E.4
0F1E:  BRA    0F1C
0F20:  MOVWF  FAD
.................... 			fprintf(STREAM_FTDI,"# current.count_b_last_second=%lu\r\n",
.................... 				current.count_b_last_second
.................... 			);
0F22:  MOVLW  10
0F24:  MOVWF  FF6
0F26:  MOVLW  05
0F28:  MOVWF  FF7
0F2A:  MOVLW  1E
0F2C:  MOVWF  x72
0F2E:  CALL   0654
0F32:  MOVLW  10
0F34:  MOVWF  FE9
0F36:  MOVFF  2D,72
0F3A:  MOVFF  2C,71
0F3E:  RCALL  0A2A
0F40:  MOVLW  0D
0F42:  BTFSS  F9E.4
0F44:  BRA    0F42
0F46:  MOVWF  FAD
0F48:  MOVLW  0A
0F4A:  BTFSS  F9E.4
0F4C:  BRA    0F4A
0F4E:  MOVWF  FAD
.................... 			fprintf(STREAM_FTDI,"# current.count_a_long=%lu\r\n",
.................... 				current.count_a_long
.................... 			);
0F50:  MOVLW  34
0F52:  MOVWF  FF6
0F54:  MOVLW  05
0F56:  MOVWF  FF7
0F58:  MOVLW  17
0F5A:  MOVWF  x72
0F5C:  CALL   0654
0F60:  MOVLW  41
0F62:  MOVWF  FE9
0F64:  MOVFF  31,74
0F68:  MOVFF  30,73
0F6C:  MOVFF  2F,72
0F70:  MOVFF  2E,71
0F74:  RCALL  0B64
0F76:  MOVLW  0D
0F78:  BTFSS  F9E.4
0F7A:  BRA    0F78
0F7C:  MOVWF  FAD
0F7E:  MOVLW  0A
0F80:  BTFSS  F9E.4
0F82:  BRA    0F80
0F84:  MOVWF  FAD
.................... 			fprintf(STREAM_FTDI,"# current.count_b_long=%lu\r\n",
.................... 				current.count_b_long
.................... 			);
0F86:  MOVLW  52
0F88:  MOVWF  FF6
0F8A:  MOVLW  05
0F8C:  MOVWF  FF7
0F8E:  MOVLW  17
0F90:  MOVWF  x72
0F92:  CALL   0654
0F96:  MOVLW  41
0F98:  MOVWF  FE9
0F9A:  MOVFF  35,74
0F9E:  MOVFF  34,73
0FA2:  MOVFF  33,72
0FA6:  MOVFF  32,71
0FAA:  RCALL  0B64
0FAC:  MOVLW  0D
0FAE:  BTFSS  F9E.4
0FB0:  BRA    0FAE
0FB2:  MOVWF  FAD
0FB4:  MOVLW  0A
0FB6:  BTFSS  F9E.4
0FB8:  BRA    0FB6
0FBA:  MOVWF  FAD
.................... 
.................... 			fprintf(STREAM_FTDI,"# current.count_seconds_long=%lu\r\n",
.................... 				current.count_seconds_long
.................... 			);
0FBC:  MOVLW  70
0FBE:  MOVWF  FF6
0FC0:  MOVLW  05
0FC2:  MOVWF  FF7
0FC4:  MOVLW  1D
0FC6:  MOVWF  x72
0FC8:  CALL   0654
0FCC:  MOVLW  41
0FCE:  MOVWF  FE9
0FD0:  MOVFF  39,74
0FD4:  MOVFF  38,73
0FD8:  MOVFF  37,72
0FDC:  MOVFF  36,71
0FE0:  RCALL  0B64
0FE2:  MOVLW  0D
0FE4:  BTFSS  F9E.4
0FE6:  BRA    0FE4
0FE8:  MOVWF  FAD
0FEA:  MOVLW  0A
0FEC:  BTFSS  F9E.4
0FEE:  BRA    0FEC
0FF0:  MOVWF  FAD
.................... 
.................... 			fprintf(STREAM_FTDI,"# input(PIC_ADDR_MSB)=%u\r\n",input(PIC_ADDR_MSB));
0FF2:  BSF    F94.6
0FF4:  MOVLW  00
0FF6:  BTFSC  F82.6
0FF8:  MOVLW  01
0FFA:  MOVWF  x71
0FFC:  MOVLW  94
0FFE:  MOVWF  FF6
1000:  MOVLW  05
1002:  MOVWF  FF7
1004:  MOVLW  16
1006:  MOVWF  x72
1008:  CALL   0654
100C:  MOVFF  71,72
1010:  MOVLW  1B
1012:  MOVWF  x73
1014:  RCALL  0C0A
1016:  MOVLW  0D
1018:  BTFSS  F9E.4
101A:  BRA    1018
101C:  MOVWF  FAD
101E:  MOVLW  0A
1020:  BTFSS  F9E.4
1022:  BRA    1020
1024:  MOVWF  FAD
.................... 			fprintf(STREAM_FTDI,"# input(PIC_ADDR_LSB)=%u\r\n",input(PIC_ADDR_LSB));
1026:  BSF    F94.7
1028:  MOVLW  00
102A:  BTFSC  F82.7
102C:  MOVLW  01
102E:  MOVWF  x71
1030:  MOVLW  B0
1032:  MOVWF  FF6
1034:  MOVLW  05
1036:  MOVWF  FF7
1038:  MOVLW  16
103A:  MOVWF  x72
103C:  CALL   0654
1040:  MOVFF  71,72
1044:  MOVLW  1B
1046:  MOVWF  x73
1048:  RCALL  0C0A
104A:  MOVLW  0D
104C:  BTFSS  F9E.4
104E:  BRA    104C
1050:  MOVWF  FAD
1052:  MOVLW  0A
1054:  BTFSS  F9E.4
1056:  BRA    1054
1058:  MOVWF  FAD
.................... 
.................... 		}
105A:  BRA    0D7C
.................... 
.................... 
.................... 	}
.................... 
.................... 
.................... }
105C:  BRA    105C

Configuration Fuses:
   Word  1: 2200   HS NOPLLEN PCLKEN NOFCMEN NOIESO
   Word  2: 1819   NOPUT NOBROWNOUT BORV19 NOWDT WDT4096
   Word  3: 0000   NOHFOFST NOMCLR
   Word  4: 0009   STVREN NOLVP BBSIZ2K NOXINST DEBUG
   Word  5: C003   NOPROTECT NOCPB NOCPD
   Word  6: E003   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 4003   NOEBTR NOEBTRB

   Some fuses have been forced to be compatible with the ICD debugger.

ROM data:
F00000: 00 00 40 00                                        ..@.
