CCS PCH C Compiler, Version 5.117, 2295               11-Apr-24 09:05

               Filename:   C:\Users\James Jarvis\Desktop\planetPrecision\dcswc_module_voltage_current_counter\dcswc_module_voltage_current_counter.lst

               ROM used:   2766 bytes (17%)
                           Largest free fragment is 13614
               RAM used:   115 (22%) at main() level
                           133 (26%) worst case
               Stack used: 5 locations (3 in main + 2 for interrupts)
               Stack size: 31

*
0000:  GOTO   0902
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  FF5,15
003C:  MOVFF  FF6,16
0040:  MOVFF  FF7,17
0044:  MOVFF  00,0E
0048:  MOVFF  01,0F
004C:  MOVFF  02,10
0050:  MOVFF  03,11
0054:  BTFSS  F9D.1
0056:  GOTO   0060
005A:  BTFSC  F9E.1
005C:  GOTO   00BA
0060:  BTFSS  F9D.3
0062:  GOTO   006C
0066:  BTFSC  F9E.3
0068:  GOTO   039E
006C:  MOVFF  0E,00
0070:  MOVFF  0F,01
0074:  MOVFF  10,02
0078:  MOVFF  11,03
007C:  MOVFF  0C,FE9
0080:  MOVFF  07,FEA
0084:  BSF    07.7
0086:  MOVFF  08,FE1
008A:  MOVFF  09,FE2
008E:  MOVFF  0A,FD9
0092:  MOVFF  0B,FDA
0096:  MOVFF  12,FF3
009A:  MOVFF  13,FF4
009E:  MOVFF  14,FFA
00A2:  MOVFF  15,FF5
00A6:  MOVFF  16,FF6
00AA:  MOVFF  17,FF7
00AE:  MOVF   04,W
00B0:  MOVFF  06,FE0
00B4:  MOVFF  05,FD8
00B8:  RETFIE 0
.................... #include "dcswc_module_voltage_current_counter.h"
.................... #include <18F14K22.h>
.................... //////////// Standard Header file for the PIC18F14K22 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18F14K22
*
0450:  DATA 23,20
0452:  DATA 64,63
0454:  DATA 73,77
0456:  DATA 63,5F
0458:  DATA 6D,6F
045A:  DATA 64,75
045C:  DATA 6C,65
045E:  DATA 5F,76
0460:  DATA 6F,6C
0462:  DATA 74,61
0464:  DATA 67,65
0466:  DATA 5F,63
0468:  DATA 75,72
046A:  DATA 72,65
046C:  DATA 6E,74
046E:  DATA 5F,63
0470:  DATA 6F,75
0472:  DATA 6E,74
0474:  DATA 65,72
0476:  DATA 20,25
0478:  DATA 73,0D
047A:  DATA 0A,23
047C:  DATA 20,00
047E:  DATA 31,31
0480:  DATA 2D,41
0482:  DATA 70,72
0484:  DATA 2D,32
0486:  DATA 34,00
0488:  DATA 57,44
048A:  DATA 54,20
048C:  DATA 54,49
048E:  DATA 4D,45
0490:  DATA 4F,55
0492:  DATA 54,00
0494:  DATA 4D,43
0496:  DATA 4C,52
0498:  DATA 20,46
049A:  DATA 52,4F
049C:  DATA 4D,20
049E:  DATA 53,4C
04A0:  DATA 45,45
04A2:  DATA 50,00
04A4:  DATA 4D,43
04A6:  DATA 4C,52
04A8:  DATA 20,46
04AA:  DATA 52,4F
04AC:  DATA 4D,20
04AE:  DATA 52,55
04B0:  DATA 4E,00
04B2:  DATA 4E,4F
04B4:  DATA 52,4D
04B6:  DATA 41,4C
04B8:  DATA 20,50
04BA:  DATA 4F,57
04BC:  DATA 45,52
04BE:  DATA 20,55
04C0:  DATA 50,00
04C2:  DATA 42,52
04C4:  DATA 4F,57
04C6:  DATA 4E,4F
04C8:  DATA 55,54
04CA:  DATA 20,52
04CC:  DATA 45,53
04CE:  DATA 54,41
04D0:  DATA 52,54
04D2:  DATA 00,00
04D4:  DATA 57,44
04D6:  DATA 54,20
04D8:  DATA 46,52
04DA:  DATA 4F,4D
04DC:  DATA 20,53
04DE:  DATA 4C,45
04E0:  DATA 45,50
04E2:  DATA 00,00
04E4:  DATA 52,45
04E6:  DATA 53,45
04E8:  DATA 54,20
04EA:  DATA 49,4E
04EC:  DATA 53,54
04EE:  DATA 52,55
04F0:  DATA 43,54
04F2:  DATA 49,4F
04F4:  DATA 4E,00
04F6:  DATA 55,4E
04F8:  DATA 4B,4E
04FA:  DATA 4F,57
04FC:  DATA 4E,21
04FE:  DATA 00,00
0500:  DATA 23,20
0502:  DATA 6F,75
0504:  DATA 72,20
0506:  DATA 49,32
0508:  DATA 43,20
050A:  DATA 61,64
050C:  DATA 64,72
050E:  DATA 65,73
0510:  DATA 73,3D
0512:  DATA 30,78
0514:  DATA 25,30
0516:  DATA 32,78
0518:  DATA 0D,0A
051A:  DATA 00,00
*
0664:  TBLRD*+
0666:  MOVFF  FF6,74
066A:  MOVFF  FF7,75
066E:  MOVF   FF5,W
0670:  BTFSS  F9E.4
0672:  BRA    0670
0674:  MOVWF  FAD
0676:  MOVFF  74,FF6
067A:  MOVFF  75,FF7
067E:  DECFSZ x73,F
0680:  BRA    0664
0682:  RETURN 0
0684:  TBLRD*+
0686:  MOVF   FF5,F
0688:  BZ    06A4
068A:  MOVFF  FF6,72
068E:  MOVFF  FF7,73
0692:  MOVF   FF5,W
0694:  BTFSS  F9E.4
0696:  BRA    0694
0698:  MOVWF  FAD
069A:  MOVFF  72,FF6
069E:  MOVFF  73,FF7
06A2:  BRA    0684
06A4:  RETURN 0
06A6:  BTFSC  x74.7
06A8:  BRA    06CA
06AA:  MOVLW  0F
06AC:  MOVWF  00
06AE:  SWAPF  x73,W
06B0:  ANDWF  00,F
06B2:  MOVLW  0A
06B4:  SUBWF  00,W
06B6:  BC    06BE
06B8:  MOVLW  30
06BA:  ADDWF  00,F
06BC:  BRA    06C2
06BE:  MOVF   x74,W
06C0:  ADDWF  00,F
06C2:  MOVF   00,W
06C4:  BTFSS  F9E.4
06C6:  BRA    06C4
06C8:  MOVWF  FAD
06CA:  MOVLW  0F
06CC:  ANDWF  x73,F
06CE:  MOVLW  0A
06D0:  SUBWF  x73,W
06D2:  BC    06D8
06D4:  MOVLW  30
06D6:  BRA    06DC
06D8:  BCF    x74.7
06DA:  MOVF   x74,W
06DC:  ADDWF  x73,F
06DE:  MOVF   x73,W
06E0:  BTFSS  F9E.4
06E2:  BRA    06E0
06E4:  MOVWF  FAD
06E6:  GOTO   0AA6 (RETURN)
.................... 
.................... #list
.................... 
.................... #device ADC=10
.................... #device *=16
.................... #use delay(clock=16MHz)
*
063C:  CLRF   FEA
063E:  MOVLW  72
0640:  MOVWF  FE9
0642:  MOVF   FEF,W
0644:  BZ    0662
0646:  MOVLW  05
0648:  MOVWF  01
064A:  CLRF   00
064C:  DECFSZ 00,F
064E:  BRA    064C
0650:  DECFSZ 01,F
0652:  BRA    064A
0654:  MOVLW  2E
0656:  MOVWF  00
0658:  DECFSZ 00,F
065A:  BRA    0658
065C:  BRA    065E
065E:  DECFSZ FEF,F
0660:  BRA    0646
0662:  RETURN 0
.................... 
.................... /* hardware I2C port is slave and is connected to DCSWC bus */
.................... #use i2c(stream=STREAM_SLAVE,SLAVE, I2C1, FORCE_HW)
*
0388:  MOVF   FC9,W
038A:  MOVFF  80,FC9
038E:  BSF    FC6.4
0390:  BCF    F9E.3
0392:  BTFSC  FC7.0
0394:  BRA    0392
0396:  CLRF   01
0398:  BTFSS  FC5.6
039A:  INCF   01,F
039C:  RETURN 0
.................... /* slave address set based on dip switch in init() */
.................... /* Linux / i2cdetect will use the CCS address >>1. So 0x34 becomes 0x1a */
.................... 
.................... 
.................... 
.................... /* important FUSE notes! 
.................... MPLAB defaults to DEBUG mode and that will override fuses.
.................... make sure it is on "BUILD CONFIGURATION" of "RELEASE" under
.................... "PROJECT" menu.
.................... 
.................... CCS setup functions can override fuses. Check .LST file
.................... to see if anything has been overriden!
.................... */
.................... 
.................... #fuses NODEBUG 
.................... #fuses HS
.................... #fuses NOPCLKEN
.................... #fuses NOPLLEN
.................... #fuses NOFCMEN
.................... #fuses NOIESO
.................... #fuses BROWNOUT
.................... #fuses BORV30
.................... #fuses NOPUT
.................... #fuses WDT
.................... #fuses WDT128     /* this can be override by setup_wdt() */
.................... #fuses NOHFOFST
.................... #fuses NOMCLR
.................... #fuses STVREN
.................... #fuses NOLVP
.................... #fuses NOXINST
.................... #fuses NODEBUG
.................... #fuses NOPROTECT
.................... #fuses NOWRT
.................... #fuses NOWRTC 
.................... #fuses NOWRTB
.................... #fuses NOWRTD
.................... #fuses NOEBTR
.................... #fuses NOEBTRB
.................... #fuses BBSIZ1K
.................... 
.................... 
.................... #use standard_io(ALL)
.................... 
.................... #use rs232(UART1,stream=STREAM_FTDI,baud=9600,errors)	
.................... 
.................... /* program config CRC of 0 and a serial_prefix of 'A' ... that will trigger a write default on first boot */
.................... #ROM 0xF00000 = { 0x00, 0x00, 0x40, 0x00 }
.................... 
.................... 
.................... 
.................... #define COUNT_B              PIN_C5
.................... #define COUNT_A              PIN_C4
.................... #define LED_A                PIN_C3
.................... #define PIC_ADDR_MSB         PIN_C6
.................... #define PIC_ADDR_LSB         PIN_C7
.................... #define SER_TO_PC            PIN_B7
.................... 
.................... #define INA_ALERT            PIN_A2
.................... #define I2C_SW_SDA           PIN_C0
.................... #define I2C_SW_SCL           PIN_C1
.................... #define TP2                  PIN_C2
.................... #define I2C_SDA              PIN_B4
.................... #define SER_FROM_PC          PIN_B5
.................... #define I2C_SCL              PIN_B6
.................... 
.................... 
.................... /* software I2C port is maser and is connected to two INA228A */
.................... #use i2c(stream=STREAM_MASTER, MASTER, FAST, FORCE_SW, scl=I2C_SW_SCL, sda=I2C_SW_SDA)
*
053A:  MOVLW  08
053C:  MOVWF  01
053E:  NOP   
0540:  BCF    F8B.1
0542:  BCF    F94.1
0544:  NOP   
0546:  RLCF   x79,F
0548:  BCF    F8B.0
054A:  BTFSC  FD8.0
054C:  BSF    F94.0
054E:  BTFSS  FD8.0
0550:  BCF    F94.0
0552:  BSF    F94.1
0554:  BTFSS  F82.1
0556:  BRA    0554
0558:  DECFSZ 01,F
055A:  BRA    053E
055C:  NOP   
055E:  BCF    F8B.1
0560:  BCF    F94.1
0562:  NOP   
0564:  BSF    F94.0
0566:  NOP   
0568:  NOP   
056A:  BSF    F94.1
056C:  BTFSS  F82.1
056E:  BRA    056C
0570:  CLRF   01
0572:  NOP   
0574:  BTFSC  F82.0
0576:  BSF    01.0
0578:  BCF    F8B.1
057A:  BCF    F94.1
057C:  BCF    F8B.0
057E:  BCF    F94.0
0580:  RETURN 0
*
06EA:  MOVLW  08
06EC:  MOVWF  x7B
06EE:  MOVFF  00,7C
06F2:  BSF    F94.0
06F4:  NOP   
06F6:  BSF    F94.1
06F8:  BTFSS  F82.1
06FA:  BRA    06F8
06FC:  BTFSC  F82.0
06FE:  BSF    FD8.0
0700:  BTFSS  F82.0
0702:  BCF    FD8.0
0704:  RLCF   01,F
0706:  NOP   
0708:  BCF    F94.1
070A:  BCF    F8B.1
070C:  DECFSZ x7B,F
070E:  BRA    06F2
0710:  BSF    F94.0
0712:  NOP   
0714:  BCF    F8B.0
0716:  MOVF   x7C,W
0718:  BTFSS  FD8.2
071A:  BCF    F94.0
071C:  NOP   
071E:  BSF    F94.1
0720:  BTFSS  F82.1
0722:  BRA    0720
0724:  NOP   
0726:  BCF    F8B.1
0728:  BCF    F94.1
072A:  NOP   
072C:  BCF    F8B.0
072E:  BCF    F94.0
0730:  RETURN 0
.................... 
.................... 
.................... 
.................... #define INA228_A_ADDR      0x80
.................... #define INA228_B_ADDR      0x9a
.................... 
.................... 
.................... 
.................... #define ADCRANGE 1
.................... 
.................... typedef struct {
.................... 	int32 vbus_a, vshunt_a;
.................... 	int32 vbus_b, vshunt_b;
.................... 
.................... 	int16 count_a_last_second, count_b_last_second;
.................... 
.................... 	int32 count_a_long;
.................... 	int32 count_b_long;
.................... 	int32 count_seconds_long;
.................... 
.................... 	int16 dietemp_a;
.................... 	int16 dietemp_b;
.................... } struct_current;
.................... 
.................... typedef struct {
.................... 	/* action flags */
.................... 	int1 now_millisecond;
.................... 
.................... 	int1 now_ina;    // query ina registers
.................... 
.................... 	int1 now_dump;   // debugging
.................... 
.................... 	/* timers */
.................... 	int8 led_on_a;
.................... } struct_time_keep;
.................... 
.................... /* global structures */
.................... struct_current current={0};
.................... struct_current next={0};
.................... struct_time_keep timers={0};
.................... 
.................... #include "ina228.c"
.................... #define INA228_REG_CONFIG       0x00  // 16 bits, configuration
.................... #define INA228_REG_ADC_CONFIG   0x01  // 16 bits, ADC configuration
.................... #define INA228_REG_SHUNT_CAL    0x02  // 16 bits, shunt calibration
.................... #define INA228_REG_SHUNT_TEMPCO 0x03  // 16 bits, shunt temperature coefficient
.................... #define INA228_REG_VSHUNT       0x04  // 24 bits, shunt voltage measurement
.................... #define INA228_REG_VBUS         0x05  // 24 bits, bus voltage measurement
.................... #define INA228_REG_DIETEMP      0x06  // 16 bits, temperature measurement
.................... #define INA228_REG_CURRENT      0x07  // 24 bits, current result
.................... #define INA228_REG_POWER        0x08  // 24 bits, power result 
.................... #define INA228_REG_ENERGY       0x09  // 40 bits, energy result
.................... #define INA228_REG_CHARGE       0x0a  // 40 bits, charge result
.................... #define INA228_REG_DIAG_ALRT    0x0b  // 16 bits, diagnostic flags and alert
.................... #define INA228_REG_SOVL         0x0c  // 16 bits, shunt overvoltage threshold
.................... #define INA228_REG_SUVL         0x0d  // 16 bits, shunt undervoltage threshold
.................... #define INA228_REG_BOVL         0x0e  // 16 bits, bus overvoltage threshold
.................... #define INA228_REG_BUVL         0x0f  // 16 bits, bus undervoltage threshold
.................... #define INA228_REG_TEMP_LIMIT   0x10  // 16 bits, temperature over-limit threshold
.................... #define INA228_REG_PWR_LIMIT    0x11  // 16 bits, power over-limit threshold
.................... #define INA228_REG_MFG_ID       0x3e  // 16 bits, manufacturer ID
.................... #define INA228_REG_DEVICE_ID    0x3f  // 16 bits, device ID
.................... 
.................... #define INA228_I2C_WRITE        0x00
.................... #define INA228_I2C_READ         0x01 
.................... 
.................... 
.................... int16 ina228_read16(int8 i2c_address, int8 regaddr) {
.................... 	int16 data;
.................... 
.................... 	i2c_start(STREAM_MASTER);
*
07D0:  BSF    F94.0
07D2:  NOP   
07D4:  BSF    F94.1
07D6:  NOP   
07D8:  BCF    F8B.0
07DA:  BCF    F94.0
07DC:  NOP   
07DE:  BCF    F8B.1
07E0:  BCF    F94.1
.................... 	delay_us(15);
07E2:  MOVLW  13
07E4:  MOVWF  00
07E6:  DECFSZ 00,F
07E8:  BRA    07E6
07EA:  BRA    07EC
.................... 	i2c_write(STREAM_MASTER,i2c_address);
07EC:  MOVFF  72,79
07F0:  RCALL  053A
.................... 	i2c_write(STREAM_MASTER,regaddr);
07F2:  MOVFF  73,79
07F6:  RCALL  053A
.................... 	i2c_start(STREAM_MASTER);
07F8:  BSF    F94.0
07FA:  NOP   
07FC:  BSF    F94.1
07FE:  NOP   
0800:  BTFSS  F82.1
0802:  BRA    0800
0804:  BCF    F8B.0
0806:  BCF    F94.0
0808:  NOP   
080A:  BCF    F8B.1
080C:  BCF    F94.1
.................... 	delay_us(15);
080E:  MOVLW  13
0810:  MOVWF  00
0812:  DECFSZ 00,F
0814:  BRA    0812
0816:  BRA    0818
.................... 	i2c_write(STREAM_MASTER,i2c_address | INA228_I2C_READ);  // read cycle
0818:  MOVF   x72,W
081A:  IORLW  01
081C:  MOVWF  x76
081E:  MOVWF  x79
0820:  RCALL  053A
.................... 	data=make16(i2c_read(STREAM_MASTER,1),i2c_read(STREAM_MASTER,0));                                 
0822:  MOVLW  01
0824:  MOVWF  00
0826:  RCALL  06EA
0828:  MOVFF  01,76
082C:  CLRF   00
082E:  RCALL  06EA
0830:  MOVFF  76,75
0834:  MOVFF  01,74
.................... 	i2c_stop(STREAM_MASTER);
0838:  BCF    F94.0
083A:  NOP   
083C:  BSF    F94.1
083E:  BTFSS  F82.1
0840:  BRA    083E
0842:  NOP   
0844:  BRA    0846
0846:  NOP   
0848:  BSF    F94.0
084A:  NOP   
.................... 
.................... 	return data;
084C:  MOVFF  74,01
0850:  MOVFF  75,02
0854:  RETURN 0
.................... }
.................... 
.................... int32 ina228_read24(int8 i2c_address, int8 regaddr) {
.................... 	int32 data;
.................... 
.................... 	i2c_start(STREAM_MASTER);
*
0732:  BSF    F94.0
0734:  NOP   
0736:  BSF    F94.1
0738:  NOP   
073A:  BCF    F8B.0
073C:  BCF    F94.0
073E:  NOP   
0740:  BCF    F8B.1
0742:  BCF    F94.1
.................... 	delay_us(15);
0744:  MOVLW  13
0746:  MOVWF  00
0748:  DECFSZ 00,F
074A:  BRA    0748
074C:  BRA    074E
.................... 	i2c_write(STREAM_MASTER,i2c_address);
074E:  MOVFF  72,79
0752:  RCALL  053A
.................... 	i2c_write(STREAM_MASTER,regaddr);
0754:  MOVFF  73,79
0758:  RCALL  053A
.................... 	i2c_start(STREAM_MASTER);
075A:  BSF    F94.0
075C:  NOP   
075E:  BSF    F94.1
0760:  NOP   
0762:  BTFSS  F82.1
0764:  BRA    0762
0766:  BCF    F8B.0
0768:  BCF    F94.0
076A:  NOP   
076C:  BCF    F8B.1
076E:  BCF    F94.1
.................... 	delay_us(15);
0770:  MOVLW  13
0772:  MOVWF  00
0774:  DECFSZ 00,F
0776:  BRA    0774
0778:  BRA    077A
.................... 	i2c_write(STREAM_MASTER,i2c_address | INA228_I2C_READ);  // read cycle
077A:  MOVF   x72,W
077C:  IORLW  01
077E:  MOVWF  x78
0780:  MOVWF  x79
0782:  RCALL  053A
.................... 	data=make32(0,i2c_read(STREAM_MASTER,1),i2c_read(STREAM_MASTER,1),i2c_read(STREAM_MASTER,0));
0784:  MOVLW  01
0786:  MOVWF  00
0788:  RCALL  06EA
078A:  MOVFF  01,78
078E:  MOVLW  01
0790:  MOVWF  00
0792:  RCALL  06EA
0794:  MOVFF  01,79
0798:  CLRF   00
079A:  RCALL  06EA
079C:  CLRF   x77
079E:  MOVFF  78,76
07A2:  MOVFF  79,75
07A6:  MOVFF  01,74
.................... 	i2c_stop(STREAM_MASTER);
07AA:  BCF    F94.0
07AC:  NOP   
07AE:  BSF    F94.1
07B0:  BTFSS  F82.1
07B2:  BRA    07B0
07B4:  NOP   
07B6:  BRA    07B8
07B8:  NOP   
07BA:  BSF    F94.0
07BC:  NOP   
.................... 
.................... 	return data;
07BE:  MOVFF  74,00
07C2:  MOVFF  75,01
07C6:  MOVFF  76,02
07CA:  MOVFF  77,03
07CE:  RETURN 0
.................... }
.................... 
.................... void ina228_write16(int8 i2c_address, int8 regaddr, int16 value) {
.................... 	i2c_start(STREAM_MASTER);
*
0582:  BSF    F94.0
0584:  NOP   
0586:  BSF    F94.1
0588:  NOP   
058A:  BCF    F8B.0
058C:  BCF    F94.0
058E:  NOP   
0590:  BCF    F8B.1
0592:  BCF    F94.1
.................... 	delay_us(15);                                                 
0594:  MOVLW  13
0596:  MOVWF  00
0598:  DECFSZ 00,F
059A:  BRA    0598
059C:  BRA    059E
.................... 	i2c_write(STREAM_MASTER,i2c_address); // write cycle                       
059E:  MOVFF  73,79
05A2:  RCALL  053A
.................... 	i2c_write(STREAM_MASTER,regaddr);  // write cycle         
05A4:  MOVFF  74,79
05A8:  RCALL  053A
.................... 	i2c_write(STREAM_MASTER,make8(value,1));
05AA:  MOVFF  76,79
05AE:  RCALL  053A
.................... 	i2c_write(STREAM_MASTER,make8(value,0));
05B0:  MOVFF  75,79
05B4:  RCALL  053A
.................... 	i2c_stop(STREAM_MASTER);
05B6:  BCF    F94.0
05B8:  NOP   
05BA:  BSF    F94.1
05BC:  BTFSS  F82.1
05BE:  BRA    05BC
05C0:  NOP   
05C2:  BRA    05C4
05C4:  NOP   
05C6:  BSF    F94.0
05C8:  NOP   
05CA:  RETURN 0
.................... }
.................... 
.................... void ina228_init(int8 i2c_address) {
.................... 	/* 
.................... 	INA228_REG_CONFIG (from table 7-5 in INA228 datasheet
.................... 		bit[15]            RST      (R/W) Reset bit
.................... 		bit[14]            RSTACC   (R/W) Resets the contents of accumulation registers ENERGY and CHARGE to 0
.................... 		bit[13] to bit[ 6] CONDLY   (R/W) Sets the Delay for initial ADC conversion in steps of 2 ms
....................                                           0h = 0 s
....................                                           1h = 2 ms
....................                                           FFh = 510 ms
.................... 		bit[ 5]            TEMPCOMP (R/W) Enables temperature compensation of an external shunt 
.................... 		bit[ 4]            ADCRANGE (R/W) Shunt full scale range selection across IN+ and IN–
....................                                           0h = ±163.84 mV
....................                                           1h = ± 40.96 mV
.................... 		bit[ 3] to bit[ 0] RESERVED (R)   Reserved. Always reads 0
....................  	*/
.................... 
.................... 	/* note that issuing a reset bit to INA228_REG_CONFIG will cause it to reset and apparently ignore the rest of the config */
.................... 
.................... 	/* no resets, no conversion delay, no shunt temperature compensation, +-40.96mV range */
.................... #if ADCRANGE == 1
.................... 	ina228_write16(i2c_address,INA228_REG_CONFIG,0b0000000000010000);
05CC:  MOVFF  72,73
05D0:  CLRF   x74
05D2:  CLRF   x76
05D4:  MOVLW  10
05D6:  MOVWF  x75
05D8:  RCALL  0582
.................... //                                                 5432109876543210
.................... //                                                 1     0
.................... #else
.................... 	ina228_write16(i2c_address,INA228_REG_CONFIG,0x00);
.................... #endif
.................... 
.................... 	/* continuous measurements, longest conversion time for voltages, shortest for temperature, 128 averaging window */
.................... 	ina228_write16(i2c_address,INA228_REG_ADC_CONFIG,0b1111111111000100);
05DA:  MOVFF  72,73
05DE:  MOVLW  01
05E0:  MOVWF  x74
05E2:  SETF   x76
05E4:  MOVLW  C4
05E6:  MOVWF  x75
05E8:  RCALL  0582
05EA:  RETURN 0
.................... 
.................... }
.................... 
.................... #include "i2c_handler_dcswc_module_voltage_current_counter.c"
.................... #include "registers_dcswc_module_voltage_current_counter.h"
.................... /* 32 bit INA228 bus and shunt voltages */
.................... #define I2C_REG_VBUS_A_MSW                    0
.................... #define I2C_REG_VBUS_A_LSW                    1
.................... #define I2C_REG_VSHUNT_A_MSW                  2
.................... #define I2C_REG_VSHUNT_A_LSW                  3
.................... 
.................... #define I2C_REG_VBUS_B_MSW                    4
.................... #define I2C_REG_VBUS_B_LSW                    5
.................... #define I2C_REG_VSHUNT_B_MSW                  6
.................... #define I2C_REG_VSHUNT_B_LSW                  7
.................... 
.................... /* 16 bit count of last (not current) second */
.................... #define I2C_REG_COUNT_A_LAST_SECOND           8
.................... #define I2C_REG_COUNT_B_LAST_SECOND           9
.................... 
.................... /* 32 bit count since reset */
.................... #define I2C_REG_COUNT_A_LONG_MSW              10
.................... #define I2C_REG_COUNT_A_LONG_LSW              11
.................... #define I2C_REG_COUNT_B_LONG_MSW              12
.................... #define I2C_REG_COUNT_B_LONG_LSW              13
.................... 
.................... /* 32 bit seconds since count reset */
.................... #define I2C_REG_COUNT_LONG_SECONDS_MSW        14
.................... #define I2C_REG_COUNT_LONG_SECONDS_LSW        15
.................... 
.................... /* 16 bit INA228 die temperatures */
.................... #define I2C_REG_DIETEMP_A                     16
.................... #define I2C_REG_DIETEMP_B                     17
.................... 
.................... 
.................... 
.................... /* test scratchpad registers for validating I2C communications */
.................... //int16 rtest[8] = { 0x0001, 0x0203, 0x0405, 0x0607, 0x0809, 0x0a0b, 0x0c0d, 0x0e0f };
.................... 
.................... 
.................... void write_i2c(int8 address, int16 value) {
.................... 	
.................... 	switch ( address ) {
*
01B2:  MOVF   x82,W
01B4:  XORLW  0E
01B6:  BZ    01BE
01B8:  XORLW  01
01BA:  BZ    01BE
01BC:  BRA    01D6
.................... #if 0
.................... 		case 0: rtest[0]=value; break;
.................... 		case 1: rtest[1]=value; break;
.................... 		case 2: rtest[2]=value; break;
.................... 		case 3: rtest[3]=value; break;
.................... 		case 4: rtest[4]=value; break;
.................... 		case 5: rtest[5]=value; break;
.................... 		case 6: rtest[6]=value; break;
.................... 		case 7: rtest[7]=value; break;
.................... #endif
.................... 
.................... 		/* write anything to either of these addresses and we reset the long counter */
.................... 		case I2C_REG_COUNT_LONG_SECONDS_MSW:
.................... 		case I2C_REG_COUNT_LONG_SECONDS_LSW:
.................... 			current.count_a_long=0;
01BE:  CLRF   31
01C0:  CLRF   30
01C2:  CLRF   2F
01C4:  CLRF   2E
.................... 			current.count_b_long=0;
01C6:  CLRF   35
01C8:  CLRF   34
01CA:  CLRF   33
01CC:  CLRF   32
.................... 			current.count_seconds_long=0;
01CE:  CLRF   39
01D0:  CLRF   38
01D2:  CLRF   37
01D4:  CLRF   36
.................... 			break;
.................... 		default:
.................... 			/* do nothing */
.................... 	}
01D6:  GOTO   041E (RETURN)
.................... 
.................... }
.................... 
.................... 
.................... int16 map_i2c(int8 addr) {
.................... 	static int16 lsw=0xffff;
.................... 
.................... 	timers.led_on_a=100;
01DA:  MOVLW  64
01DC:  MOVWF  x63
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 	switch ( addr ) {
01DE:  MOVF   x80,W
01E0:  BZ    023C
01E2:  XORLW  01
01E4:  BZ    025A
01E6:  XORLW  03
01E8:  BZ    0264
01EA:  XORLW  01
01EC:  BZ    0284
01EE:  XORLW  07
01F0:  BZ    028E
01F2:  XORLW  01
01F4:  BZ    02AC
01F6:  XORLW  03
01F8:  BZ    02B6
01FA:  XORLW  01
01FC:  BZ    02D4
01FE:  XORLW  0F
0200:  BTFSC  FD8.2
0202:  BRA    02DE
0204:  XORLW  01
0206:  BTFSC  FD8.2
0208:  BRA    02E8
020A:  XORLW  03
020C:  BTFSC  FD8.2
020E:  BRA    02F2
0210:  XORLW  01
0212:  BTFSC  FD8.2
0214:  BRA    0310
0216:  XORLW  07
0218:  BTFSC  FD8.2
021A:  BRA    031A
021C:  XORLW  01
021E:  BTFSC  FD8.2
0220:  BRA    0338
0222:  XORLW  03
0224:  BTFSC  FD8.2
0226:  BRA    0342
0228:  XORLW  01
022A:  BTFSC  FD8.2
022C:  BRA    0360
022E:  XORLW  1F
0230:  BTFSC  FD8.2
0232:  BRA    036A
0234:  XORLW  01
0236:  BTFSC  FD8.2
0238:  BRA    0374
023A:  BRA    037E
.................... #if 0
.................... 		case 0: return rtest[0];
.................... 		case 1: return rtest[1];
.................... 		case 2: return rtest[2];
.................... 		case 3: return rtest[3];
.................... 		case 4: return rtest[4];
.................... 		case 5: return rtest[5];
.................... 		case 6: return rtest[6];
.................... 		case 7: return rtest[7];
.................... #endif
.................... 
.................... 		/* 32 bit variables have the most significant word read first and that sets the
.................... 		   least sinificant word which can be read next. _LSW registers are only valid if
.................... 		   they are preceeded by a read on the matching _MSW register
.................... 		 */
.................... 		case I2C_REG_VBUS_A_MSW:
.................... 			lsw = make16(make8(current.vbus_a,1),make8(current.vbus_a,0));
023C:  MOVFF  1B,65
0240:  MOVFF  1A,64
.................... 			return (int16) make16(make8(current.vbus_a,3),make8(current.vbus_a,2));
0244:  MOVFF  1D,81
0248:  MOVFF  1C,82
024C:  MOVFF  1D,03
0250:  MOVFF  1C,01
0254:  MOVFF  1D,02
0258:  BRA    0384
.................... 		case I2C_REG_VBUS_A_LSW:
.................... 			return (int16) lsw;
025A:  MOVFF  64,01
025E:  MOVFF  65,02
0262:  BRA    0384
.................... 		case I2C_REG_VSHUNT_A_MSW:
.................... 			timers.now_dump=1;
0264:  BSF    x62.2
.................... 			lsw = make16(make8(current.vshunt_a,1),make8(current.vshunt_a,0));
0266:  MOVFF  1F,65
026A:  MOVFF  1E,64
.................... 			return (int16) make16(make8(current.vshunt_a,3),make8(current.vshunt_a,2));
026E:  MOVFF  21,81
0272:  MOVFF  20,82
0276:  MOVFF  21,03
027A:  MOVFF  20,01
027E:  MOVFF  21,02
0282:  BRA    0384
.................... 		case I2C_REG_VSHUNT_A_LSW:
.................... 			return (int16) lsw;    
0284:  MOVFF  64,01
0288:  MOVFF  65,02
028C:  BRA    0384
.................... 
.................... 		case I2C_REG_VBUS_B_MSW:
.................... 			lsw = make16(make8(current.vbus_b,1),make8(current.vbus_b,0));
028E:  MOVFF  23,65
0292:  MOVFF  22,64
.................... 			return (int16) make16(make8(current.vbus_b,3),make8(current.vbus_b,2));
0296:  MOVFF  25,81
029A:  MOVFF  24,82
029E:  MOVFF  25,03
02A2:  MOVFF  24,01
02A6:  MOVFF  25,02
02AA:  BRA    0384
.................... 		case I2C_REG_VBUS_B_LSW:
.................... 			return (int16) lsw;
02AC:  MOVFF  64,01
02B0:  MOVFF  65,02
02B4:  BRA    0384
.................... 		case I2C_REG_VSHUNT_B_MSW:
.................... 			lsw = make16(make8(current.vshunt_b,1),make8(current.vshunt_b,0));
02B6:  MOVFF  27,65
02BA:  MOVFF  26,64
.................... 			return (int16) make16(make8(current.vshunt_b,3),make8(current.vshunt_b,2));
02BE:  MOVFF  29,81
02C2:  MOVFF  28,82
02C6:  MOVFF  29,03
02CA:  MOVFF  28,01
02CE:  MOVFF  29,02
02D2:  BRA    0384
.................... 		case I2C_REG_VSHUNT_B_LSW:
.................... 			return (int16) lsw;    
02D4:  MOVFF  64,01
02D8:  MOVFF  65,02
02DC:  BRA    0384
.................... 
.................... 
.................... 		case I2C_REG_COUNT_A_LAST_SECOND:
.................... 			return (int16) current.count_a_last_second;
02DE:  MOVFF  2A,01
02E2:  MOVFF  2B,02
02E6:  BRA    0384
.................... 		case I2C_REG_COUNT_B_LAST_SECOND:
.................... 			return (int16) current.count_b_last_second;
02E8:  MOVFF  2C,01
02EC:  MOVFF  2D,02
02F0:  BRA    0384
.................... 
.................... 		case I2C_REG_COUNT_A_LONG_MSW:
.................... 			lsw = make16(make8(current.count_a_long,1),make8(current.count_a_long,0));
02F2:  MOVFF  2F,65
02F6:  MOVFF  2E,64
.................... 			return (int16) make16(make8(current.count_a_long,3),make8(current.count_a_long,2));
02FA:  MOVFF  31,81
02FE:  MOVFF  30,82
0302:  MOVFF  31,03
0306:  MOVFF  30,01
030A:  MOVFF  31,02
030E:  BRA    0384
.................... 		case I2C_REG_COUNT_A_LONG_LSW:
.................... 			return (int16) lsw;
0310:  MOVFF  64,01
0314:  MOVFF  65,02
0318:  BRA    0384
.................... 		case I2C_REG_COUNT_B_LONG_MSW:
.................... 			lsw = make16(make8(current.count_b_long,1),make8(current.count_b_long,0));
031A:  MOVFF  33,65
031E:  MOVFF  32,64
.................... 			return (int16) make16(make8(current.count_b_long,3),make8(current.count_b_long,2));
0322:  MOVFF  35,81
0326:  MOVFF  34,82
032A:  MOVFF  35,03
032E:  MOVFF  34,01
0332:  MOVFF  35,02
0336:  BRA    0384
.................... 		case I2C_REG_COUNT_B_LONG_LSW:
.................... 			return (int16) lsw;
0338:  MOVFF  64,01
033C:  MOVFF  65,02
0340:  BRA    0384
.................... 		case I2C_REG_COUNT_LONG_SECONDS_MSW:
.................... 			lsw = make16(make8(current.count_seconds_long,1),make8(current.count_seconds_long,0));
0342:  MOVFF  37,65
0346:  MOVFF  36,64
.................... 			return (int16) make16(make8(current.count_seconds_long,3),make8(current.count_seconds_long,2));
034A:  MOVFF  39,81
034E:  MOVFF  38,82
0352:  MOVFF  39,03
0356:  MOVFF  38,01
035A:  MOVFF  39,02
035E:  BRA    0384
.................... 		case I2C_REG_COUNT_LONG_SECONDS_LSW:
.................... 			return (int16) lsw;
0360:  MOVFF  64,01
0364:  MOVFF  65,02
0368:  BRA    0384
.................... 
.................... 		case I2C_REG_DIETEMP_A:
.................... 			return (int16) current.dietemp_a;
036A:  MOVFF  3A,01
036E:  MOVFF  3B,02
0372:  BRA    0384
.................... 		case I2C_REG_DIETEMP_B:
.................... 			return (int16) current.dietemp_b;
0374:  MOVFF  3C,01
0378:  MOVFF  3D,02
037C:  BRA    0384
.................... 
.................... 		/* we should have range checked, and never gotten here ... or read unimplemented (future) register */
.................... 		default: return (int16) addr;
037E:  MOVFF  80,01
0382:  CLRF   02
.................... 	}
0384:  GOTO   0432 (RETURN)
.................... 
.................... }
.................... 
.................... 
.................... 
.................... #include "interrupt_dcswc_module_voltage_current_counter.c"
.................... #int_timer2
.................... void isr_timer2() {
.................... 	static int16 ticks=0;
.................... 	static short count_a_last=0;
.................... 	static short count_b_last=0;
.................... 	short count_a_now;
.................... 	short count_b_now;
.................... 
.................... 
.................... 	/* external input counting */
.................... 	count_a_now=input(COUNT_A);
*
00BA:  BSF    F94.4
00BC:  BCF    x7D.0
00BE:  BTFSC  F82.4
00C0:  BSF    x7D.0
.................... 	if ( 0 == count_a_now && 1 == count_a_last ) {
00C2:  BTFSC  x7D.0
00C4:  BRA    00D0
00C6:  BTFSS  x68.0
00C8:  BRA    00D0
.................... 		next.count_a_last_second++;
00CA:  INCF   4E,F
00CC:  BTFSC  FD8.2
00CE:  INCF   4F,F
.................... 	}
.................... 	count_a_last=count_a_now;
00D0:  BCF    x68.0
00D2:  BTFSC  x7D.0
00D4:  BSF    x68.0
.................... 
.................... 	count_b_now=input(COUNT_B);
00D6:  BSF    F94.5
00D8:  BCF    x7D.1
00DA:  BTFSC  F82.5
00DC:  BSF    x7D.1
.................... 	if ( 0 == count_b_now && 1 == count_b_last ) {
00DE:  BTFSC  x7D.1
00E0:  BRA    00EC
00E2:  BTFSS  x68.1
00E4:  BRA    00EC
.................... 		next.count_b_last_second++;
00E6:  INCF   50,F
00E8:  BTFSC  FD8.2
00EA:  INCF   51,F
.................... 	}
.................... 	count_b_last=count_b_now;
00EC:  BCF    x68.1
00EE:  BTFSC  x7D.1
00F0:  BSF    x68.1
.................... 
.................... 
.................... 	/* timing */
.................... 
.................... 	timers.now_millisecond=1;
00F2:  BSF    x62.0
.................... 
.................... 	ticks++;
00F4:  INCF   x66,F
00F6:  BTFSC  FD8.2
00F8:  INCF   x67,F
.................... 	if ( 500 == ticks ) {
00FA:  MOVF   x66,W
00FC:  SUBLW  F4
00FE:  BNZ   0108
0100:  DECFSZ x67,W
0102:  BRA    0108
.................... 		timers.now_ina=1;
0104:  BSF    x62.1
.................... 	} else if ( 1000 == ticks ) {
0106:  BRA    01AC
0108:  MOVF   x66,W
010A:  SUBLW  E8
010C:  BNZ   01AC
010E:  MOVF   x67,W
0110:  SUBLW  03
0112:  BNZ   01AC
.................... 		current.vbus_a=next.vbus_a;
0114:  MOVFF  41,1D
0118:  MOVFF  40,1C
011C:  MOVFF  3F,1B
0120:  MOVFF  3E,1A
.................... 		current.vshunt_a=next.vshunt_a;
0124:  MOVFF  45,21
0128:  MOVFF  44,20
012C:  MOVFF  43,1F
0130:  MOVFF  42,1E
.................... 		current.dietemp_a=next.dietemp_a;	
0134:  MOVFF  5F,3B
0138:  MOVFF  5E,3A
.................... 
.................... 		current.vbus_b=next.vbus_b;
013C:  MOVFF  49,25
0140:  MOVFF  48,24
0144:  MOVFF  47,23
0148:  MOVFF  46,22
.................... 		current.vshunt_b=next.vshunt_b;
014C:  MOVFF  4D,29
0150:  MOVFF  4C,28
0154:  MOVFF  4B,27
0158:  MOVFF  4A,26
.................... 		current.dietemp_b=next.dietemp_b;
015C:  MOVFF  61,3D
0160:  MOVFF  60,3C
.................... 
.................... 		current.count_a_last_second=next.count_a_last_second;
0164:  MOVFF  4F,2B
0168:  MOVFF  4E,2A
.................... 
.................... 		current.count_b_last_second=next.count_b_last_second;	
016C:  MOVFF  51,2D
0170:  MOVFF  50,2C
.................... 
.................... 		current.count_a_long += current.count_a_last_second;
0174:  MOVF   2A,W
0176:  ADDWF  2E,F
0178:  MOVF   2B,W
017A:  ADDWFC 2F,F
017C:  MOVLW  00
017E:  ADDWFC 30,F
0180:  ADDWFC 31,F
.................... 		current.count_b_long += current.count_b_last_second;
0182:  MOVF   2C,W
0184:  ADDWF  32,F
0186:  MOVF   2D,W
0188:  ADDWFC 33,F
018A:  MOVLW  00
018C:  ADDWFC 34,F
018E:  ADDWFC 35,F
.................... 	
.................... 		current.count_seconds_long++;
0190:  MOVLW  01
0192:  ADDWF  36,F
0194:  BTFSC  FD8.0
0196:  INCF   37,F
0198:  BTFSC  FD8.2
019A:  INCF   38,F
019C:  BTFSC  FD8.2
019E:  INCF   39,F
.................... 
.................... 		/* reset our counters */
.................... 		next.count_a_last_second=0;
01A0:  CLRF   4F
01A2:  CLRF   4E
.................... 		next.count_b_last_second=0;
01A4:  CLRF   51
01A6:  CLRF   50
.................... 
.................... 		ticks=0;
01A8:  CLRF   x67
01AA:  CLRF   x66
.................... 	}
.................... }
.................... 
.................... 
.................... /* I2C slave interrupt */
01AC:  BCF    F9E.1
01AE:  GOTO   006C
.................... #byte SSPSTAT=GETENV("SFR:SSPSTAT")
.................... #INT_SSP
.................... void ssp_interrupt () {
.................... 	static int8 sstate;
.................... 	int8 state;
.................... 	int8 incoming;
.................... 	static int16 lastValue;
.................... 	static int8 lastMSB;
.................... 
.................... 	static int8 address; 
.................... 
.................... 	/* 
.................... 	our implementation of i2c_isr_state() that won't overflow and switch states
.................... 	but it will quit counting at 127 bytes. 
.................... 	If more bytes are needed, external counting variables can be used or the size of state can be made larger
.................... 	*/
.................... 
.................... 
.................... 	if ( ! bit_test(SSPSTAT,5) ) {
*
039E:  BTFSC  FC7.5
03A0:  BRA    03AA
.................... 		/* address */
.................... 		sstate=0;
03A2:  CLRF   x69
.................... 
.................... 		if ( bit_test(SSPSTAT,2) ) {
03A4:  BTFSS  FC7.2
03A6:  BRA    03AA
.................... 			/* set high bit if read */
.................... 			bit_set(sstate,7);
03A8:  BSF    x69.7
.................... 		}
.................... 	} else {
.................... 		/* data */
.................... 	}
.................... 
.................... 	/* state variable used below is not incremented */
.................... 	state=sstate;
03AA:  MOVFF  69,7D
.................... 
.................... 	/* increment the state counter for next pass through unless it will overflow us into another state */
.................... 	if ( sstate != 0x7f && sstate != 0xff) {
03AE:  MOVF   x69,W
03B0:  SUBLW  7F
03B2:  BZ    03BC
03B4:  INCFSZ x69,W
03B6:  BRA    03BA
03B8:  BRA    03BC
.................... 		sstate++;
03BA:  INCF   x69,F
.................... 	}
.................... 
.................... 	
.................... 	/* i2c_isr_state() return an 8 bit int
.................... 		0 - Address match received with R/W bit clear, perform i2c_read( ) to read the I2C address.
.................... 		1-0x7F - Master has written data; i2c_read() will immediately return the data
.................... 		0x80 - Address match received with R/W bit set; perform i2c_read( ) to read the I2C address,
.................... 		and use i2c_write( ) to pre-load the transmit buffer for the next transaction (next I2C read
.................... 		performed by master will read this byte).
.................... 		0x81-0xFF - Transmission completed and acknowledged; respond with i2c_write() to pre-load
.................... 		the transmit buffer for the next transition (the next I2C read performed by master will read this
.................... 		byte).
.................... 		Function:
.................... 		Returns the state of I2C communications in I2C slave mode after an SSP interrupt. The return
.................... 		value increments with each byte received or sent.
.................... 		If 0x00 or 0x80 is returned, an i2C_read( ) needs to be performed to read the I2C address that
.................... 		was sent (it will match the address configured by #USE I2C so this value can be ignored)
.................... 	*/
.................... 
.................... 	if ( state <= 0x80 ) {                      
03BC:  MOVF   x7D,W
03BE:  SUBLW  80
03C0:  BNC   041E
.................... 		/* I2C master is sending us data */
.................... 		if ( 0x80 == state ) {
03C2:  MOVF   x7D,W
03C4:  SUBLW  80
03C6:  BNZ   03CE
.................... 			/* i2c_read(2) casues the function to read the SSPBUF without releasing the clock */
.................... 			incoming = i2c_read(STREAM_SLAVE,2);
03C8:  MOVFF  FC9,7E
.................... 		} else {
03CC:  BRA    03DA
.................... 			incoming = i2c_read(STREAM_SLAVE);
03CE:  BCF    FC6.6
03D0:  BTFSS  FC7.0
03D2:  BRA    03D0
03D4:  MOVF   FC9,W
03D6:  BSF    FC6.4
03D8:  MOVWF  x7E
.................... 		}
.................... 
.................... 		if ( 1 == state ) {             
03DA:  DECFSZ x7D,W
03DC:  BRA    03E6
.................... 			address = incoming<<1;
03DE:  BCF    FD8.0
03E0:  RLCF   x7E,W
03E2:  MOVWF  x6D
.................... 		} else if ( state >= 2 && 0x80 != state ) {
03E4:  BRA    041E
03E6:  MOVF   x7D,W
03E8:  SUBLW  01
03EA:  BC    041E
03EC:  MOVF   x7D,W
03EE:  SUBLW  80
03F0:  BZ    041E
.................... 			/* received byte is data */
.................... 		
.................... 			/* save MSB and we'll process it on next */
.................... 			if ( 2 == state ) {
03F2:  MOVF   x7D,W
03F4:  SUBLW  02
03F6:  BNZ   03FE
.................... 				lastMSB=incoming;
03F8:  MOVFF  7E,6C
.................... 			} else if ( 3 == state ) {
03FC:  BRA    041E
03FE:  MOVF   x7D,W
0400:  SUBLW  03
0402:  BNZ   041E
.................... 				/* 16 bit value made of previous byte and this byte */
.................... 				write_i2c(address>>1,make16(lastMSB,incoming));
0404:  BCF    FD8.0
0406:  RRCF   x6D,W
0408:  MOVWF  x7F
040A:  MOVFF  6C,81
040E:  MOVFF  7E,80
0412:  MOVWF  x82
0414:  MOVFF  6C,84
0418:  MOVFF  7E,83
041C:  BRA    01B2
.................... 
.................... 				/* this write only works for a single register per I2C transaction */
.................... 				/* this is not a BUG, but it would need to be implemented if this functionality is needed */
.................... 			}
.................... 		}
.................... 	}
.................... 
.................... 
.................... 	if ( state >= 0x80 ) {
041E:  MOVF   x7D,W
0420:  SUBLW  7F
0422:  BC    044A
.................... 		/* I2C master is requesting data from us */
.................... 
.................... 		if ( ! bit_test(address,0) ) {
0424:  BTFSC  x6D.0
0426:  BRA    0442
.................... 			/* read 16 bit register (register address half of I2C address) on even address */
.................... 			lastValue=map_i2c(address>>1);
0428:  BCF    FD8.0
042A:  RRCF   x6D,W
042C:  MOVWF  x7F
042E:  MOVWF  x80
0430:  BRA    01DA
0432:  MOVFF  02,6B
0436:  MOVFF  01,6A
.................... 
.................... 			/* send the MSB */
.................... 			i2c_write(STREAM_SLAVE,make8(lastValue,1));
043A:  MOVFF  6B,80
043E:  RCALL  0388
.................... 		} else {
0440:  BRA    0448
.................... 			/* send LSB of 16 bit register on odd address */
.................... 			i2c_write(STREAM_SLAVE,make8(lastValue,0));
0442:  MOVFF  6A,80
0446:  RCALL  0388
.................... 		}
.................... 		address++;
0448:  INCF   x6D,F
.................... 	}
044A:  BCF    F9E.3
044C:  GOTO   006C
.................... }
.................... 
.................... 
.................... int8 read_dip_switch(void) {
.................... 	/* nomenclature is backwards on netlist. We actually want LSB on top */
.................... 	return ( ! input(PIC_ADDR_LSB)<<1 ) | ( ! input(PIC_ADDR_MSB) );
*
051C:  BSF    F94.7
051E:  MOVLW  00
0520:  BTFSS  F82.7
0522:  MOVLW  01
0524:  MOVWF  00
0526:  BCF    FD8.0
0528:  RLCF   00,W
052A:  MOVWF  x72
052C:  BSF    F94.6
052E:  MOVLW  00
0530:  BTFSS  F82.6
0532:  MOVLW  01
0534:  IORWF  x72,W
0536:  MOVWF  01
0538:  RETURN 0
.................... }
.................... 
.................... void init(void) {
.................... 	setup_vref(VREF_OFF);
*
05EC:  CLRF   FBA
.................... 	setup_dac(DAC_OFF);
05EE:  CLRF   FBB
.................... 	setup_adc(ADC_OFF);
05F0:  BCF    FC2.0
.................... 	setup_adc_ports(NO_ANALOGS);
05F2:  MOVLW  00
05F4:  MOVWF  F7E
05F6:  BCF    FC1.0
05F8:  BCF    FC1.1
05FA:  BCF    FC1.2
05FC:  BCF    FC1.3
05FE:  MOVWF  F7F
.................... 
.................... 	setup_wdt(WDT_512MS);
0600:  BSF    FD1.0
.................... 
.................... 
.................... 	set_tris_a    (0b00111111);
0602:  MOVLW  3F
0604:  MOVWF  F92
.................... 	port_a_pullups(0b00110000);
0606:  MOVLW  30
0608:  MOVWF  F77
060A:  BCF    FF1.7
.................... //                   76543210
.................... 
.................... 	set_tris_b    (0b01110000);
060C:  MOVLW  70
060E:  MOVWF  F93
.................... 	port_b_pullups(0b00000000);
0610:  CLRF   F78
.................... //                   76543210
.................... 
.................... 	set_tris_c    (0b11110011);
0612:  MOVLW  F3
0614:  MOVWF  F94
.................... //                   76543210
.................... 
.................... 
.................... 	/* data structure initialization */
.................... 	/* all initialized to 0 on declaration. Just do this if need non-zero */
.................... 
.................... 
.................... 	/* one periodic interrupt @ 1mS. Generated from system 16 MHz clock */
.................... 	/* prescale=16, match=249, postscale=1. Match is 249 because when match occurs, one cycle is lost */
.................... 	setup_timer_2(T2_DIV_BY_16,249,1);
0616:  MOVLW  00
0618:  IORLW  06
061A:  MOVWF  FCA
061C:  MOVLW  F9
061E:  MOVWF  FCB
.................... 
.................... 	enable_interrupts(INT_TIMER2);
0620:  BSF    F9D.1
.................... 
.................... 	/* set I2C slave address, which is always an even number */
.................... 	i2c_slaveaddr(0x36 + (read_dip_switch()<<1) );
0622:  RCALL  051C
0624:  BCF    FD8.0
0626:  RLCF   01,W
0628:  ADDLW  36
062A:  MOVWF  FC8
.................... 
.................... 
.................... 	/* initialize ina228 chips */
.................... 	ina228_init(INA228_A_ADDR);
062C:  MOVLW  80
062E:  MOVWF  x72
0630:  RCALL  05CC
.................... 	ina228_init(INA228_B_ADDR);
0632:  MOVLW  9A
0634:  MOVWF  x72
0636:  RCALL  05CC
0638:  GOTO   09AC (RETURN)
.................... 
.................... }
.................... 
.................... 
.................... void action_now_ina(void) {
.................... 	timers.now_ina=0;
*
0856:  BCF    x62.1
.................... 
.................... 	/* sample INA228 at middle of 1 second window */
.................... 	next.vbus_a  =ina228_read24(INA228_A_ADDR,INA228_REG_VBUS);
0858:  MOVLW  80
085A:  MOVWF  x72
085C:  MOVLW  05
085E:  MOVWF  x73
0860:  RCALL  0732
0862:  MOVFF  03,41
0866:  MOVFF  02,40
086A:  MOVFF  01,3F
086E:  MOVFF  00,3E
.................... 	next.vshunt_a=ina228_read24(INA228_A_ADDR,INA228_REG_VSHUNT);
0872:  MOVLW  80
0874:  MOVWF  x72
0876:  MOVLW  04
0878:  MOVWF  x73
087A:  RCALL  0732
087C:  MOVFF  03,45
0880:  MOVFF  02,44
0884:  MOVFF  01,43
0888:  MOVFF  00,42
.................... 
.................... 	next.vbus_b  =ina228_read24(INA228_B_ADDR,INA228_REG_VBUS);
088C:  MOVLW  9A
088E:  MOVWF  x72
0890:  MOVLW  05
0892:  MOVWF  x73
0894:  RCALL  0732
0896:  MOVFF  03,49
089A:  MOVFF  02,48
089E:  MOVFF  01,47
08A2:  MOVFF  00,46
.................... 	next.vshunt_b=ina228_read24(INA228_B_ADDR,INA228_REG_VSHUNT);
08A6:  MOVLW  9A
08A8:  MOVWF  x72
08AA:  MOVLW  04
08AC:  MOVWF  x73
08AE:  RCALL  0732
08B0:  MOVFF  03,4D
08B4:  MOVFF  02,4C
08B8:  MOVFF  01,4B
08BC:  MOVFF  00,4A
.................... 
.................... 	next.dietemp_a=ina228_read16(INA228_A_ADDR,INA228_REG_DIETEMP);
08C0:  MOVLW  80
08C2:  MOVWF  x72
08C4:  MOVLW  06
08C6:  MOVWF  x73
08C8:  RCALL  07D0
08CA:  MOVFF  02,5F
08CE:  MOVFF  01,5E
.................... 	next.dietemp_b=ina228_read16(INA228_B_ADDR,INA228_REG_DIETEMP);
08D2:  MOVLW  9A
08D4:  MOVWF  x72
08D6:  MOVLW  06
08D8:  MOVWF  x73
08DA:  RCALL  07D0
08DC:  MOVFF  02,61
08E0:  MOVFF  01,60
.................... 
.................... #if ADCRANGE == 1 
.................... 	/* set low bit of high word (bit 24) to indicate we have +-40.96mV shunt range */
.................... 	bit_set(next.vshunt_a,24);
08E4:  BSF    45.0
.................... 	bit_set(next.vshunt_b,24);
08E6:  BSF    4D.0
.................... #else
08E8:  GOTO   0AC8 (RETURN)
.................... 	/* systems with +-163.84mV shunt range have bit 24 cleared. Or older firmwares don't implement this and that bit
.................... 	will be 0 by default */
.................... 	bit_clear(next.vshunt_a,24);
.................... 	bit_clear(next.vshunt_b,24);
.................... #endif
.................... }
.................... 
.................... 
.................... void periodic_millisecond(void) {
.................... 	timers.now_millisecond=0;
08EC:  BCF    x62.0
.................... 
.................... 	/* LED control */
.................... 	if ( 0==timers.led_on_a ) {
08EE:  MOVF   x63,F
08F0:  BNZ   08F8
.................... 		output_low(LED_A);
08F2:  BCF    F94.3
08F4:  BCF    F8B.3
.................... 	} else {
08F6:  BRA    08FE
.................... 		output_high(LED_A);
08F8:  BCF    F94.3
08FA:  BSF    F8B.3
.................... 		timers.led_on_a--;
08FC:  DECF   x63,F
.................... 	}
08FE:  GOTO   0ACE (RETURN)
.................... 
.................... 
.................... }
.................... 
.................... 
.................... void main(void) {
0902:  CLRF   FF8
0904:  BCF    FD0.7
0906:  BSF    07.7
0908:  BSF    F93.6
090A:  BSF    F93.4
090C:  CLRF   FC8
090E:  MOVLW  36
0910:  MOVWF  FC6
0912:  BSF    FC5.0
0914:  BSF    FC5.7
0916:  CLRF   19
0918:  BSF    FB8.3
091A:  MOVLW  A0
091C:  MOVWF  FAF
091E:  MOVLW  01
0920:  MOVWF  FB0
0922:  MOVLW  A6
0924:  MOVWF  FAC
0926:  MOVLW  90
0928:  MOVWF  FAB
092A:  CLRF   x6F
092C:  CLRF   x6E
092E:  MOVLW  00
0930:  MOVWF  F7E
0932:  BCF    FC1.0
0934:  BCF    FC1.1
0936:  BCF    FC1.2
0938:  BCF    FC1.3
093A:  MOVWF  F7F
093C:  CLRF   F6C
093E:  CLRF   F6B
0940:  CLRF   F6D
0942:  BCF    x68.0
0944:  BCF    x68.1
0946:  BRA    0958
0948:  DATA 4A,40
094A:  DATA 1A,00
094C:  DATA 04,80
094E:  DATA FF,FF
0950:  DATA 00,00
0952:  DATA 05,40
0954:  DATA 69,00
0956:  DATA 00,00
0958:  MOVLW  00
095A:  MOVWF  FF8
095C:  MOVLW  09
095E:  MOVWF  FF7
0960:  MOVLW  48
0962:  MOVWF  FF6
0964:  TBLRD*+
0966:  MOVF   FF5,W
0968:  MOVWF  00
096A:  XORLW  00
096C:  BZ    0994
096E:  TBLRD*+
0970:  MOVF   FF5,W
0972:  MOVWF  01
0974:  BTFSC  FE8.7
0976:  BRA    0982
0978:  ANDLW  3F
097A:  MOVWF  FEA
097C:  TBLRD*+
097E:  MOVFF  FF5,FE9
0982:  BTFSC  01.6
0984:  TBLRD*+
0986:  BTFSS  01.6
0988:  TBLRD*+
098A:  MOVFF  FF5,FEE
098E:  DCFSNZ 00,F
0990:  BRA    0964
0992:  BRA    0986
0994:  CLRF   FF8
.................... 	int8 restart_cause;
.................... 	int8 i;
.................... 
.................... 	restart_cause=restart_cause();
0996:  MOVF   FD0,W
0998:  ANDLW  0F
099A:  BTFSS  FD0.4
099C:  MOVLW  00
099E:  BSF    FD0.0
09A0:  BSF    FD0.1
09A2:  BSF    FD0.4
09A4:  BSF    FD8.3
09A6:  BSF    FD8.4
09A8:  MOVWF  x70
.................... 
.................... 	init();
09AA:  BRA    05EC
.................... 
.................... 
.................... 
.................... 	/* flash on startup */
.................... 	for ( i=0 ; i<5 ; i++ ) {
09AC:  CLRF   x71
09AE:  MOVF   x71,W
09B0:  SUBLW  04
09B2:  BNC   09CE
.................... 		restart_wdt();
09B4:  CLRWDT
.................... 		output_high(LED_A);
09B6:  BCF    F94.3
09B8:  BSF    F8B.3
.................... 		delay_ms(200);
09BA:  MOVLW  C8
09BC:  MOVWF  x72
09BE:  RCALL  063C
.................... 		output_low(LED_A);
09C0:  BCF    F94.3
09C2:  BCF    F8B.3
.................... 		delay_ms(200);
09C4:  MOVLW  C8
09C6:  MOVWF  x72
09C8:  RCALL  063C
09CA:  INCF   x71,F
09CC:  BRA    09AE
.................... 	}
.................... 
.................... 	fprintf(STREAM_FTDI,"# dcswc_module_voltage_current_counter %s\r\n# ",__DATE__);
09CE:  MOVLW  50
09D0:  MOVWF  FF6
09D2:  MOVLW  04
09D4:  MOVWF  FF7
09D6:  MOVLW  27
09D8:  MOVWF  x73
09DA:  RCALL  0664
09DC:  MOVLW  7E
09DE:  MOVWF  FF6
09E0:  MOVLW  04
09E2:  MOVWF  FF7
09E4:  RCALL  0684
09E6:  MOVLW  79
09E8:  MOVWF  FF6
09EA:  MOVLW  04
09EC:  MOVWF  FF7
09EE:  MOVLW  04
09F0:  MOVWF  x73
09F2:  RCALL  0664
.................... 	switch ( restart_cause ) {
09F4:  MOVF   x70,W
09F6:  XORLW  07
09F8:  BZ    0A14
09FA:  XORLW  0C
09FC:  BZ    0A20
09FE:  XORLW  04
0A00:  BZ    0A2C
0A02:  XORLW  03
0A04:  BZ    0A38
0A06:  XORLW  02
0A08:  BZ    0A44
0A0A:  XORLW  0D
0A0C:  BZ    0A50
0A0E:  XORLW  03
0A10:  BZ    0A5C
0A12:  BRA    0A68
.................... 		case WDT_TIMEOUT:       fprintf(STREAM_FTDI,"WDT TIMEOUT"); break;
0A14:  MOVLW  88
0A16:  MOVWF  FF6
0A18:  MOVLW  04
0A1A:  MOVWF  FF7
0A1C:  RCALL  0684
0A1E:  BRA    0A72
.................... 		case MCLR_FROM_SLEEP:   fprintf(STREAM_FTDI,"MCLR FROM SLEEP"); break;
0A20:  MOVLW  94
0A22:  MOVWF  FF6
0A24:  MOVLW  04
0A26:  MOVWF  FF7
0A28:  RCALL  0684
0A2A:  BRA    0A72
.................... 		case MCLR_FROM_RUN:     fprintf(STREAM_FTDI,"MCLR FROM RUN"); break;
0A2C:  MOVLW  A4
0A2E:  MOVWF  FF6
0A30:  MOVLW  04
0A32:  MOVWF  FF7
0A34:  RCALL  0684
0A36:  BRA    0A72
.................... 		case NORMAL_POWER_UP:   fprintf(STREAM_FTDI,"NORMAL POWER UP"); break;
0A38:  MOVLW  B2
0A3A:  MOVWF  FF6
0A3C:  MOVLW  04
0A3E:  MOVWF  FF7
0A40:  RCALL  0684
0A42:  BRA    0A72
.................... 		case BROWNOUT_RESTART:  fprintf(STREAM_FTDI,"BROWNOUT RESTART"); break;
0A44:  MOVLW  C2
0A46:  MOVWF  FF6
0A48:  MOVLW  04
0A4A:  MOVWF  FF7
0A4C:  RCALL  0684
0A4E:  BRA    0A72
.................... 		case WDT_FROM_SLEEP:    fprintf(STREAM_FTDI,"WDT FROM SLEEP"); break;
0A50:  MOVLW  D4
0A52:  MOVWF  FF6
0A54:  MOVLW  04
0A56:  MOVWF  FF7
0A58:  RCALL  0684
0A5A:  BRA    0A72
.................... 		case RESET_INSTRUCTION: fprintf(STREAM_FTDI,"RESET INSTRUCTION"); break;
0A5C:  MOVLW  E4
0A5E:  MOVWF  FF6
0A60:  MOVLW  04
0A62:  MOVWF  FF7
0A64:  RCALL  0684
0A66:  BRA    0A72
.................... 		default:                fprintf(STREAM_FTDI,"UNKNOWN!");
0A68:  MOVLW  F6
0A6A:  MOVWF  FF6
0A6C:  MOVLW  04
0A6E:  MOVWF  FF7
0A70:  RCALL  0684
.................... 	}
.................... 	fprintf(STREAM_FTDI,"\r\n");
0A72:  MOVLW  0D
0A74:  BTFSS  F9E.4
0A76:  BRA    0A74
0A78:  MOVWF  FAD
0A7A:  MOVLW  0A
0A7C:  BTFSS  F9E.4
0A7E:  BRA    0A7C
0A80:  MOVWF  FAD
.................... 
.................... 	restart_wdt();
0A82:  CLRWDT
.................... 	fprintf(STREAM_FTDI,"# our I2C address=0x%02x\r\n",0x36 + (read_dip_switch()<<1));
0A84:  RCALL  051C
0A86:  BCF    FD8.0
0A88:  RLCF   01,W
0A8A:  ADDLW  36
0A8C:  MOVWF  x72
0A8E:  MOVLW  00
0A90:  MOVWF  FF6
0A92:  MOVLW  05
0A94:  MOVWF  FF7
0A96:  MOVLW  14
0A98:  MOVWF  x73
0A9A:  RCALL  0664
0A9C:  MOVFF  72,73
0AA0:  MOVLW  57
0AA2:  MOVWF  x74
0AA4:  BRA    06A6
0AA6:  MOVLW  0D
0AA8:  BTFSS  F9E.4
0AAA:  BRA    0AA8
0AAC:  MOVWF  FAD
0AAE:  MOVLW  0A
0AB0:  BTFSS  F9E.4
0AB2:  BRA    0AB0
0AB4:  MOVWF  FAD
.................... 
.................... 	timers.led_on_a=500;
0AB6:  MOVLW  F4
0AB8:  MOVWF  x63
.................... 
.................... 	enable_interrupts(GLOBAL);
0ABA:  MOVLW  C0
0ABC:  IORWF  FF2,F
.................... 
.................... 	/* enable I2C slave interrupt */
.................... 	enable_interrupts(INT_SSP);
0ABE:  BSF    F9D.3
.................... 
.................... 	for ( ; ; ) {
.................... 		restart_wdt();
0AC0:  CLRWDT
.................... 
.................... 		/* query INA228's for next */
.................... 		if ( timers.now_ina ) {
0AC2:  BTFSS  x62.1
0AC4:  BRA    0AC8
.................... 			action_now_ina();
0AC6:  BRA    0856
.................... 		}
.................... 
.................... 		if ( timers.now_millisecond ) {
0AC8:  BTFSS  x62.0
0ACA:  BRA    0ACE
.................... 			periodic_millisecond();
0ACC:  BRA    08EC
.................... 		}
.................... 
.................... #if 0
.................... 		if ( timers.now_dump ) {
.................... 			timers.now_dump=0;
.................... 
.................... 			fprintf(STREAM_FTDI,"# A: 0x%08lx / 0x%08lx / 0x%04lu\r\n",
.................... 				current.vbus_a,
.................... 				current.vshunt_a,
.................... 				current.dietemp_a
.................... 			);
.................... 		}
.................... #endif
.................... 
.................... #if 0
0ACE:  BRA    0AC0
.................... 		if ( kbhit() ) {
.................... 			getc();
.................... 
.................... 			fprintf(STREAM_FTDI,"# DIP SWITCHES: %d\r\n",
.................... 				read_dip_switch()
.................... 			);
.................... 
.................... 			fprintf(STREAM_FTDI,"# A: 0x%08lx / 0x%08lx / 0x%04lu\r\n",
.................... 				current.vbus_a,
.................... 				current.vshunt_a,
.................... 				current.dietemp_a
.................... 			);
.................... 			fprintf(STREAM_FTDI,"# B: 0x%08lx / 0x%08lx / 0x%04lu\r\n",
.................... 				current.vbus_b,
.................... 				current.vshunt_b,
.................... 				current.dietemp_b
.................... 			);
.................... 
.................... 			fprintf(STREAM_FTDI,"# current.count_a_last_second=%lu\r\n",
.................... 				current.count_a_last_second
.................... 			);
.................... 			fprintf(STREAM_FTDI,"# current.count_b_last_second=%lu\r\n",
.................... 				current.count_b_last_second
.................... 			);
.................... 			fprintf(STREAM_FTDI,"# current.count_a_long=%lu\r\n",
.................... 				current.count_a_long
.................... 			);
.................... 			fprintf(STREAM_FTDI,"# current.count_b_long=%lu\r\n",
.................... 				current.count_b_long
.................... 			);
.................... 
.................... 			fprintf(STREAM_FTDI,"# current.count_seconds_long=%lu\r\n",
.................... 				current.count_seconds_long
.................... 			);
.................... 
.................... 			fprintf(STREAM_FTDI,"# input(PIC_ADDR_MSB)=%u\r\n",input(PIC_ADDR_MSB));
.................... 			fprintf(STREAM_FTDI,"# input(PIC_ADDR_LSB)=%u\r\n",input(PIC_ADDR_LSB));
.................... 		}
.................... #endif
.................... 
.................... 
.................... 	}
.................... 
.................... 
.................... }
0AD0:  SLEEP 

Configuration Fuses:
   Word  1: 0200   HS NOPLLEN NOPCLKEN NOFCMEN NOIESO
   Word  2: 0F07   NOPUT BROWNOUT BORV30 WDT WDT128
   Word  3: 0000   NOHFOFST NOMCLR
   Word  4: 0081   STVREN NOLVP BBSIZ1K NOXINST NODEBUG
   Word  5: C003   NOPROTECT NOCPB NOCPD
   Word  6: E003   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 4003   NOEBTR NOEBTRB

ROM data:
F00000: 00 00 40 00                                        ..@.
