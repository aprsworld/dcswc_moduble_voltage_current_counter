CCS PCH C Compiler, Version 5.090, 49113               13-Jan-22 17:32

               Filename:   C:\Users\James Jarvis\Desktop\planetPrecision\dcswc_module_voltage_current_counter\dcswc_module_voltage_current_counter.lst

               ROM used:   2506 bytes (16%)
                           Largest free fragment is 13042
               RAM used:   114 (22%) at main() level
                           133 (26%) worst case
               Stack used: 4 locations (2 in main + 2 for interrupts)
               Stack size: 30

0000:  GOTO   0832
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  FF5,15
003C:  MOVFF  FF6,16
0040:  MOVFF  FF7,17
0044:  MOVFF  00,0E
0048:  MOVFF  01,0F
004C:  MOVFF  02,10
0050:  MOVFF  03,11
0054:  BTFSS  F9D.1
0056:  GOTO   0060
005A:  BTFSC  F9E.1
005C:  GOTO   00BA
0060:  BTFSS  F9D.3
0062:  GOTO   006C
0066:  BTFSC  F9E.3
0068:  GOTO   039E
006C:  MOVFF  0E,00
0070:  MOVFF  0F,01
0074:  MOVFF  10,02
0078:  MOVFF  11,03
007C:  MOVFF  0C,FE9
0080:  MOVFF  07,FEA
0084:  BSF    07.7
0086:  MOVFF  08,FE1
008A:  MOVFF  09,FE2
008E:  MOVFF  0A,FD9
0092:  MOVFF  0B,FDA
0096:  MOVFF  12,FF3
009A:  MOVFF  13,FF4
009E:  MOVFF  14,FFA
00A2:  MOVFF  15,FF5
00A6:  MOVFF  16,FF6
00AA:  MOVFF  17,FF7
00AE:  MOVF   04,W
00B0:  MOVFF  06,FE0
00B4:  MOVFF  05,FD8
00B8:  RETFIE 0
.................... #include "dcswc_module_voltage_current_counter.h"
.................... #include <18F14K22.h>
.................... //////////// Standard Header file for the PIC18F14K22 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18F14K22
*
0458:  DATA 23,20
045A:  DATA 64,63
045C:  DATA 73,77
045E:  DATA 63,5F
0460:  DATA 6D,6F
0462:  DATA 64,75
0464:  DATA 6C,65
0466:  DATA 5F,76
0468:  DATA 6F,6C
046A:  DATA 74,61
046C:  DATA 67,65
046E:  DATA 5F,63
0470:  DATA 75,72
0472:  DATA 72,65
0474:  DATA 6E,74
0476:  DATA 5F,63
0478:  DATA 6F,75
047A:  DATA 6E,74
047C:  DATA 65,72
047E:  DATA 20,25
0480:  DATA 73,0D
0482:  DATA 0A,23
0484:  DATA 20,00
0486:  DATA 31,33
0488:  DATA 2D,4A
048A:  DATA 61,6E
048C:  DATA 2D,32
048E:  DATA 32,00
0490:  DATA 57,44
0492:  DATA 54,20
0494:  DATA 54,49
0496:  DATA 4D,45
0498:  DATA 4F,55
049A:  DATA 54,00
049C:  DATA 4D,43
049E:  DATA 4C,52
04A0:  DATA 20,46
04A2:  DATA 52,4F
04A4:  DATA 4D,20
04A6:  DATA 53,4C
04A8:  DATA 45,45
04AA:  DATA 50,00
04AC:  DATA 4D,43
04AE:  DATA 4C,52
04B0:  DATA 20,46
04B2:  DATA 52,4F
04B4:  DATA 4D,20
04B6:  DATA 52,55
04B8:  DATA 4E,00
04BA:  DATA 4E,4F
04BC:  DATA 52,4D
04BE:  DATA 41,4C
04C0:  DATA 20,50
04C2:  DATA 4F,57
04C4:  DATA 45,52
04C6:  DATA 20,55
04C8:  DATA 50,00
04CA:  DATA 42,52
04CC:  DATA 4F,57
04CE:  DATA 4E,4F
04D0:  DATA 55,54
04D2:  DATA 20,52
04D4:  DATA 45,53
04D6:  DATA 54,41
04D8:  DATA 52,54
04DA:  DATA 00,00
04DC:  DATA 57,44
04DE:  DATA 54,20
04E0:  DATA 46,52
04E2:  DATA 4F,4D
04E4:  DATA 20,53
04E6:  DATA 4C,45
04E8:  DATA 45,50
04EA:  DATA 00,00
04EC:  DATA 52,45
04EE:  DATA 53,45
04F0:  DATA 54,20
04F2:  DATA 49,4E
04F4:  DATA 53,54
04F6:  DATA 52,55
04F8:  DATA 43,54
04FA:  DATA 49,4F
04FC:  DATA 4E,00
04FE:  DATA 55,4E
0500:  DATA 4B,4E
0502:  DATA 4F,57
0504:  DATA 4E,21
0506:  DATA 00,00
*
0594:  TBLRD*+
0596:  MOVFF  FF6,73
059A:  MOVFF  FF7,74
059E:  MOVF   FF5,W
05A0:  BTFSS  F9E.4
05A2:  BRA    05A0
05A4:  MOVWF  FAD
05A6:  MOVFF  73,FF6
05AA:  MOVFF  74,FF7
05AE:  DECFSZ x72,F
05B0:  BRA    0594
05B2:  RETURN 0
05B4:  TBLRD*+
05B6:  MOVF   FF5,F
05B8:  BZ    05D4
05BA:  MOVFF  FF6,72
05BE:  MOVFF  FF7,73
05C2:  MOVF   FF5,W
05C4:  BTFSS  F9E.4
05C6:  BRA    05C4
05C8:  MOVWF  FAD
05CA:  MOVFF  72,FF6
05CE:  MOVFF  73,FF7
05D2:  BRA    05B4
05D4:  RETURN 0
.................... 
.................... #list
.................... 
.................... #device ADC=10
.................... #device *=16
.................... #use delay(clock=16MHz)
*
056C:  CLRF   FEA
056E:  MOVLW  72
0570:  MOVWF  FE9
0572:  MOVF   FEF,W
0574:  BZ    0592
0576:  MOVLW  05
0578:  MOVWF  01
057A:  CLRF   00
057C:  DECFSZ 00,F
057E:  BRA    057C
0580:  DECFSZ 01,F
0582:  BRA    057A
0584:  MOVLW  2E
0586:  MOVWF  00
0588:  DECFSZ 00,F
058A:  BRA    0588
058C:  BRA    058E
058E:  DECFSZ FEF,F
0590:  BRA    0576
0592:  RETURN 0
.................... 
.................... /* hardware I2C port is slave and is connected to DCSWC bus */
.................... #use i2c(stream=STREAM_SLAVE,SLAVE, I2C1, FORCE_HW)
*
0388:  MOVF   FC9,W
038A:  MOVFF  80,FC9
038E:  BSF    FC6.4
0390:  BCF    F9E.3
0392:  BTFSC  FC7.0
0394:  BRA    0392
0396:  CLRF   01
0398:  BTFSS  FC5.6
039A:  INCF   01,F
039C:  RETURN 0
.................... /* slave address set based on dip switch in init() */
.................... /* Linux / i2cdetect will use the CCS address >>1. So 0x34 becomes 0x1a */
.................... 
.................... 
.................... 
.................... #fuses HS
.................... #fuses NOPLLEN
.................... #fuses NOFCMEN
.................... #fuses NOIESO
.................... #fuses PUT
.................... #fuses BROWNOUT
.................... #fuses WDT512
.................... #fuses NOHFOFST
.................... #fuses NOMCLR
.................... #fuses STVREN
.................... #fuses NOLVP
.................... #fuses NOXINST
.................... #fuses NODEBUG
.................... #fuses NOPROTECT
.................... #fuses NOWRT
.................... #fuses NOWRTC 
.................... #fuses NOWRTB
.................... #fuses NOWRTD
.................... #fuses NOEBTR
.................... #fuses NOEBTRB
.................... 
.................... #use standard_io(ALL)
.................... 
.................... #use rs232(UART1,stream=STREAM_FTDI,baud=9600,errors)	
.................... 
.................... /* program config CRC of 0 and a serial_prefix of 'A' ... that will trigger a write default on first boot */
.................... #ROM 0xF00000 = { 0x00, 0x00, 0x40, 0x00 }
.................... 
.................... 
.................... 
.................... #define COUNT_B              PIN_C5
.................... #define COUNT_A              PIN_C4
.................... #define LED_A                PIN_C3
.................... #define PIC_ADDR_MSB         PIN_C6
.................... #define PIC_ADDR_LSB         PIN_C7
.................... #define SER_TO_PC            PIN_B7
.................... 
.................... #define INA_ALERT            PIN_A2
.................... #define I2C_SW_SDA           PIN_C0
.................... #define I2C_SW_SCL           PIN_C1
.................... #define TP2                  PIN_C2
.................... #define I2C_SDA              PIN_B4
.................... #define SER_FROM_PC          PIN_B5
.................... #define I2C_SCL              PIN_B6
.................... 
.................... 
.................... /* software I2C port is maser and is connected to two INA228A */
.................... #use i2c(stream=STREAM_MASTER, MASTER, FAST, FORCE_SW, scl=I2C_SW_SCL, sda=I2C_SW_SDA)
*
05D6:  MOVLW  08
05D8:  MOVWF  01
05DA:  NOP   
05DC:  BCF    F8B.1
05DE:  BCF    F94.1
05E0:  NOP   
05E2:  RLCF   x79,F
05E4:  BCF    F8B.0
05E6:  BTFSC  FD8.0
05E8:  BSF    F94.0
05EA:  BTFSS  FD8.0
05EC:  BCF    F94.0
05EE:  BSF    F94.1
05F0:  BTFSS  F82.1
05F2:  BRA    05F0
05F4:  DECFSZ 01,F
05F6:  BRA    05DA
05F8:  NOP   
05FA:  BCF    F8B.1
05FC:  BCF    F94.1
05FE:  NOP   
0600:  BSF    F94.0
0602:  NOP   
0604:  NOP   
0606:  BSF    F94.1
0608:  BTFSS  F82.1
060A:  BRA    0608
060C:  CLRF   01
060E:  NOP   
0610:  BTFSC  F82.0
0612:  BSF    01.0
0614:  BCF    F8B.1
0616:  BCF    F94.1
0618:  BCF    F8B.0
061A:  BCF    F94.0
061C:  RETURN 0
061E:  MOVLW  08
0620:  MOVWF  x7B
0622:  MOVFF  00,7C
0626:  BSF    F94.0
0628:  NOP   
062A:  BSF    F94.1
062C:  BTFSS  F82.1
062E:  BRA    062C
0630:  BTFSC  F82.0
0632:  BSF    FD8.0
0634:  BTFSS  F82.0
0636:  BCF    FD8.0
0638:  RLCF   01,F
063A:  NOP   
063C:  BCF    F94.1
063E:  BCF    F8B.1
0640:  DECFSZ x7B,F
0642:  BRA    0626
0644:  BSF    F94.0
0646:  NOP   
0648:  BCF    F8B.0
064A:  MOVF   x7C,W
064C:  BTFSS  FD8.2
064E:  BCF    F94.0
0650:  NOP   
0652:  BSF    F94.1
0654:  BTFSS  F82.1
0656:  BRA    0654
0658:  NOP   
065A:  BCF    F8B.1
065C:  BCF    F94.1
065E:  NOP   
0660:  BCF    F8B.0
0662:  BCF    F94.0
0664:  RETURN 0
.................... 
.................... 
.................... 
.................... #define INA228_A_ADDR      0x80
.................... #define INA228_B_ADDR      0x9a
.................... 
.................... 
.................... 
.................... 
.................... typedef struct {
.................... 	int32 vbus_a, vshunt_a;
.................... 	int32 vbus_b, vshunt_b;
.................... 
.................... 	int16 count_a_last_second, count_b_last_second;
.................... 
.................... 	int32 count_a_long;
.................... 	int32 count_b_long;
.................... 	int32 count_seconds_long;
.................... 
.................... 	int16 dietemp_a;
.................... 	int16 dietemp_b;
.................... } struct_current;
.................... 
.................... typedef struct {
.................... 	/* action flags */
.................... 	int1 now_millisecond;
.................... 
.................... 	int1 now_ina;    // query ina registers
.................... 
.................... 	int1 now_dump;   // debugging
.................... 
.................... 	/* timers */
.................... 	int8 led_on_a;
.................... } struct_time_keep;
.................... 
.................... /* global structures */
.................... struct_current current={0};
.................... struct_current next={0};
.................... struct_time_keep timers={0};
.................... 
.................... #include "ina228.c"
.................... #define INA228_REG_CONFIG       0x00  // 16 bits, configuration
.................... #define INA228_REG_ADC_CONFIG   0x01  // 16 bits, ADC configuration
.................... #define INA228_REG_SHUNT_CAL    0x02  // 16 bits, shunt calibration
.................... #define INA228_REG_SHUNT_TEMPCO 0x03  // 16 bits, shunt temperature coefficient
.................... #define INA228_REG_VSHUNT       0x04  // 24 bits, shunt voltage measurement
.................... #define INA228_REG_VBUS         0x05  // 24 bits, bus voltage measurement
.................... #define INA228_REG_DIETEMP      0x06  // 16 bits, temperature measurement
.................... #define INA228_REG_CURRENT      0x07  // 24 bits, current result
.................... #define INA228_REG_POWER        0x08  // 24 bits, power result 
.................... #define INA228_REG_ENERGY       0x09  // 40 bits, energy result
.................... #define INA228_REG_CHARGE       0x0a  // 40 bits, charge result
.................... #define INA228_REG_DIAG_ALRT    0x0b  // 16 bits, diagnostic flags and alert
.................... #define INA228_REG_SOVL         0x0c  // 16 bits, shunt overvoltage threshold
.................... #define INA228_REG_SUVL         0x0d  // 16 bits, shunt undervoltage threshold
.................... #define INA228_REG_BOVL         0x0e  // 16 bits, bus overvoltage threshold
.................... #define INA228_REG_BUVL         0x0f  // 16 bits, bus undervoltage threshold
.................... #define INA228_REG_TEMP_LIMIT   0x10  // 16 bits, temperature over-limit threshold
.................... #define INA228_REG_PWR_LIMIT    0x11  // 16 bits, power over-limit threshold
.................... #define INA228_REG_MFG_ID       0x3e  // 16 bits, manufacturer ID
.................... #define INA228_REG_DEVICE_ID    0x3f  // 16 bits, device ID
.................... 
.................... #define INA228_I2C_WRITE        0x00
.................... #define INA228_I2C_READ         0x01 
.................... 
.................... 
.................... int16 ina228_read16(int8 i2c_address, int8 regaddr) {
.................... 	int16 data;
.................... 
.................... 	i2c_start(STREAM_MASTER);
*
0704:  BSF    F94.0
0706:  NOP   
0708:  BSF    F94.1
070A:  NOP   
070C:  BCF    F8B.0
070E:  BCF    F94.0
0710:  NOP   
0712:  BCF    F8B.1
0714:  BCF    F94.1
.................... 	delay_us(15);
0716:  MOVLW  13
0718:  MOVWF  00
071A:  DECFSZ 00,F
071C:  BRA    071A
071E:  BRA    0720
.................... 	i2c_write(STREAM_MASTER,i2c_address);
0720:  MOVFF  72,79
0724:  RCALL  05D6
.................... 	i2c_write(STREAM_MASTER,regaddr);
0726:  MOVFF  73,79
072A:  RCALL  05D6
.................... 	i2c_start(STREAM_MASTER);
072C:  BSF    F94.0
072E:  NOP   
0730:  BSF    F94.1
0732:  NOP   
0734:  BTFSS  F82.1
0736:  BRA    0734
0738:  BCF    F8B.0
073A:  BCF    F94.0
073C:  NOP   
073E:  BCF    F8B.1
0740:  BCF    F94.1
.................... 	delay_us(15);
0742:  MOVLW  13
0744:  MOVWF  00
0746:  DECFSZ 00,F
0748:  BRA    0746
074A:  BRA    074C
.................... 	i2c_write(STREAM_MASTER,i2c_address | INA228_I2C_READ);  // read cycle
074C:  MOVF   x72,W
074E:  IORLW  01
0750:  MOVWF  x76
0752:  MOVWF  x79
0754:  RCALL  05D6
.................... 	data=make16(i2c_read(STREAM_MASTER,1),i2c_read(STREAM_MASTER,0));                                 
0756:  MOVLW  01
0758:  MOVWF  00
075A:  RCALL  061E
075C:  MOVFF  01,76
0760:  CLRF   00
0762:  RCALL  061E
0764:  MOVFF  76,75
0768:  MOVFF  01,74
.................... 	i2c_stop(STREAM_MASTER);
076C:  BCF    F94.0
076E:  NOP   
0770:  BSF    F94.1
0772:  BTFSS  F82.1
0774:  BRA    0772
0776:  NOP   
0778:  BRA    077A
077A:  NOP   
077C:  BSF    F94.0
077E:  NOP   
.................... 
.................... 	return data;
0780:  MOVFF  74,01
0784:  MOVFF  75,02
0788:  RETURN 0
.................... }
.................... 
.................... int32 ina228_read24(int8 i2c_address, int8 regaddr) {
.................... 	int32 data;
.................... 
.................... 	i2c_start(STREAM_MASTER);
*
0666:  BSF    F94.0
0668:  NOP   
066A:  BSF    F94.1
066C:  NOP   
066E:  BCF    F8B.0
0670:  BCF    F94.0
0672:  NOP   
0674:  BCF    F8B.1
0676:  BCF    F94.1
.................... 	delay_us(15);
0678:  MOVLW  13
067A:  MOVWF  00
067C:  DECFSZ 00,F
067E:  BRA    067C
0680:  BRA    0682
.................... 	i2c_write(STREAM_MASTER,i2c_address);
0682:  MOVFF  72,79
0686:  RCALL  05D6
.................... 	i2c_write(STREAM_MASTER,regaddr);
0688:  MOVFF  73,79
068C:  RCALL  05D6
.................... 	i2c_start(STREAM_MASTER);
068E:  BSF    F94.0
0690:  NOP   
0692:  BSF    F94.1
0694:  NOP   
0696:  BTFSS  F82.1
0698:  BRA    0696
069A:  BCF    F8B.0
069C:  BCF    F94.0
069E:  NOP   
06A0:  BCF    F8B.1
06A2:  BCF    F94.1
.................... 	delay_us(15);
06A4:  MOVLW  13
06A6:  MOVWF  00
06A8:  DECFSZ 00,F
06AA:  BRA    06A8
06AC:  BRA    06AE
.................... 	i2c_write(STREAM_MASTER,i2c_address | INA228_I2C_READ);  // read cycle
06AE:  MOVF   x72,W
06B0:  IORLW  01
06B2:  MOVWF  x78
06B4:  MOVWF  x79
06B6:  RCALL  05D6
.................... 	data=make32(0,i2c_read(STREAM_MASTER,1),i2c_read(STREAM_MASTER,1),i2c_read(STREAM_MASTER,0));
06B8:  MOVLW  01
06BA:  MOVWF  00
06BC:  RCALL  061E
06BE:  MOVFF  01,78
06C2:  MOVLW  01
06C4:  MOVWF  00
06C6:  RCALL  061E
06C8:  MOVFF  01,79
06CC:  CLRF   00
06CE:  RCALL  061E
06D0:  CLRF   x77
06D2:  MOVFF  78,76
06D6:  MOVFF  79,75
06DA:  MOVFF  01,74
.................... 	i2c_stop(STREAM_MASTER);
06DE:  BCF    F94.0
06E0:  NOP   
06E2:  BSF    F94.1
06E4:  BTFSS  F82.1
06E6:  BRA    06E4
06E8:  NOP   
06EA:  BRA    06EC
06EC:  NOP   
06EE:  BSF    F94.0
06F0:  NOP   
.................... 
.................... 	return data;
06F2:  MOVFF  74,00
06F6:  MOVFF  75,01
06FA:  MOVFF  76,02
06FE:  MOVFF  77,03
0702:  RETURN 0
.................... }
.................... 
.................... void ina228_write16(int8 i2c_address, int8 regaddr, int16 value) {
.................... 	i2c_start(STREAM_MASTER);
.................... 	delay_us(15);                                                 
.................... 	i2c_write(STREAM_MASTER,i2c_address); // write cycle                       
.................... 	i2c_write(STREAM_MASTER,regaddr);  // write cycle         
.................... 	i2c_write(STREAM_MASTER,make8(value,1));
.................... 	i2c_write(STREAM_MASTER,make8(value,0));
.................... 	i2c_stop(STREAM_MASTER);
.................... }
.................... 
.................... void ina228_init(int8 i2c_address) {
.................... 	ina228_write16(i2c_address,INA228_REG_CONFIG,0b1000000000000000);
.................... }
.................... 
.................... #include "i2c_handler_dcswc_module_voltage_current_counter.c"
.................... #include "registers_dcswc_module_voltage_current_counter.h"
.................... /* 32 bit INA228 bus and shunt voltages */
.................... #define I2C_REG_VBUS_A_MSW                    0
.................... #define I2C_REG_VBUS_A_LSW                    1
.................... #define I2C_REG_VSHUNT_A_MSW                  2
.................... #define I2C_REG_VSHUNT_A_LSW                  3
.................... 
.................... #define I2C_REG_VBUS_B_MSW                    4
.................... #define I2C_REG_VBUS_B_LSW                    5
.................... #define I2C_REG_VSHUNT_B_MSW                  6
.................... #define I2C_REG_VSHUNT_B_LSW                  7
.................... 
.................... /* 16 bit count of last (not current) second */
.................... #define I2C_REG_COUNT_A_LAST_SECOND           8
.................... #define I2C_REG_COUNT_B_LAST_SECOND           9
.................... 
.................... /* 32 bit count since reset */
.................... #define I2C_REG_COUNT_A_LONG_MSW              10
.................... #define I2C_REG_COUNT_A_LONG_LSW              11
.................... #define I2C_REG_COUNT_B_LONG_MSW              12
.................... #define I2C_REG_COUNT_B_LONG_LSW              13
.................... 
.................... /* 32 bit seconds since count reset */
.................... #define I2C_REG_COUNT_LONG_SECONDS_MSW        14
.................... #define I2C_REG_COUNT_LONG_SECONDS_LSW        15
.................... 
.................... /* 16 bit INA228 die temperatures */
.................... #define I2C_REG_DIETEMP_A                     16
.................... #define I2C_REG_DIETEMP_B                     17
.................... 
.................... 
.................... 
.................... /* test scratchpad registers for validating I2C communications */
.................... //int16 rtest[8] = { 0x0001, 0x0203, 0x0405, 0x0607, 0x0809, 0x0a0b, 0x0c0d, 0x0e0f };
.................... 
.................... 
.................... void write_i2c(int8 address, int16 value) {
.................... 	
.................... 	switch ( address ) {
*
01B2:  MOVF   x82,W
01B4:  XORLW  0E
01B6:  BZ    01BE
01B8:  XORLW  01
01BA:  BZ    01BE
01BC:  BRA    01D6
.................... #if 0
.................... 		case 0: rtest[0]=value; break;
.................... 		case 1: rtest[1]=value; break;
.................... 		case 2: rtest[2]=value; break;
.................... 		case 3: rtest[3]=value; break;
.................... 		case 4: rtest[4]=value; break;
.................... 		case 5: rtest[5]=value; break;
.................... 		case 6: rtest[6]=value; break;
.................... 		case 7: rtest[7]=value; break;
.................... #endif
.................... 
.................... 		/* write anything to either of these addresses and we reset the long counter */
.................... 		case I2C_REG_COUNT_LONG_SECONDS_MSW:
.................... 		case I2C_REG_COUNT_LONG_SECONDS_LSW:
.................... 			current.count_a_long=0;
01BE:  CLRF   31
01C0:  CLRF   30
01C2:  CLRF   2F
01C4:  CLRF   2E
.................... 			current.count_b_long=0;
01C6:  CLRF   35
01C8:  CLRF   34
01CA:  CLRF   33
01CC:  CLRF   32
.................... 			current.count_seconds_long=0;
01CE:  CLRF   39
01D0:  CLRF   38
01D2:  CLRF   37
01D4:  CLRF   36
.................... 			break;
.................... 		default:
.................... 			/* do nothing */
.................... 	}
01D6:  GOTO   041E (RETURN)
.................... 
.................... }
.................... 
.................... 
.................... int16 map_i2c(int8 addr) {
.................... 	static int16 lsw=0xffff;
.................... 
.................... 	timers.led_on_a=100;
01DA:  MOVLW  64
01DC:  MOVWF  x63
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 	switch ( addr ) {
01DE:  MOVF   x80,W
01E0:  BZ    023C
01E2:  XORLW  01
01E4:  BZ    025A
01E6:  XORLW  03
01E8:  BZ    0264
01EA:  XORLW  01
01EC:  BZ    0284
01EE:  XORLW  07
01F0:  BZ    028E
01F2:  XORLW  01
01F4:  BZ    02AC
01F6:  XORLW  03
01F8:  BZ    02B6
01FA:  XORLW  01
01FC:  BZ    02D4
01FE:  XORLW  0F
0200:  BTFSC  FD8.2
0202:  BRA    02DE
0204:  XORLW  01
0206:  BTFSC  FD8.2
0208:  BRA    02E8
020A:  XORLW  03
020C:  BTFSC  FD8.2
020E:  BRA    02F2
0210:  XORLW  01
0212:  BTFSC  FD8.2
0214:  BRA    0310
0216:  XORLW  07
0218:  BTFSC  FD8.2
021A:  BRA    031A
021C:  XORLW  01
021E:  BTFSC  FD8.2
0220:  BRA    0338
0222:  XORLW  03
0224:  BTFSC  FD8.2
0226:  BRA    0342
0228:  XORLW  01
022A:  BTFSC  FD8.2
022C:  BRA    0360
022E:  XORLW  1F
0230:  BTFSC  FD8.2
0232:  BRA    036A
0234:  XORLW  01
0236:  BTFSC  FD8.2
0238:  BRA    0374
023A:  BRA    037E
.................... #if 0
.................... 		case 0: return rtest[0];
.................... 		case 1: return rtest[1];
.................... 		case 2: return rtest[2];
.................... 		case 3: return rtest[3];
.................... 		case 4: return rtest[4];
.................... 		case 5: return rtest[5];
.................... 		case 6: return rtest[6];
.................... 		case 7: return rtest[7];
.................... #endif
.................... 
.................... 		/* 32 bit variables have the most significant word read first and that sets the
.................... 		   least sinificant word which can be read next. _LSW registers are only valid if
.................... 		   they are preceeded by a read on the matching _MSW register
.................... 		 */
.................... 		case I2C_REG_VBUS_A_MSW:
.................... 			lsw = make16(make8(current.vbus_a,1),make8(current.vbus_a,0));
023C:  MOVFF  1B,65
0240:  MOVFF  1A,64
.................... 			return (int16) make16(make8(current.vbus_a,3),make8(current.vbus_a,2));
0244:  MOVFF  1D,81
0248:  MOVFF  1C,82
024C:  MOVFF  1D,03
0250:  MOVFF  1C,01
0254:  MOVFF  1D,02
0258:  BRA    0384
.................... 		case I2C_REG_VBUS_A_LSW:
.................... 			return (int16) lsw;
025A:  MOVFF  64,01
025E:  MOVFF  65,02
0262:  BRA    0384
.................... 		case I2C_REG_VSHUNT_A_MSW:
.................... 			timers.now_dump=1;
0264:  BSF    x62.2
.................... 			lsw = make16(make8(current.vshunt_a,1),make8(current.vshunt_a,0));
0266:  MOVFF  1F,65
026A:  MOVFF  1E,64
.................... 			return (int16) make16(make8(current.vshunt_a,3),make8(current.vshunt_a,2));
026E:  MOVFF  21,81
0272:  MOVFF  20,82
0276:  MOVFF  21,03
027A:  MOVFF  20,01
027E:  MOVFF  21,02
0282:  BRA    0384
.................... 		case I2C_REG_VSHUNT_A_LSW:
.................... 			return (int16) lsw;    
0284:  MOVFF  64,01
0288:  MOVFF  65,02
028C:  BRA    0384
.................... 
.................... 		case I2C_REG_VBUS_B_MSW:
.................... 			lsw = make16(make8(current.vbus_a,1),make8(current.vbus_a,0));
028E:  MOVFF  1B,65
0292:  MOVFF  1A,64
.................... 			return (int16) make16(make8(current.vbus_b,3),make8(current.vbus_b,2));
0296:  MOVFF  25,81
029A:  MOVFF  24,82
029E:  MOVFF  25,03
02A2:  MOVFF  24,01
02A6:  MOVFF  25,02
02AA:  BRA    0384
.................... 		case I2C_REG_VBUS_B_LSW:
.................... 			return (int16) lsw;
02AC:  MOVFF  64,01
02B0:  MOVFF  65,02
02B4:  BRA    0384
.................... 		case I2C_REG_VSHUNT_B_MSW:
.................... 			lsw = make16(make8(current.vshunt_b,1),make8(current.vshunt_b,0));
02B6:  MOVFF  27,65
02BA:  MOVFF  26,64
.................... 			return (int16) make16(make8(current.vshunt_b,3),make8(current.vshunt_b,2));
02BE:  MOVFF  29,81
02C2:  MOVFF  28,82
02C6:  MOVFF  29,03
02CA:  MOVFF  28,01
02CE:  MOVFF  29,02
02D2:  BRA    0384
.................... 		case I2C_REG_VSHUNT_B_LSW:
.................... 			return (int16) lsw;    
02D4:  MOVFF  64,01
02D8:  MOVFF  65,02
02DC:  BRA    0384
.................... 
.................... 
.................... 		case I2C_REG_COUNT_A_LAST_SECOND:
.................... 			return (int16) current.count_a_last_second;
02DE:  MOVFF  2A,01
02E2:  MOVFF  2B,02
02E6:  BRA    0384
.................... 		case I2C_REG_COUNT_B_LAST_SECOND:
.................... 			return (int16) current.count_b_last_second;
02E8:  MOVFF  2C,01
02EC:  MOVFF  2D,02
02F0:  BRA    0384
.................... 
.................... 		case I2C_REG_COUNT_A_LONG_MSW:
.................... 			lsw = make16(make8(current.count_a_long,1),make8(current.count_a_long,0));
02F2:  MOVFF  2F,65
02F6:  MOVFF  2E,64
.................... 			return (int16) make16(make8(current.count_a_long,3),make8(current.count_a_long,2));
02FA:  MOVFF  31,81
02FE:  MOVFF  30,82
0302:  MOVFF  31,03
0306:  MOVFF  30,01
030A:  MOVFF  31,02
030E:  BRA    0384
.................... 		case I2C_REG_COUNT_A_LONG_LSW:
.................... 			return (int16) lsw;
0310:  MOVFF  64,01
0314:  MOVFF  65,02
0318:  BRA    0384
.................... 		case I2C_REG_COUNT_B_LONG_MSW:
.................... 			lsw = make16(make8(current.count_b_long,1),make8(current.count_b_long,0));
031A:  MOVFF  33,65
031E:  MOVFF  32,64
.................... 			return (int16) make16(make8(current.count_b_long,3),make8(current.count_b_long,2));
0322:  MOVFF  35,81
0326:  MOVFF  34,82
032A:  MOVFF  35,03
032E:  MOVFF  34,01
0332:  MOVFF  35,02
0336:  BRA    0384
.................... 		case I2C_REG_COUNT_B_LONG_LSW:
.................... 			return (int16) lsw;
0338:  MOVFF  64,01
033C:  MOVFF  65,02
0340:  BRA    0384
.................... 		case I2C_REG_COUNT_LONG_SECONDS_MSW:
.................... 			lsw = make16(make8(current.count_seconds_long,1),make8(current.count_seconds_long,0));
0342:  MOVFF  37,65
0346:  MOVFF  36,64
.................... 			return (int16) make16(make8(current.count_seconds_long,3),make8(current.count_seconds_long,2));
034A:  MOVFF  39,81
034E:  MOVFF  38,82
0352:  MOVFF  39,03
0356:  MOVFF  38,01
035A:  MOVFF  39,02
035E:  BRA    0384
.................... 		case I2C_REG_COUNT_LONG_SECONDS_LSW:
.................... 			return (int16) lsw;
0360:  MOVFF  64,01
0364:  MOVFF  65,02
0368:  BRA    0384
.................... 
.................... 		case I2C_REG_DIETEMP_A:
.................... 			return (int16) current.dietemp_a;
036A:  MOVFF  3A,01
036E:  MOVFF  3B,02
0372:  BRA    0384
.................... 		case I2C_REG_DIETEMP_B:
.................... 			return (int16) current.dietemp_b;
0374:  MOVFF  3C,01
0378:  MOVFF  3D,02
037C:  BRA    0384
.................... 
.................... 		/* we should have range checked, and never gotten here ... or read unimplemented (future) register */
.................... 		default: return (int16) addr;
037E:  MOVFF  80,01
0382:  CLRF   02
.................... 	}
0384:  GOTO   0432 (RETURN)
.................... 
.................... }
.................... 
.................... 
.................... 
.................... #include "interrupt_dcswc_module_voltage_current_counter.c"
.................... #int_timer2
.................... void isr_timer2() {
.................... 	static int16 ticks=0;
.................... 	static short count_a_last=0;
.................... 	static short count_b_last=0;
.................... 	short count_a_now;
.................... 	short count_b_now;
.................... 
.................... 
.................... 	/* external input counting */
.................... 	count_a_now=input(COUNT_A);
*
00BA:  BSF    F94.4
00BC:  BCF    x7D.0
00BE:  BTFSC  F82.4
00C0:  BSF    x7D.0
.................... 	if ( 0 == count_a_now && 1 == count_a_last ) {
00C2:  BTFSC  x7D.0
00C4:  BRA    00D0
00C6:  BTFSS  x68.0
00C8:  BRA    00D0
.................... 		next.count_a_last_second++;
00CA:  INCF   4E,F
00CC:  BTFSC  FD8.2
00CE:  INCF   4F,F
.................... 	}
.................... 	count_a_last=count_a_now;
00D0:  BCF    x68.0
00D2:  BTFSC  x7D.0
00D4:  BSF    x68.0
.................... 
.................... 	count_b_now=input(COUNT_B);
00D6:  BSF    F94.5
00D8:  BCF    x7D.1
00DA:  BTFSC  F82.5
00DC:  BSF    x7D.1
.................... 	if ( 0 == count_b_now && 1 == count_b_last ) {
00DE:  BTFSC  x7D.1
00E0:  BRA    00EC
00E2:  BTFSS  x68.1
00E4:  BRA    00EC
.................... 		next.count_b_last_second++;
00E6:  INCF   50,F
00E8:  BTFSC  FD8.2
00EA:  INCF   51,F
.................... 	}
.................... 	count_b_last=count_b_now;
00EC:  BCF    x68.1
00EE:  BTFSC  x7D.1
00F0:  BSF    x68.1
.................... 
.................... 
.................... 	/* timing */
.................... 
.................... 	timers.now_millisecond=1;
00F2:  BSF    x62.0
.................... 
.................... 	ticks++;
00F4:  INCF   x66,F
00F6:  BTFSC  FD8.2
00F8:  INCF   x67,F
.................... 	if ( 500 == ticks ) {
00FA:  MOVF   x66,W
00FC:  SUBLW  F4
00FE:  BNZ   0108
0100:  DECFSZ x67,W
0102:  BRA    0108
.................... 		timers.now_ina=1;
0104:  BSF    x62.1
.................... 	} else if ( 1000 == ticks ) {
0106:  BRA    01AC
0108:  MOVF   x66,W
010A:  SUBLW  E8
010C:  BNZ   01AC
010E:  MOVF   x67,W
0110:  SUBLW  03
0112:  BNZ   01AC
.................... 		current.vbus_a=next.vbus_a;
0114:  MOVFF  41,1D
0118:  MOVFF  40,1C
011C:  MOVFF  3F,1B
0120:  MOVFF  3E,1A
.................... 		current.vshunt_a=next.vshunt_a;
0124:  MOVFF  45,21
0128:  MOVFF  44,20
012C:  MOVFF  43,1F
0130:  MOVFF  42,1E
.................... 		current.dietemp_a=next.dietemp_a;	
0134:  MOVFF  5F,3B
0138:  MOVFF  5E,3A
.................... 
.................... 		current.vbus_b=next.vbus_b;
013C:  MOVFF  49,25
0140:  MOVFF  48,24
0144:  MOVFF  47,23
0148:  MOVFF  46,22
.................... 		current.vshunt_b=next.vshunt_b;
014C:  MOVFF  4D,29
0150:  MOVFF  4C,28
0154:  MOVFF  4B,27
0158:  MOVFF  4A,26
.................... 		current.dietemp_b=next.dietemp_b;
015C:  MOVFF  61,3D
0160:  MOVFF  60,3C
.................... 
.................... 		current.count_a_last_second=next.count_a_last_second;
0164:  MOVFF  4F,2B
0168:  MOVFF  4E,2A
.................... 
.................... 		current.count_b_last_second=next.count_b_last_second;	
016C:  MOVFF  51,2D
0170:  MOVFF  50,2C
.................... 
.................... 		current.count_a_long += current.count_a_last_second;
0174:  MOVF   2A,W
0176:  ADDWF  2E,F
0178:  MOVF   2B,W
017A:  ADDWFC 2F,F
017C:  MOVLW  00
017E:  ADDWFC 30,F
0180:  ADDWFC 31,F
.................... 		current.count_b_long += current.count_b_last_second;
0182:  MOVF   2C,W
0184:  ADDWF  32,F
0186:  MOVF   2D,W
0188:  ADDWFC 33,F
018A:  MOVLW  00
018C:  ADDWFC 34,F
018E:  ADDWFC 35,F
.................... 	
.................... 		current.count_seconds_long++;
0190:  MOVLW  01
0192:  ADDWF  36,F
0194:  BTFSC  FD8.0
0196:  INCF   37,F
0198:  BTFSC  FD8.2
019A:  INCF   38,F
019C:  BTFSC  FD8.2
019E:  INCF   39,F
.................... 
.................... 		/* reset our counters */
.................... 		next.count_a_last_second=0;
01A0:  CLRF   4F
01A2:  CLRF   4E
.................... 		next.count_b_last_second=0;
01A4:  CLRF   51
01A6:  CLRF   50
.................... 
.................... 		ticks=0;
01A8:  CLRF   x67
01AA:  CLRF   x66
.................... 	}
.................... }
.................... 
.................... 
.................... /* I2C slave interrupt */
01AC:  BCF    F9E.1
01AE:  GOTO   006C
.................... #byte SSPSTAT=GETENV("SFR:SSPSTAT")
.................... #INT_SSP
.................... void ssp_interrupt () {
.................... 	static int8 sstate;
.................... 	int8 state;
.................... 	int8 incoming;
.................... 	static int16 lastValue;
.................... 	static int8 lastMSB;
.................... 
.................... 	static int8 address; 
.................... 
.................... 	/* 
.................... 	our implementation of i2c_isr_state() that won't overflow and switch states
.................... 	but it will quit counting at 127 bytes. 
.................... 	If more bytes are needed, external counting variables can be used or the size of state can be made larger
.................... 	*/
.................... 
.................... 
.................... 	if ( ! bit_test(SSPSTAT,5) ) {
*
039E:  BTFSC  FC7.5
03A0:  BRA    03AA
.................... 		/* address */
.................... 		sstate=0;
03A2:  CLRF   x69
.................... 
.................... 		if ( bit_test(SSPSTAT,2) ) {
03A4:  BTFSS  FC7.2
03A6:  BRA    03AA
.................... 			/* set high bit if read */
.................... 			bit_set(sstate,7);
03A8:  BSF    x69.7
.................... 		}
.................... 	} else {
.................... 		/* data */
.................... 	}
.................... 
.................... 	/* state variable used below is not incremented */
.................... 	state=sstate;
03AA:  MOVFF  69,7D
.................... 
.................... 	/* increment the state counter for next pass through unless it will overflow us into another state */
.................... 	if ( sstate != 0x7f && sstate != 0xff) {
03AE:  MOVF   x69,W
03B0:  SUBLW  7F
03B2:  BZ    03BC
03B4:  INCFSZ x69,W
03B6:  BRA    03BA
03B8:  BRA    03BC
.................... 		sstate++;
03BA:  INCF   x69,F
.................... 	}
.................... 
.................... 	
.................... 	/* i2c_isr_state() return an 8 bit int
.................... 		0 - Address match received with R/W bit clear, perform i2c_read( ) to read the I2C address.
.................... 		1-0x7F - Master has written data; i2c_read() will immediately return the data
.................... 		0x80 - Address match received with R/W bit set; perform i2c_read( ) to read the I2C address,
.................... 		and use i2c_write( ) to pre-load the transmit buffer for the next transaction (next I2C read
.................... 		performed by master will read this byte).
.................... 		0x81-0xFF - Transmission completed and acknowledged; respond with i2c_write() to pre-load
.................... 		the transmit buffer for the next transition (the next I2C read performed by master will read this
.................... 		byte).
.................... 		Function:
.................... 		Returns the state of I2C communications in I2C slave mode after an SSP interrupt. The return
.................... 		value increments with each byte received or sent.
.................... 		If 0x00 or 0x80 is returned, an i2C_read( ) needs to be performed to read the I2C address that
.................... 		was sent (it will match the address configured by #USE I2C so this value can be ignored)
.................... 	*/
.................... 
.................... 	if ( state <= 0x80 ) {                      
03BC:  MOVF   x7D,W
03BE:  SUBLW  80
03C0:  BNC   041E
.................... 		/* I2C master is sending us data */
.................... 		if ( 0x80 == state ) {
03C2:  MOVF   x7D,W
03C4:  SUBLW  80
03C6:  BNZ   03CE
.................... 			/* i2c_read(2) casues the function to read the SSPBUF without releasing the clock */
.................... 			incoming = i2c_read(STREAM_SLAVE,2);
03C8:  MOVFF  FC9,7E
.................... 		} else {
03CC:  BRA    03DA
.................... 			incoming = i2c_read(STREAM_SLAVE);
03CE:  BCF    FC6.6
03D0:  BTFSS  FC7.0
03D2:  BRA    03D0
03D4:  MOVF   FC9,W
03D6:  BSF    FC6.4
03D8:  MOVWF  x7E
.................... 		}
.................... 
.................... 		if ( 1 == state ) {             
03DA:  DECFSZ x7D,W
03DC:  BRA    03E6
.................... 			address = incoming<<1;
03DE:  BCF    FD8.0
03E0:  RLCF   x7E,W
03E2:  MOVWF  x6D
.................... 		} else if ( state >= 2 && 0x80 != state ) {
03E4:  BRA    041E
03E6:  MOVF   x7D,W
03E8:  SUBLW  01
03EA:  BC    041E
03EC:  MOVF   x7D,W
03EE:  SUBLW  80
03F0:  BZ    041E
.................... 			/* received byte is data */
.................... 		
.................... 			/* save MSB and we'll process it on next */
.................... 			if ( 2 == state ) {
03F2:  MOVF   x7D,W
03F4:  SUBLW  02
03F6:  BNZ   03FE
.................... 				lastMSB=incoming;
03F8:  MOVFF  7E,6C
.................... 			} else if ( 3 == state ) {
03FC:  BRA    041E
03FE:  MOVF   x7D,W
0400:  SUBLW  03
0402:  BNZ   041E
.................... 				/* 16 bit value made of previous byte and this byte */
.................... 				write_i2c(address>>1,make16(lastMSB,incoming));
0404:  BCF    FD8.0
0406:  RRCF   x6D,W
0408:  MOVWF  x7F
040A:  MOVFF  6C,81
040E:  MOVFF  7E,80
0412:  MOVWF  x82
0414:  MOVFF  6C,84
0418:  MOVFF  7E,83
041C:  BRA    01B2
.................... 
.................... 				/* this write only works for a single register per I2C transaction */
.................... 				/* this is not a BUG, but it would need to be implemented if this functionality is needed */
.................... 			}
.................... 		}
.................... 	}
.................... 
.................... 
.................... 	if ( state >= 0x80 ) {
041E:  MOVF   x7D,W
0420:  SUBLW  7F
0422:  BC    0452
.................... 		/* I2C master is requesting data from us */
.................... 
.................... 		if ( ! bit_test(address,0) ) {
0424:  BTFSC  x6D.0
0426:  BRA    0446
.................... 			/* read 16 bit register (register address half of I2C address) on even address */
.................... 			lastValue=map_i2c(address>>1);
0428:  BCF    FD8.0
042A:  RRCF   x6D,W
042C:  MOVWF  x7F
042E:  MOVWF  x80
0430:  BRA    01DA
0432:  MOVFF  02,6B
0436:  MOVFF  01,6A
.................... 
.................... 			/* send the MSB */
.................... 			i2c_write(STREAM_SLAVE,make8(lastValue,1));
043A:  MOVFF  6B,7F
043E:  MOVFF  6B,80
0442:  RCALL  0388
.................... 		} else {
0444:  BRA    0450
.................... 			/* send LSB of 16 bit register on odd address */
.................... 			i2c_write(STREAM_SLAVE,make8(lastValue,0));
0446:  MOVFF  6A,7F
044A:  MOVFF  6A,80
044E:  RCALL  0388
.................... 		}
.................... 		address++;
0450:  INCF   x6D,F
.................... 	}
0452:  BCF    F9E.3
0454:  GOTO   006C
.................... }
.................... 
.................... 
.................... int8 read_dip_switch(void) {
.................... 	/* nomenclature is backwards on netlist. We actually want LSB on top */
.................... 	return ( ! input(PIC_ADDR_LSB)<<1 ) | ( ! input(PIC_ADDR_MSB) );
*
0508:  BSF    F94.7
050A:  MOVLW  00
050C:  BTFSS  F82.7
050E:  MOVLW  01
0510:  MOVWF  00
0512:  BCF    FD8.0
0514:  RLCF   00,W
0516:  MOVWF  x72
0518:  BSF    F94.6
051A:  MOVLW  00
051C:  BTFSS  F82.6
051E:  MOVLW  01
0520:  IORWF  x72,W
0522:  MOVWF  01
0524:  GOTO   0560 (RETURN)
.................... }
.................... 
.................... void init(void) {
.................... 	setup_vref(VREF_OFF);
0528:  CLRF   FBA
.................... 	setup_dac(DAC_OFF);
052A:  CLRF   FBB
.................... 	setup_adc(ADC_OFF);
052C:  BCF    FC2.0
.................... 	setup_adc_ports(NO_ANALOGS);
052E:  MOVLW  00
0530:  MOVWF  F7E
0532:  BCF    FC1.0
0534:  BCF    FC1.1
0536:  BCF    FC1.2
0538:  BCF    FC1.3
053A:  MOVWF  F7F
.................... 
.................... 	setup_wdt(WDT_512MS);
053C:  BSF    FD1.0
.................... 
.................... 
.................... 	set_tris_a    (0b00111111);
053E:  MOVLW  3F
0540:  MOVWF  F92
.................... 	port_a_pullups(0b00110000);
0542:  MOVLW  30
0544:  MOVWF  F77
0546:  BCF    FF1.7
.................... //                   76543210
.................... 
.................... 	set_tris_b    (0b01110000);
0548:  MOVLW  70
054A:  MOVWF  F93
.................... 	port_b_pullups(0b00000000);
054C:  CLRF   F78
.................... //                   76543210
.................... 
.................... 	set_tris_c    (0b11110011);
054E:  MOVLW  F3
0550:  MOVWF  F94
.................... //                   76543210
.................... 
.................... 
.................... 	/* data structure initialization */
.................... 	/* all initialized to 0 on declaration. Just do this if need non-zero */
.................... 
.................... 
.................... 	/* one periodic interrupt @ 1mS. Generated from system 16 MHz clock */
.................... 	/* prescale=16, match=249, postscale=1. Match is 249 because when match occurs, one cycle is lost */
.................... 	setup_timer_2(T2_DIV_BY_16,249,1);
0552:  MOVLW  00
0554:  IORLW  06
0556:  MOVWF  FCA
0558:  MOVLW  F9
055A:  MOVWF  FCB
.................... 
.................... 	enable_interrupts(INT_TIMER2);
055C:  BSF    F9D.1
.................... 
.................... 	/* set I2C slave address, which is always an even number */
.................... 	i2c_slaveaddr(0x36 + (read_dip_switch()<<1) );
055E:  BRA    0508
0560:  BCF    FD8.0
0562:  RLCF   01,W
0564:  ADDLW  36
0566:  MOVWF  FC8
0568:  GOTO   08DC (RETURN)
.................... 
.................... }
.................... 
.................... 
.................... void action_now_ina(void) {
.................... 	timers.now_ina=0;
*
078A:  BCF    x62.1
.................... 
.................... 	/* sample INA228 at middle of 1 second window */
.................... 	next.vbus_a=ina228_read24(INA228_A_ADDR,INA228_REG_VBUS);
078C:  MOVLW  80
078E:  MOVWF  x72
0790:  MOVLW  05
0792:  MOVWF  x73
0794:  RCALL  0666
0796:  MOVFF  03,41
079A:  MOVFF  02,40
079E:  MOVFF  01,3F
07A2:  MOVFF  00,3E
.................... 	next.vshunt_a=ina228_read24(INA228_A_ADDR,INA228_REG_VSHUNT);
07A6:  MOVLW  80
07A8:  MOVWF  x72
07AA:  MOVLW  04
07AC:  MOVWF  x73
07AE:  RCALL  0666
07B0:  MOVFF  03,45
07B4:  MOVFF  02,44
07B8:  MOVFF  01,43
07BC:  MOVFF  00,42
.................... 
.................... 	next.vbus_b=ina228_read24(INA228_B_ADDR,INA228_REG_VBUS);
07C0:  MOVLW  9A
07C2:  MOVWF  x72
07C4:  MOVLW  05
07C6:  MOVWF  x73
07C8:  RCALL  0666
07CA:  MOVFF  03,49
07CE:  MOVFF  02,48
07D2:  MOVFF  01,47
07D6:  MOVFF  00,46
.................... 	next.vshunt_b=ina228_read24(INA228_B_ADDR,INA228_REG_VSHUNT);
07DA:  MOVLW  9A
07DC:  MOVWF  x72
07DE:  MOVLW  04
07E0:  MOVWF  x73
07E2:  RCALL  0666
07E4:  MOVFF  03,4D
07E8:  MOVFF  02,4C
07EC:  MOVFF  01,4B
07F0:  MOVFF  00,4A
.................... 
.................... 	next.dietemp_a=ina228_read16(INA228_A_ADDR,INA228_REG_DIETEMP);
07F4:  MOVLW  80
07F6:  MOVWF  x72
07F8:  MOVLW  06
07FA:  MOVWF  x73
07FC:  RCALL  0704
07FE:  MOVFF  02,5F
0802:  MOVFF  01,5E
.................... 	next.dietemp_b=ina228_read16(INA228_B_ADDR,INA228_REG_DIETEMP);
0806:  MOVLW  9A
0808:  MOVWF  x72
080A:  MOVLW  06
080C:  MOVWF  x73
080E:  RCALL  0704
0810:  MOVFF  02,61
0814:  MOVFF  01,60
0818:  GOTO   09C4 (RETURN)
.................... }
.................... 
.................... 
.................... void periodic_millisecond(void) {
.................... 	timers.now_millisecond=0;
081C:  BCF    x62.0
.................... 
.................... 	/* LED control */
.................... 	if ( 0==timers.led_on_a ) {
081E:  MOVF   x63,F
0820:  BNZ   0828
.................... 		output_low(LED_A);
0822:  BCF    F94.3
0824:  BCF    F8B.3
.................... 	} else {
0826:  BRA    082E
.................... 		output_high(LED_A);
0828:  BCF    F94.3
082A:  BSF    F8B.3
.................... 		timers.led_on_a--;
082C:  DECF   x63,F
.................... 	}
082E:  GOTO   09CA (RETURN)
.................... 
.................... 
.................... }
.................... 
.................... 
.................... void main(void) {
0832:  CLRF   FF8
0834:  BCF    FD0.7
0836:  BSF    07.7
0838:  BSF    F93.6
083A:  BSF    F93.4
083C:  CLRF   FC8
083E:  MOVLW  36
0840:  MOVWF  FC6
0842:  BSF    FC5.0
0844:  BSF    FC5.7
0846:  CLRF   19
0848:  BSF    FB8.3
084A:  MOVLW  A0
084C:  MOVWF  FAF
084E:  MOVLW  01
0850:  MOVWF  FB0
0852:  MOVLW  A6
0854:  MOVWF  FAC
0856:  MOVLW  90
0858:  MOVWF  FAB
085A:  CLRF   x6F
085C:  CLRF   x6E
085E:  MOVLW  00
0860:  MOVWF  F7E
0862:  BCF    FC1.0
0864:  BCF    FC1.1
0866:  BCF    FC1.2
0868:  BCF    FC1.3
086A:  MOVWF  F7F
086C:  CLRF   F6C
086E:  CLRF   F6B
0870:  CLRF   F6D
0872:  BCF    x68.0
0874:  BCF    x68.1
0876:  BRA    0888
0878:  DATA 4A,40
087A:  DATA 1A,00
087C:  DATA 04,80
087E:  DATA FF,FF
0880:  DATA 00,00
0882:  DATA 05,40
0884:  DATA 69,00
0886:  DATA 00,00
0888:  MOVLW  00
088A:  MOVWF  FF8
088C:  MOVLW  08
088E:  MOVWF  FF7
0890:  MOVLW  78
0892:  MOVWF  FF6
0894:  TBLRD*+
0896:  MOVF   FF5,W
0898:  MOVWF  00
089A:  XORLW  00
089C:  BZ    08C4
089E:  TBLRD*+
08A0:  MOVF   FF5,W
08A2:  MOVWF  01
08A4:  BTFSC  FE8.7
08A6:  BRA    08B2
08A8:  ANDLW  3F
08AA:  MOVWF  FEA
08AC:  TBLRD*+
08AE:  MOVFF  FF5,FE9
08B2:  BTFSC  01.6
08B4:  TBLRD*+
08B6:  BTFSS  01.6
08B8:  TBLRD*+
08BA:  MOVFF  FF5,FEE
08BE:  DCFSNZ 00,F
08C0:  BRA    0894
08C2:  BRA    08B6
08C4:  CLRF   FF8
.................... 	int8 restart_cause;
.................... 	int8 i;
.................... 
.................... 	restart_cause=restart_cause();
08C6:  MOVF   FD0,W
08C8:  ANDLW  0F
08CA:  BTFSS  FD0.4
08CC:  MOVLW  00
08CE:  BSF    FD0.0
08D0:  BSF    FD0.1
08D2:  BSF    FD0.4
08D4:  BSF    FD8.3
08D6:  BSF    FD8.4
08D8:  MOVWF  x70
.................... 
.................... 	init();
08DA:  BRA    0528
.................... 
.................... 
.................... 
.................... 	/* flash on startup */
.................... 	for ( i=0 ; i<5 ; i++ ) {
08DC:  CLRF   x71
08DE:  MOVF   x71,W
08E0:  SUBLW  04
08E2:  BNC   08FE
.................... 		restart_wdt();
08E4:  CLRWDT
.................... 		output_high(LED_A);
08E6:  BCF    F94.3
08E8:  BSF    F8B.3
.................... 		delay_ms(200);
08EA:  MOVLW  C8
08EC:  MOVWF  x72
08EE:  RCALL  056C
.................... 		output_low(LED_A);
08F0:  BCF    F94.3
08F2:  BCF    F8B.3
.................... 		delay_ms(200);
08F4:  MOVLW  C8
08F6:  MOVWF  x72
08F8:  RCALL  056C
08FA:  INCF   x71,F
08FC:  BRA    08DE
.................... 	}
.................... 
.................... 	fprintf(STREAM_FTDI,"# dcswc_module_voltage_current_counter %s\r\n# ",__DATE__);
08FE:  MOVLW  58
0900:  MOVWF  FF6
0902:  MOVLW  04
0904:  MOVWF  FF7
0906:  MOVLW  27
0908:  MOVWF  x72
090A:  RCALL  0594
090C:  MOVLW  86
090E:  MOVWF  FF6
0910:  MOVLW  04
0912:  MOVWF  FF7
0914:  RCALL  05B4
0916:  MOVLW  81
0918:  MOVWF  FF6
091A:  MOVLW  04
091C:  MOVWF  FF7
091E:  MOVLW  04
0920:  MOVWF  x72
0922:  RCALL  0594
.................... 	switch ( restart_cause ) {
0924:  MOVF   x70,W
0926:  XORLW  07
0928:  BZ    0944
092A:  XORLW  0C
092C:  BZ    0950
092E:  XORLW  04
0930:  BZ    095C
0932:  XORLW  03
0934:  BZ    0968
0936:  XORLW  02
0938:  BZ    0974
093A:  XORLW  0D
093C:  BZ    0980
093E:  XORLW  03
0940:  BZ    098C
0942:  BRA    0998
.................... 		case WDT_TIMEOUT:       fprintf(STREAM_FTDI,"WDT TIMEOUT"); break;
0944:  MOVLW  90
0946:  MOVWF  FF6
0948:  MOVLW  04
094A:  MOVWF  FF7
094C:  RCALL  05B4
094E:  BRA    09A2
.................... 		case MCLR_FROM_SLEEP:   fprintf(STREAM_FTDI,"MCLR FROM SLEEP"); break;
0950:  MOVLW  9C
0952:  MOVWF  FF6
0954:  MOVLW  04
0956:  MOVWF  FF7
0958:  RCALL  05B4
095A:  BRA    09A2
.................... 		case MCLR_FROM_RUN:     fprintf(STREAM_FTDI,"MCLR FROM RUN"); break;
095C:  MOVLW  AC
095E:  MOVWF  FF6
0960:  MOVLW  04
0962:  MOVWF  FF7
0964:  RCALL  05B4
0966:  BRA    09A2
.................... 		case NORMAL_POWER_UP:   fprintf(STREAM_FTDI,"NORMAL POWER UP"); break;
0968:  MOVLW  BA
096A:  MOVWF  FF6
096C:  MOVLW  04
096E:  MOVWF  FF7
0970:  RCALL  05B4
0972:  BRA    09A2
.................... 		case BROWNOUT_RESTART:  fprintf(STREAM_FTDI,"BROWNOUT RESTART"); break;
0974:  MOVLW  CA
0976:  MOVWF  FF6
0978:  MOVLW  04
097A:  MOVWF  FF7
097C:  RCALL  05B4
097E:  BRA    09A2
.................... 		case WDT_FROM_SLEEP:    fprintf(STREAM_FTDI,"WDT FROM SLEEP"); break;
0980:  MOVLW  DC
0982:  MOVWF  FF6
0984:  MOVLW  04
0986:  MOVWF  FF7
0988:  RCALL  05B4
098A:  BRA    09A2
.................... 		case RESET_INSTRUCTION: fprintf(STREAM_FTDI,"RESET INSTRUCTION"); break;
098C:  MOVLW  EC
098E:  MOVWF  FF6
0990:  MOVLW  04
0992:  MOVWF  FF7
0994:  RCALL  05B4
0996:  BRA    09A2
.................... 		default:                fprintf(STREAM_FTDI,"UNKNOWN!");
0998:  MOVLW  FE
099A:  MOVWF  FF6
099C:  MOVLW  04
099E:  MOVWF  FF7
09A0:  RCALL  05B4
.................... 	}
.................... 	fprintf(STREAM_FTDI,"\r\n");
09A2:  MOVLW  0D
09A4:  BTFSS  F9E.4
09A6:  BRA    09A4
09A8:  MOVWF  FAD
09AA:  MOVLW  0A
09AC:  BTFSS  F9E.4
09AE:  BRA    09AC
09B0:  MOVWF  FAD
.................... 
.................... 
.................... 	timers.led_on_a=500;
09B2:  MOVLW  F4
09B4:  MOVWF  x63
.................... 
.................... 	enable_interrupts(GLOBAL);
09B6:  MOVLW  C0
09B8:  IORWF  FF2,F
.................... 
.................... 	/* enable I2C slave interrupt */
.................... 	enable_interrupts(INT_SSP);
09BA:  BSF    F9D.3
.................... 
.................... 	for ( ; ; ) {
.................... 		restart_wdt();
09BC:  CLRWDT
.................... 
.................... 		/* query INA228's for next */
.................... 		if ( timers.now_ina ) {
09BE:  BTFSS  x62.1
09C0:  BRA    09C4
.................... 			action_now_ina();
09C2:  BRA    078A
.................... 		}
.................... 
.................... 		if ( timers.now_millisecond ) {
09C4:  BTFSS  x62.0
09C6:  BRA    09CA
.................... 			periodic_millisecond();
09C8:  BRA    081C
.................... 		}
.................... 
.................... #if 0
.................... 		if ( timers.now_dump ) {
.................... 			timers.now_dump=0;
.................... 
.................... 			fprintf(STREAM_FTDI,"# A: 0x%08lx / 0x%08lx / 0x%04lu\r\n",
.................... 				current.vbus_a,
.................... 				current.vshunt_a,
.................... 				current.dietemp_a
.................... 			);
.................... 		}
.................... #endif
.................... 
.................... #if 0
09CA:  BRA    09BC
.................... 		if ( kbhit() ) {
.................... 			getc();
.................... 
.................... 			fprintf(STREAM_FTDI,"# DIP SWITCHES: %d\r\n",
.................... 				read_dip_switch()
.................... 			);
.................... 
.................... 			fprintf(STREAM_FTDI,"# A: 0x%08lx / 0x%08lx / 0x%04lu\r\n",
.................... 				current.vbus_a,
.................... 				current.vshunt_a,
.................... 				current.dietemp_a
.................... 			);
.................... 			fprintf(STREAM_FTDI,"# B: 0x%08lx / 0x%08lx / 0x%04lu\r\n",
.................... 				current.vbus_b,
.................... 				current.vshunt_b,
.................... 				current.dietemp_b
.................... 			);
.................... 
.................... 			fprintf(STREAM_FTDI,"# current.count_a_last_second=%lu\r\n",
.................... 				current.count_a_last_second
.................... 			);
.................... 			fprintf(STREAM_FTDI,"# current.count_b_last_second=%lu\r\n",
.................... 				current.count_b_last_second
.................... 			);
.................... 			fprintf(STREAM_FTDI,"# current.count_a_long=%lu\r\n",
.................... 				current.count_a_long
.................... 			);
.................... 			fprintf(STREAM_FTDI,"# current.count_b_long=%lu\r\n",
.................... 				current.count_b_long
.................... 			);
.................... 
.................... 			fprintf(STREAM_FTDI,"# current.count_seconds_long=%lu\r\n",
.................... 				current.count_seconds_long
.................... 			);
.................... 
.................... 			fprintf(STREAM_FTDI,"# input(PIC_ADDR_MSB)=%u\r\n",input(PIC_ADDR_MSB));
.................... 			fprintf(STREAM_FTDI,"# input(PIC_ADDR_LSB)=%u\r\n",input(PIC_ADDR_LSB));
.................... 		}
.................... #endif
.................... 
.................... 
.................... 	}
.................... 
.................... 
.................... }
09CC:  BRA    09CC

Configuration Fuses:
   Word  1: 2200   HS NOPLLEN PCLKEN NOFCMEN NOIESO
   Word  2: 0E19   NOPUT NOBROWNOUT BORV19 NOWDT WDT128
   Word  3: 0000   NOHFOFST NOMCLR
   Word  4: 0009   STVREN NOLVP BBSIZ2K NOXINST DEBUG
   Word  5: C003   NOPROTECT NOCPB NOCPD
   Word  6: E003   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 4003   NOEBTR NOEBTRB

   Some fuses have been forced to be compatible with the ICD debugger.

ROM data:
F00000: 00 00 40 00                                        ..@.
